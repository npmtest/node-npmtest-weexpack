{"/home/travis/build/npmtest/node-npmtest-weexpack/test.js":"/* istanbul instrument in package npmtest_weexpack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-weexpack/lib.npmtest_weexpack.js":"/* istanbul instrument in package npmtest_weexpack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_weexpack = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_weexpack = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-weexpack/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-weexpack && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_weexpack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_weexpack\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_weexpack.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_weexpack.rollup.js'] =\n            local.assetsDict['/assets.npmtest_weexpack.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_weexpack.__dirname + '/lib.npmtest_weexpack.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/index.js":"const chalk = require('chalk')\nconst initProject = require('./src/init/init')\nconst runAndroid = require('./src/run/Android')\nconst runIOS = require('./src/run/iOS')\nconst runWeb = require('./src/run/web')\n\n/**\n * Get current version\n */\nfunction getVersion() {\n  return require('./package.json').version\n}\n\n/**\n * Initialize a standard weex project\n * @param {String} project name\n * @param {String} config file path\n */\nfunction init(projectName = '', configFile = '') {\n  if (projectName.match(/^[$A-Z_][0-9A-Z_-]*$/i)) {\n    initProject(projectName, configFile)\n  } else {\n    console.log(`  ${chalk.red('Invalid project name:')} ${chalk.yellow(projectName)}`)\n  }\n}\n\n/**\n * Run weex app on the specific platform\n * @param {String} platform\n */\nfunction run(platform = '', options = {}) {\n  switch (platform) {\n    case 'android' : runAndroid(options); break;\n    case 'ios'     : runIOS(options);     break;\n    case 'web'     : runWeb(options);     break;\n\n    default : {\n      console.log(`  ${chalk.red('Unknown platform:')} ${chalk.yellow(platform)}`)\n    }\n  }\n}\n\nmodule.exports = {\n  getVersion,\n  init,\n  run,\n  runAndroid,\n  runIOS,\n  runWeb,\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/init/init.js":"const path = require('path')\nconst chalk = require('chalk')\nconst yeoman = require('yeoman-environment')\nconst TerminalAdapter = require('yeoman-environment/lib/adapter.js')\n\n/**\n * Create Silent TerminalAdapter\n * suppress 'create' output generated by yeoman\n */\nclass SilentTerminalAdapter extends TerminalAdapter {\n  constructor() {\n    super()\n    this.log.create = function() {}\n  }\n}\n\n/**\n * Initialize a standard weex project\n * @param {String} project name\n * @param {String} config file path\n */\nfunction init(projectName, configFile) {\n  console.log(` => ${chalk.blue('Initialize a new Weex app')} (${chalk.cyan(projectName)})`)\n\n  const env = yeoman.createEnv(null, null, new SilentTerminalAdapter())\n\n  env.register(\n    require.resolve(path.join(__dirname, '../../generator')),\n    'weex:app'\n  )\n\n  // TODO: get generator configs from configFile\n  const args = []\n\n  const generator = env.create('weex:app', {\n    args,\n    options: {\n      projectName,\n    }\n  })\n\n  generator.destinationRoot(projectName)\n  generator.run()\n}\n\nmodule.exports = init\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/run/Android.js":"const path = require('path')\nconst chalk = require('chalk')\nconst child_process = require('child_process')\nconst fs = require('fs')\nconst inquirer = require('inquirer')\nconst copy = require('recursive-copy')\nconst utils = require('../utils')\nconst startJSServer = require('./server')\nconst {Config,androidConfigResolver} = require('../utils/config')\n/**\n * Build and run Android app on a connected emulator or device\n * @param {Object} options\n */\nfunction runAndroid(options) {\n  console.log(` => ${chalk.blue.bold('npm install&build')}`)\n  utils.buildJS()\n    .then(()=> {\n      return new Promise((resolve, reject)=> {\n        copy('./dist/', 'platforms/android/app/src/main/assets/dist', {overwrite: true}, function (err) {\n          if (err) return reject(err);\n          else resolve();\n        })\n      });\n    })\n    .then(()=> {\n      startJSServer()\n      return {options}\n    })\n    .then(prepareAndroid)\n    .then(resolveConfig)\n    .then(findAndroidDevice)\n    .then(chooseDevice)\n    .then(reverseDevice)\n\n    .then(buildApp)\n    .then(installApp)\n    .then(runApp)\n    .catch((err) => {\n      if (err) {\n        console.log(chalk.red('Error:', err));\n      }\n    })\n}\n\n/**\n * Prepare\n * @param {Object} options\n */\nfunction prepareAndroid({options}) {\n  return new Promise((resolve, reject) => {\n    const rootPath = process.cwd()\n\n    if (!utils.checkAndroid(rootPath)) {\n      console.log(rootPath)\n      console.log(chalk.red('  Android project not found !'))\n      console.log()\n      console.log(`  You should run ${chalk.blue('weexpack create')} or ${chalk.blue('weexpack platform add android')}  first`)\n      reject()\n    }\n\n    console.log()\n    console.log(` => ${chalk.blue.bold('Will start Android app')}`)\n\n    // change working directory to android\n    process.chdir(path.join(rootPath, 'platforms/android'))\n\n    if (!process.env.ANDROID_HOME) {\n      console.log()\n      console.log(chalk.red('  Environment variable $ANDROID_HOME not found !'))\n      console.log()\n      console.log(`  You should set $ANDROID_HOME first.`)\n      console.log(`  See ${chalk.cyan('http://stackoverflow.com/questions/19986214/setting-android-home-enviromental-variable-on-mac-os-x')}`)\n      reject()\n    }\n\n    // try {\n    //   child_process.execSync(`adb kill-server`, {encoding: 'utf8'})\n    // } catch (e) {\n    //   reject()\n    // }\n    // try {\n    //   child_process.execSync(`adb start-server`, {encoding: 'utf8'})\n    // } catch (e) {\n    //   reject()\n    // }\n\n  try {\n    child_process.execSync(`adb start-server`, {encoding: 'utf8'})\n  } catch (e) {\n    reject()\n  }\n  try {\n    child_process.execSync(`adb devices`, {encoding: 'utf8'})\n  } catch (e) {\n    reject()\n  }\n    resolve({options, rootPath})\n  })\n}\nfunction resolveConfig({options,rootPath}) {\n  let androidConfig = new Config(androidConfigResolver, path.join(rootPath, 'android.config.json'));\n  return androidConfig.getConfig().then((config) => {\n    androidConfigResolver.resolve(config);\n    return {options, rootPath};\n  })\n}\n/**\n * find android devices\n * @param {Object} options\n */\nfunction findAndroidDevice({options}) {\n  return new Promise((resolve, reject) => {\n    let devicesInfo = ''\n    try {\n      devicesInfo = child_process.execSync(`adb devices`, {encoding: 'utf8'})\n    } catch (e) {\n      console.log(chalk.red(`adb devices failed, please make sure you have adb in your PATH.`))\n      console.log(`See ${chalk.cyan('http://stackoverflow.com/questions/27301960/errorunable-to-locate-adb-within-sdk-in-android-studio')}`)\n      reject()\n    }\n\n    let devicesList = utils.parseDevicesResult(devicesInfo)\n\n    resolve({devicesList, options})\n  })\n}\n\n/**\n * Choose one device to run\n * @param {Array} devicesList: name, version, id, isSimulator\n * @param {Object} options\n */\nfunction chooseDevice({devicesList, options}) {\n  return new Promise((resolve, reject) => {\n    if (devicesList && devicesList.length > 1) {\n      const listNames = [new inquirer.Separator(' = devices = ')]\n      for (const device of devicesList) {\n        listNames.push(\n          {\n            name: `${device}`,\n            value: device\n          }\n        )\n      }\n\n      inquirer.prompt([\n          {\n            type: 'list',\n            message: 'Choose one of the following devices',\n            name: 'chooseDevice',\n            choices: listNames\n          }\n        ])\n        .then((answers) => {\n          const device = answers.chooseDevice\n          resolve({device, options})\n        })\n    } else if (devicesList.length == 1) {\n      resolve({device: devicesList[0], options})\n    }\n    else {\n      reject('No android devices found.')\n    }\n  })\n}\n\n/**\n * Adb reverse device, allow device connect host network\n * @param {String} device\n * @param {Object} options\n */\nfunction reverseDevice({device, options}) {\n  return new Promise((resolve, reject) => {\n    try {\n      let s = child_process.execSync(`adb -s ${device} reverse tcp:8080 tcp:8080`, {encoding: 'utf8'})\n    } catch (e) {\n      console.error('reverse error[ignored]');\n      resolve({device, options})\n    }\n\n    resolve({device, options})\n  })\n}\n\n/**\n * Build the Android app\n * @param {String} device\n * @param {Object} options\n */\nfunction buildApp({device, options}) {\n  return new Promise((resolve, reject) => {\n    console.log(` => ${chalk.blue.bold('Building app ...')}`)\n\n    let clean = options.clean ? ' clean' : '';\n    try {\n      child_process.execSync(process.platform === 'win32' ? `call gradlew.bat${clean} assemble` : `./gradlew${clean} assemble`, {\n        encoding: 'utf8',\n        stdio: [0, 1, 2]\n      })\n    } catch (e) {\n      reject()\n    }\n\n    resolve({device, options})\n  })\n}\n\n/**\n * Install the Android app\n * @param {String} device\n * @param {Object} options\n */\nfunction installApp({device, options}) {\n  return new Promise((resolve, reject) => {\n    console.log(` => ${chalk.blue.bold('Install app ...')}`)\n\n    const apkName = 'app/build/outputs/apk/playground.apk'\n    try {\n      child_process.execSync(`adb -s ${device} install -r  ${apkName}`, {encoding: 'utf8'})\n    } catch (e) {\n      reject()\n    }\n\n    resolve({device, options})\n  })\n}\n\n/**\n * Run the Android app on emulator or device\n * @param {String} device\n * @param {Object} options\n */\nfunction runApp({device, options}) {\n  return new Promise((resolve, reject) => {\n    console.log(` => ${chalk.blue.bold('Running app ...')}`)\n\n    const packageName = fs.readFileSync(\n      'app/src/main/AndroidManifest.xml',\n      'utf8'\n    ).match(/package=\"(.+?)\"/)[1]\n\n\n    try {\n      child_process.execSync(`adb -s ${device} shell am start -n ${packageName}/.SplashActivity`, {encoding: 'utf8'})\n    } catch (e) {\n      reject(e)\n    }\n\n    resolve()\n  })\n}\n\nmodule.exports = runAndroid\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/utils/index.js":"const fs = require('fs')\nconst path = require('path');\nconst output = require('./output')\nconst validator = require('./validator')\nconst child_process = require('child_process')\nconst os =require('os')\nconst npm = require(\"npm\");\nconst utils = {\n\n  copyAndReplace(src, dest, replacements) {\n    if (fs.lstatSync(src).isDirectory()) {\n      if (!fs.existsSync(dest)) {\n        fs.mkdirSync(dest)\n      }\n    } else {\n      let content = fs.readFileSync(src, 'utf8')\n      Object.keys(replacements).forEach(regex => {\n        content = content.replace(new RegExp(regex, 'gm'), replacements[regex])\n      })\n      fs.writeFileSync(dest, content)\n    }\n  },\n\n  /**\n   * Find xcode project in particular directory\n   * @param {String} directory\n   * @return {Object} project info\n   */\n  findXcodeProject(dir) {\n    if(!fs.existsSync(dir)) {\n      return false;\n    }\n    const files = fs.readdirSync(dir)\n    const sortedFiles = files.sort()\n    for (let i = sortedFiles.length - 1; i >= 0; i--) {\n      const fileName = files[i]\n      const ext = path.extname(fileName)\n\n      if (ext === '.xcworkspace') {\n        return {\n          name: fileName,\n          isWorkspace: true,\n        }\n      }\n      if (ext === '.xcodeproj') {\n        return {\n          name: fileName,\n          isWorkspace: false,\n        }\n      }\n    }\n\n    return null\n  },\n\n  parseIOSDevicesList(text) {\n    const devices = []\n    const REG_DEVICE = /(.*?) \\((.*?)\\) \\[(.*?)]/\n\n    const lines = text.split('\\n')\n    for (const line of lines) {\n      if (line.indexOf('Watch') >= 0 || line.indexOf('TV') >= 0 || line.indexOf('iPad') >= 0) {\n        continue\n      }\n      const device = line.match(REG_DEVICE)\n      if (device !== null) {\n        const name = device[1]\n        const version = device[2]\n        const udid = device[3]\n        const isSimulator = line.indexOf('Simulator') >= 0||udid.indexOf('-')>=0\n        devices.push({name, version, udid, isSimulator})\n      }\n    }\n\n    return devices\n  },\n  parseDevicesResult(result) {\n    if (!result) {\n      return [];\n    }\n\n    const devices = [];\n    const lines = result.trim().split(/\\r?\\n/);\n\n    for (let i = 0; i < lines.length; i++) {\n      let words = lines[i].split(/[ ,\\t]+/).filter((w) => w !== '');\n\n      if (words[1] === 'device') {\n        devices.push(words[0]);\n      }\n    }\n    return devices;\n  },\n  exec(command,quiet){\n    return new Promise((resolve, reject)=> {\n      try {\n        let child = child_process.exec(command, {encoding: 'utf8'}, function () {\n          resolve();\n        })\n        if(!quiet){\n          child.stdout.pipe(process.stdout);\n        }\n        child.stderr.pipe(process.stderr);\n      }catch(e){\n        console.error('execute command failed :',command);\n        reject(e);\n      }\n    })\n\n  },\n  buildJS(cmd = 'build'){\n    return utils.exec('npm install',true).then(()=> {\n      return utils.exec('npm run ' + cmd)\n    })\n  },\n  getIOSProjectInfo(){\n    let projectInfoText=child_process.execSync('xcodebuild  -list', {encoding: 'utf8'});\n    let splits=projectInfoText.split(/Targets:|Build Configurations:|Schemes:/);\n    let projectInfo={};\n    projectInfo.name=splits[0].match(/Information about project \"([^\"]+?)\"/)[1];\n    projectInfo.targets=splits[1]?splits[1].split('\\n').filter(e=>!!e.trim()).map(e=>e.trim()):[];\n    projectInfo.configurations=splits[2]?splits[2].split('\\n').filter((e,i)=>!!e.trim()&&i<3).map(e=>e.trim()):[];\n    projectInfo.schemes=splits[3]?splits[3].split('\\n').filter(e=>!!e.trim()).map(e=>e.trim()):[];\n    return {project:projectInfo}\n  },\n  checkAndInstallForIosDeploy(){\n    let hasIosDeploy=fs.existsSync('./node_modules/.bin/ios-deploy');\n    if(!hasIosDeploy) {\n      let args='';\n      if(process.platform==='win32'){\n        console.log('run ios unsupported on windows');\n        process.exit(1);\n      }\n      if (os.release() >= '15.0.0') {\n        args=' --unsafe-perm=true --allow-root'\n      }\n      return this.exec(__dirname+'/installIosDeploy.sh'+args)\n    }\n    else {\n      return Promise.resolve();\n    }\n  },\n  xcopy(source,dest){\n    if(process.platform==='win32'){\n      cmd\n    }\n  },\n  dashToCamel(str) {\n    return str.replace(/(\\-[a-z])/g, function($1){return $1.toUpperCase().replace('-','');});  \n  },\n\n  isIOSProject:function (dir){\n    var result = this.findXcodeProject(dir)\n    return result;\n  },\n\n  isAndroidProject:function (dir){\n    if (fs.existsSync(path.join(dir, 'build.gradle'))) {\n      return true\n    }\n  },\n\n  isNewVersionPlugin : function(pluginName, version, callback) {\n    var trynum =0\n    npm.load(function(){\n      var load = function(npmName){\n\n          npm.commands.info([npmName+\"@\"+version], true, function(error,result){\n\n            if(error&&trynum==0){\n              trynum++;\n              if(npmName == \"weex-gcanvas\"){\n               var  prefix = \"weex-plugin--\"\n              }\n              else {\n               var  prefix = \"weex-plugin-\"\n              }\n              load(prefix+npmName)\n            }\n            else if(error&&trynum!==0){\n              throw  new Error(error)\n            }\n            else {\n              var weexpackVersion = result[version].weexpack ;\n\n              if(weexpackVersion&&weexpackVersion == \"0.4.0\"){\n                callback({\n                  ios: result[version].ios,\n                  android: result[version].android,\n                  version:result[version].version,\n                  name:result[version].name,\n                  weexpack:result[version].weexpack,\n                  pluginDependencies:result[version].pluginDependencies\n                })\n              }\n              else{\n                callback(false)\n              }\n            }\n\n          })\n\n\n      }\n      load(pluginName)\n\n    })\n\n\n}\n\n\n\n}\n\nmodule.exports = Object.assign(utils, output, validator)\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/utils/output.js":"\nmodule.exports = {\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/utils/validator.js":"const fs = require('fs')\nconst path = require('path')\n\n/**\n * Verifies this is an Android project\n * @param {String} root directory path\n */\nfunction checkAndroid(cwd) {\n  return fs.existsSync(path.join(cwd, 'platforms/android/gradlew'))\n}\n\n/**\n * Verifies there has a ios folder\n * @param {String} root directory path\n */\nfunction checkIOS(cwd) {\n  // return fs.existsSync(path.join(cwd, 'ios/playground'))\n  return fs.existsSync(path.join(cwd, 'platforms/ios'))\n}\n\n\n/**\n * Check if current cli is running on Windows platform\n */\nfunction isOnWindows() {\n  return /^win/.test(process.platform)\n}\n\n/**\n * Check if current cli is running on OSX platform\n */\nfunction isOnMac() {\n  return process.platform === 'darwin'\n}\n\n/**\n * Check if current cli is running on Linux platform\n */\nfunction isOnLinux() {\n  return process.platform === 'linux'\n}\n\nfunction isValidPackageName(name) {\n  return name.match(/^[$A-Z_][0-9A-Z_$]*$/i);\n}\n\nmodule.exports = {\n  checkAndroid,\n  checkIOS,\n  isOnWindows,\n  isOnMac,\n  isOnLinux,\n  isValidPackageName\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/run/server.js":"const child_process = require('child_process')\n\n/**\n * Start js bundle server\n * @param {Object} options\n */\nfunction startJSServer() {\n  let occupied = true;\n  try {\n\n    child_process.execSync(process.platform==='win32'?'netstat -aon|findstr \"8080\"':'lsof -i :8080', {encoding: 'utf8'});\n    //console.log(child_process.execSync(`open ./start`, {encoding: 'utf8'}))\n  } catch (e) {\n    occupied = false\n  }\n  if (!occupied) {\n    try {\n        child_process.exec(process.platform==='win32'?'start start.bat':`open ./start`, {encoding: 'utf8'})\n    }\n    catch (e){\n      console.error(e);\n    }\n\n  }\n  return occupied;\n}\n\nmodule.exports = startJSServer\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/utils/config.js":"/**\n * Created by godsong on 16/10/12.\n */\nconst Fs = require('fs');\nconst Path = require('path');\nconst Inquirer = require('inquirer');\nclass Config {\n  constructor(properties, path) {\n    this.path = path;\n    if (properties instanceof ConfigResolver) {\n      let map = {};\n      this.properties = [];\n      for (let key in properties.def) {\n        for (let propName in properties.def[key]) {\n          if (!map[propName]) {\n            this.properties.push({\n              name: propName,\n              desc: properties.def[key].desc || 'enter your ' + propName + ':'\n            });\n            map[propName] = true;\n          }\n        }\n      }\n    }\n    else {\n      this.properties = properties.split(',').map(prop=> {\n        var splits = prop.split('|');\n        return {\n          name: splits[0],\n          desc: splits[1] || 'enter your ' + splits[0] + ':'\n        }\n      });\n    }\n  }\n\n  getConfig() {\n    return new Promise((resolve, reject)=> {\n      let config = {};\n      try {\n        config = require(this.path);\n      }\n      catch (e) {\n      }\n      var questions = [], answers = {};\n      console.log('============build config============')\n      this.properties.forEach(function (prop) {\n        if (config[prop.name] !== undefined && config[prop.name] != '') {\n          answers[prop.name] = config[prop.name];\n          console.log(prop.name + '=>' + answers[prop.name]);\n        }\n        else {\n          questions.push({\n            type: 'input',\n            message: prop.desc,\n            name: prop.name\n          })\n        }\n      });\n      if (questions.length > 0) {\n        Inquirer.prompt(questions)\n          .then((answers) => {\n            Object.assign(config, answers);\n            Fs.writeFileSync(this.path, JSON.stringify(config, null, 4))\n            resolve(config);\n          })\n      }\n      else {\n        console.log('if you want to change build config.please modify ' + Path.basename(this.path));\n        resolve(config)\n      }\n    })\n\n  }\n}\nclass ConfigResolver {\n  constructor(def) {\n    this.def = def;\n  }\n\n  resolve(config, basePath) {\n    basePath = basePath || process.cwd();\n    for (let path in this.def) {\n      if (this.def.hasOwnProperty(path)) {\n        let targetPath = Path.join(basePath, path);\n        let source = Fs.readFileSync(targetPath).toString();\n        for (let key in this.def[path]) {\n          if (this.def[path].hasOwnProperty(key)) {\n            let configDef = this.def[path][key];\n            if (Array.isArray(configDef)) {\n              configDef.forEach((def)=> {\n                source = _resolveConfigDef(source, def, config, key)\n              })\n            }\n            else {\n              source = _resolveConfigDef(source, configDef, config, key);\n            }\n          }\n        }\n        Fs.writeFileSync(targetPath, source);\n      }\n\n    }\n  }\n}\nfunction _resolveConfigDef(source, configDef, config, key) {\n  if (configDef.type) {\n    if (config[key] === undefined) {\n      throw new Error('Config:[' + key + '] must have a value!');\n    }\n    return replacer[configDef.type](source, configDef.key, config[key]);\n  }\n  else {\n    return configDef.handler(source, config[key], replacer);\n  }\n}\nconst replacer = {\n  plist(source, key, value){\n    let r = new RegExp('(<key>' + key + '</key>\\\\s*<string>)[^<>]*?<\\/string>', 'g');\n    return source.replace(r, '$1' + value + '</string>')\n  },\n  xmlTag(source, key, value, tagName = 'string'){\n    let r = new RegExp(`<${tagName} name=\"${key}\">[^<]+?</${tagName}>`, 'g');\n    return source.replace(r, `<${tagName} name=\"${key}\">${value}</${tagName}>`);\n  },\n  xmlAttr(source, key, value, tagName = 'string'){\n    let r = new RegExp(`<${tagName} name=\"${key}\"\\\\s* value=\"[^\"]*?\"\\\\s*/>`, 'g');\n    return source.replace(r, `<${tagName} name=\"${key}\" value=\"${value}\"/>`);\n  },\n  regexp(source, regexp, value){\n    return source.replace(regexp, function (m, a, b) {\n      return a + value + (b || '');\n    })\n  }\n};\n\nexports.Config = Config;\nexports.ConfigResolver = ConfigResolver;\nexports.androidConfigResolver = new ConfigResolver({\n  'build.gradle': {\n    AppId: {\n      type: 'regexp',\n      key: /(applicationId \")[^\"]*(\")/g\n    }\n  },\n  'app/src/main/res/values/strings.xml': {\n    AppName: {\n      type: 'xmlTag',\n      key: 'app_name'\n    },\n    SplashText: {\n      type: 'xmlTag',\n      key: 'dummy_content'\n    }\n  },\n  'app/src/main/res/xml/app_config.xml': {\n    WeexBundle: {\n      handler: function (source, value, replacer) {\n        if (/https?/.test(value)) {\n          source = replacer.xmlAttr(source, 'launch_locally', 'false', 'preference');\n          return replacer.xmlAttr(source, 'launch_url', value,'preference');\n        }\n        else {\n          source = replacer.xmlAttr(source, 'launch_locally', 'true', 'preference');\n          let name=value.replace(/\\.(we|vue)$/, '.js');\n          //Fs.writeFileSync(Path.join(process.cwd(), 'app/src/main/assets/'+name),Fs.readFileSync(Path.join(process.cwd(), '../../dist', name)));\n\n          return replacer.xmlAttr(source, 'local_url', 'file://assets/dist/'+name,'preference');\n        }\n      }\n    }\n  }\n\n});\nexports.iOSConfigResolver = new ConfigResolver({\n  'WeexDemo/WeexDemo-Info.plist': {\n    AppName: {\n      type: 'plist',\n      key: 'CFBundleDisplayName'\n    },\n    Version: {\n      type: 'plist',\n      key: 'CFBundleShortVersionString'\n    },\n    BuildVersion: {\n      type: 'plist',\n      key: 'CFBundleVersion'\n    },\n    AppId: {\n      type: 'plist',\n      key: 'CFBundleIdentifier'\n    }\n\n  },\n  'WeexDemo.xcodeproj/project.pbxproj': {\n    CodeSign: [{\n      type: 'regexp',\n      key: /(\"?CODE_SIGN_IDENTITY(?:\\[sdk=iphoneos\\*])?\"?\\s*=\\s*\").*?(\")/g\n    }, {\n      type: 'plist',\n      key: 'CODE_SIGN_IDENTITY(\\\\[sdk=iphoneos\\\\*])?'\n    }\n    ],\n    Profile: [\n      {\n        type: 'regexp',\n        key: /(PROVISIONING_PROFILE\\s*=\\s*\")[^\"]*?(\")/g\n      },\n      {\n        type: 'plist',\n        key: 'PROVISIONING_PROFILE'\n      }\n    ]\n  }\n\n})\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/run/iOS.js":"const path = require('path')\nconst chalk = require('chalk')\nconst child_process = require('child_process')\nconst inquirer = require('inquirer')\nconst fs = require('fs')\nconst utils = require('../utils')\nconst startJSServer = require('./server')\nconst {Config,iOSConfigResolver} = require('../utils/config')\n/**\n * Run iOS app\n * @param {Object} options\n */\nfunction runIOS(options) {\n  utils.checkAndInstallForIosDeploy()\n    .then(utils.buildJS)\n    .then(()=>{\n      return utils.exec('rsync  -r -q ./dist/* platforms/ios/bundlejs/')\n    })\n    .then(()=> {\n      startJSServer()\n      return {options}\n    }).then(prepareIOS)\n     .then(installDep)\n    .then(findIOSDevice)\n    .then(chooseDevice)\n    .then(buildApp)\n    .then(runApp)\n    .catch((err) => {\n      if (err) {\n        try {\n          if(err.stderr){\n            console.log(err.stderr)\n          }\n          else{\n            console.log(err);\n          }\n          if(err.output)console.log(err.output.join('\\n'))\n        }catch(e){\n          console.log(e);\n        }\n      }\n    })\n}\n\n/**\n * Prepare\n * @param {Object} options\n */\nfunction prepareIOS({options}) {\n  return new Promise((resolve, reject) => {\n    const rootPath = process.cwd()\n    if (!utils.checkIOS(rootPath)) {\n      console.log()\n      console.log(chalk.red('  iOS project not found !'))\n      console.log()\n      console.log(`  You should run ${chalk.blue('weexpack create')} or ${chalk.blue('weexpack platform add ios')} first`)\n      reject()\n    }\n\n    // change working directory to ios\n    process.chdir(path.join(rootPath, 'platforms/ios'))\n\n    const xcodeProject = utils.findXcodeProject(process.cwd())\n\n    if (xcodeProject) {\n      console.log()\n      console.log(` => ${chalk.blue.bold('Will start iOS app')}`)\n      resolve({xcodeProject, options, rootPath})\n    } else {\n      console.log()\n      console.log(`  ${chalk.red.bold('Could not find Xcode project files in ios folder')}`)\n      console.log()\n      console.log(`  Please make sure you have installed iOS Develop Environment and CocoaPods`)\n      console.log(`  See ${chalk.cyan('http://alibaba.github.io/weex/doc/advanced/integrate-to-ios.html')}`)\n      reject()\n    }\n  })\n}\n\n/**\n * Install dependency\n * @param {Object} xcode project\n * @param {Object} options\n */\nfunction installDep({xcodeProject, options,rootPath}) {\n  console.log(` => ${chalk.blue.bold('pod update')}`)\n  return utils.exec('pod update').then(()=>({xcodeProject, options, rootPath}))\n}\n\n/**\n * find ios devices\n * @param {Object} xcode project\n * @param {Object} options\n * @return {Array} devices lists\n */\nfunction findIOSDevice({xcodeProject, options,rootPath}) {\n  return new Promise((resolve, reject) => {\n    let deviceInfo = ''\n    try {\n      deviceInfo = child_process.execSync('xcrun instruments -s devices', {encoding: 'utf8'})\n    } catch (e) {\n      reject(e)\n    }\n    let devicesList = utils.parseIOSDevicesList(deviceInfo)\n    resolve({devicesList, xcodeProject, options, rootPath})\n  })\n}\n\n/**\n * Choose one device to run\n * @param {Array} devicesList: name, version, id, isSimulator\n * @param {Object} xcode project\n * @param {Object} options\n * @return {Object} device\n */\nfunction chooseDevice({devicesList, xcodeProject, options,rootPath}) {\n  return new Promise((resolve, reject) => {\n    if (devicesList && devicesList.length > 0) {\n      const listNames = [new inquirer.Separator(' = devices = ')]\n      for (const device of devicesList) {\n        listNames.push(\n          {\n            name: `${device.name} ios: ${device.version}`,\n            value: device\n          }\n        )\n      }\n\n      inquirer.prompt([\n          {\n            type: 'list',\n            message: 'Choose one of the following devices',\n            name: 'chooseDevice',\n            choices: listNames\n          }\n        ])\n        .then((answers) => {\n          const device = answers.chooseDevice\n          resolve({device, xcodeProject, options, rootPath})\n        })\n    } else {\n      reject('No ios devices found.')\n    }\n  })\n}\n\n/**\n * build the iOS app on simulator or real device\n * @param {Object} device\n * @param {Object} xcode project\n * @param {Object} options\n */\nfunction buildApp({device, xcodeProject, options,rootPath}) {\n  return new Promise((resolve, reject) => {\n    let projectInfo = ''\n    try {\n      projectInfo = utils.getIOSProjectInfo();\n    } catch (e) {\n      reject(e)\n    }\n\n    const scheme = projectInfo.project.schemes[0]\n\n    if (device.isSimulator) {\n      _buildOnSimulator({scheme, device, xcodeProject, options, resolve, reject, rootPath})\n    } else {\n      _buildOnRealDevice({scheme, device, xcodeProject, options, resolve, reject, rootPath})\n    }\n  })\n}\n\n/**\n * build the iOS app on simulator\n * @param {Object} device\n * @param {Object} xcode project\n * @param {Object} options\n */\nfunction _buildOnSimulator({scheme, device, rootPath,xcodeProject, options, resolve, reject}) {\n  console.log('project is building ...')\n  let buildInfo = ''\n  try {\n    let config=require(path.join(rootPath,'ios.config.json'));\n    fs.writeFileSync(path.join(process.cwd(), 'bundlejs/index.js'), fs.readFileSync(path.join(process.cwd(), '../../dist', config.WeexBundle.replace(/\\.(we|vue)$/, '.js'))));\n\n    buildInfo = child_process.execSync(`xcodebuild -${xcodeProject.isWorkspace ? 'workspace' : 'project'} ${xcodeProject.name} -scheme ${scheme} -configuration Debug -destination id=${device.udid} -sdk iphonesimulator -derivedDataPath build clean build`, {encoding: 'utf8'})\n  } catch (e) {\n    reject(e)\n  }\n  resolve({device, xcodeProject, options})\n}\n\n/**\n * build the iOS app on real device\n * @param {Object} device\n * @param {Object} xcode project\n * @param {Object} options\n */\nfunction _buildOnRealDevice({scheme, device, xcodeProject, options, resolve, reject,rootPath}) {\n  // @TODO support debug on real device\n  let iOSConfig = new Config(iOSConfigResolver, path.join(rootPath, 'ios.config.json'))\n  iOSConfig.getConfig().then((config) => {\n    try {\n      iOSConfigResolver.resolve(config);\n      fs.writeFileSync(path.join(process.cwd(), 'bundlejs/index.js'), fs.readFileSync(path.join(process.cwd(), '../../dist', config.WeexBundle.replace(/\\.we$/, '.js'))));\n      resolve({device, xcodeProject, options, rootPath});\n    }\n    catch (e) {\n      console.log(e);\n    }\n\n  }, (e)=>reject(e))\n\n}\n\n/**\n * Run the iOS app on simulator or device\n * @param {Object} device\n * @param {Object} xcode project\n * @param {Object} options\n */\nfunction runApp({device, xcodeProject, options}) {\n  return new Promise((resolve, reject) => {\n    if (device.isSimulator) {\n      _runAppOnSimulator({device, xcodeProject, options, resolve, reject})\n    } else {\n      _runAppOnDevice({device, xcodeProject, options, resolve, reject})\n    }\n  })\n}\n\n/**\n * Run the iOS app on simulator\n * @param {Object} device\n * @param {Object} xcode project\n * @param {Object} options\n */\nfunction _runAppOnSimulator({device, xcodeProject, options, resolve, reject}) {\n  const inferredSchemeName = path.basename(xcodeProject.name, path.extname(xcodeProject.name))\n  const appPath = `build/Build/Products/Debug-iphonesimulator/${inferredSchemeName}.app`\n  const bundleID = child_process.execFileSync(\n    '/usr/libexec/PlistBuddy',\n    ['-c', 'Print:CFBundleIdentifier', path.join(appPath, 'Info.plist')],\n    {encoding: 'utf8'}\n  ).trim()\n\n  let simctlInfo = ''\n  try {\n    simctlInfo = child_process.execSync('xcrun simctl list --json devices', {encoding: 'utf8'})\n  } catch (e) {\n    reject(e)\n  }\n  simctlInfo = JSON.parse(simctlInfo)\n\n  if (!simulatorIsAvailable(simctlInfo, device)) {\n    reject('simulator is not available!')\n  }\n\n  console.log(`Launching ${device.name}...`)\n\n  try {\n    child_process.execSync(`xcrun instruments -w ${device.udid}`, {encoding: 'utf8'})\n  } catch (e) {\n    // instruments always fail with 255 because it expects more arguments,\n    // but we want it to only launch the simulator\n  }\n\n  console.log(`Installing ${appPath}`)\n\n  try {\n    child_process.execSync(`xcrun simctl install booted ${appPath}`, {encoding: 'utf8'})\n  } catch (e) {\n    reject(e)\n  }\n\n  try {\n    child_process.execSync(`xcrun simctl launch booted ${bundleID}`, {encoding: 'utf8'})\n  } catch (e) {\n    reject(e)\n  }\n  console.log('Success!')\n  resolve()\n}\n\n/**\n * check simulator is available\n * @param {JSON} info simulator list\n * @param {Object} device user choose one\n * @return {boolean} simulator is available\n */\nfunction simulatorIsAvailable(info, device) {\n  info = info.devices\n  simList = info['iOS ' + device.version]\n  for (const sim of simList) {\n    if (sim.udid === device.udid) {\n      return sim.availability === '(available)'\n    }\n  }\n}\n\n/**\n * Run the iOS app on device\n * @param {Object} device\n * @param {Object} xcode project\n * @param {Object} options\n */\nfunction _runAppOnDevice({device, xcodeProject, options, resolve, reject}) {\n  // @TODO support run on real device\n  const appPath = `build/Debug-iphoneos/WeexDemo.app`\n  const deviceId = device.udid\n  try {\n    if (!fs.existsSync(appPath)) {\n      console.log('building...');\n      child_process.execSync(path.join(__dirname, '../build/lib/cocoapods-build') + ' . Debug', {encoding: 'utf8'})\n\n    }\n\n    console.log(child_process.execSync(`../../node_modules/.bin/ios-deploy --justlaunch --debug --id ${deviceId} --bundle ${path.resolve(appPath)}`, {encoding: 'utf8'}))\n  } catch (e) {\n    reject(e)\n  }\n  console.log('Success!')\n  // reject('Weex-Pack don\\'t support run on real device. see you next version!')\n}\n\n\nmodule.exports = runIOS\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/run/web.js":"const fs = require('fs')\nconst path = require('path')\nconst chalk = require('chalk')\nconst child_process = require('child_process')\nconst startJSServer = require('./server')\nconst util = require('../utils')\nconst opener = require('opener');\n/**\n * Start web service\n * @param {Object} options\n */\nfunction runWeb(options) {\n  if (!checkWebEnv(process.cwd())) {\n    console.log()\n    console.log(chalk.red('  Not available web environment !'))\n    console.log()\n    console.log(`  You should run ${chalk.blue('weexpack init')} first`)\n    return\n  }\n\n  console.log()\n  console.log(` => ${chalk.blue.bold('Starting web service')}`)\n\n  util.buildJS().then(function () {\n    let exist = startJSServer();\n    //没办法无法预知服务器啥时候完成\n    setTimeout(function () {\n      preview()\n    }, exist ? 0 : 2000)\n\n  })\n\n}\n\n/**\n * Check web environment\n * @param {Strng} cwd\n */\nfunction checkWebEnv(cwd) {\n  return fs.existsSync(path.join(cwd, 'package.json'))\n    && fs.existsSync(path.join(cwd, 'web'))\n}\n\n/**\n * Preview in browser\n */\nfunction preview() {\n  console.log(` => ${chalk.green('server is running')}`)\n  console.log(`    please open ${chalk.cyan('http://localhost:8080/web/index.html')}`)\n  opener('http://localhost:8080/web/index.html');\n\n\n  // open url in browser\n  // try {\n  //   child_process.execSync(`open http://localhost:8080/web/index.html`, {encoding: 'utf8'})\n  // } catch(e) {}\n}\n\nmodule.exports = runWeb\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/bin/weexpack-create.js":"#!/usr/bin/env node\n\nconst program = require('commander');\nconst chalk = require('chalk');\nconst create = require('../src/create/create');\nconst cli = require('../src/cli');\nconst publish = require('../src/publish/publish');\n\nprogram.usage('[project-name] [options]').on('--help', () => {\n  console.log('  Examples:\\n');\n  console.log(chalk.grey('    # create a standard weex project'));\n  console.log('    $ ' + chalk.blue('weexpack create myProject'));\n  console.log();\n}).parse(process.argv)\n\n\n\nlet args=[];\nprocess.argv.forEach(function(arg,i){\n  if(arg!='[object Object]') {//fix commander’s bug\n    args.push(arg);\n    if (i == 1) {\n      args.push('create');\n    }\n  }\n});\n\nconst projectName = args[3]\n\nif (!projectName || !projectName.match(/^[$A-Z_][0-9A-Z_-]*$/i)) {\n  var msg = chalk.red('Invalid project name: ') + chalk.yellow(projectName);\n  console.log(msg);\n  process.exit();\n}\n\ncli(args);\n\n\nif (program.args.length < 1) {\n  program.help();\n  process.exit();\n}","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/create/create.js":"/**\n * Created by yangshengtao on 16/11/28.\n */\n\nconst path = require('path')\nconst chalk = require('chalk')\nconst yeoman = require('yeoman-environment')\nconst TerminalAdapter = require('yeoman-environment/lib/adapter.js')\n\n/**\n * Create Silent TerminalAdapter\n * suppress 'create' output generated by yeoman\n */\nclass SilentTerminalAdapter extends TerminalAdapter {\n  constructor() {\n    super()\n    this.log.create = function() {}\n  }\n}\n\n/**\n * Create a weex plugin template\n * @param {String} plugin name\n * @param {String} config file path\n */\nfunction create(pluginName, configFile) {\n  console.log(` => ${chalk.blue('Create a new Weex plugin')} (${chalk.cyan(pluginName)})`)\n\n  const env = yeoman.createEnv(null, null, new SilentTerminalAdapter())\n\n  env.register(\n    require.resolve(path.join(__dirname, '../../pluginTemplate')),\n    'weex:app'\n  )\n\n  // TODO: get generator configs from configFile\n  const args = []\n\n  const generator = env.create('weex:app', {\n    args,\n    options: {\n      pluginName,\n    }\n  })\n\n  generator.destinationRoot(pluginName)\n  generator.run()\n}\n\nmodule.exports = create;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/cli.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint node:true, bitwise:true, undef:true, trailing:true, quotmark:true,\n          indent:4, unused:vars, latedef:nofunc,\n          laxcomma:true\n*/\n\n\nvar path = require('path'),\n    fs = require('fs'),\n    help = require('./help'),\n    nopt,\n    _,\n    updateNotifier,\n    pkg = require('../package.json'),\n    telemetry = require('./telemetry'),\n    Q = require('q');\nvar { prefix } = require('./utils/npm');\n\nvar cordova_lib = require('../lib'),\n    CordovaError = cordova_lib.CordovaError,\n    WeexpackError = cordova_lib.CordovaError,\n    cordova = cordova_lib.cordova,\n    events = cordova_lib.events,\n    logger = require('weexpack-common').CordovaLogger.get();\n\n\n/*\n * init\n *\n * initializes nopt and underscore\n * nopt and underscore are require()d in try-catch below to print a nice error\n * message if one of them is not installed.\n */\nfunction init() {\n    try {\n        nopt = require('nopt');\n        _ = require('underscore');\n        updateNotifier = require('update-notifier');\n    } catch (e) {\n        console.error(\n            'Please run npm install from this directory:\\n\\t' +\n            path.dirname(__dirname)\n        );\n        process.exit(2);\n    }\n}\n\nfunction checkForUpdates() {\n    try {\n        // Checks for available update and returns an instance\n        var notifier = updateNotifier({\n            pkg: pkg\n        });\n\n        // Notify using the built-in convenience method\n        notifier.notify();\n    } catch (e) {\n        // https://issues.apache.org/jira/browse/CB-10062\n        if (e && e.message && /EACCES/.test(e.message)) {\n            console.log('Update notifier was not able to access the config file.\\n' +\n                'You may grant permissions to the file: \\'sudo chmod 744 ~/.config/configstore/update-notifier-cordova.json\\'');\n        } else {\n            throw e;\n        }\n    }\n}\n\nvar shouldCollectTelemetry = false;\nmodule.exports = function (inputArgs, cb) {\n\n    /**\n     * mainly used for testing.\n     */\n    cb = cb || function(){};\n\n    init();\n\n    // If no inputArgs given, use process.argv.\n    inputArgs = inputArgs || process.argv;\n    var cmd = inputArgs[2]; // e.g: inputArgs= 'node cordova run ios'\n    var subcommand = getSubCommand(inputArgs, cmd);\n    var isTelemetryCmd = (false && cmd === 'telemetry');\n\n    // ToDO: Move nopt-based parsing of args up here\n    if(cmd === '--version' || cmd === '-v') {\n        cmd = 'version';\n    } else if(!cmd || cmd === '--help' || cmd === 'h') {\n        cmd = 'help';\n    }\n\n    Q().then(function (collectTelemetry) {\n        shouldCollectTelemetry = collectTelemetry;\n        if(isTelemetryCmd) {\n            return Q();\n        }\n        return cli(inputArgs);\n    }).then(function () {\n        if (shouldCollectTelemetry && !isTelemetryCmd) {\n            telemetry.track(cmd, subcommand, 'successful');\n        }\n        // call cb with error as arg if something failed\n        cb(null);\n    }).fail(function (err) {\n        if (shouldCollectTelemetry && !isTelemetryCmd) {\n            telemetry.track(cmd, subcommand, 'unsuccessful');\n        }\n        // call cb with error as arg if something failed\n        cb(err);\n        throw err;\n    }).done();\n};\n\nfunction getSubCommand(args, cmd) {\n    var subCommands = [\n        'platform',\n        'platforms',\n        'plugin',\n        'plugins',\n       // 'telemetry'\n    ];\n    if(subCommands.indexOf(cmd)) {\n        return args[3];\n    }\n    return null;\n}\n\nfunction handleTelemetryCmd(subcommand, isOptedIn) {\n\n    if (subcommand !== 'on' && subcommand !== 'off') {\n        logger.subscribe(events);\n        return help(['telemetry']);\n    }\n\n    var turnOn = subcommand === 'on' ? true : false;\n    var cmdSuccess = true;\n\n    // turn telemetry on or off\n    try {\n        if (turnOn) {\n            telemetry.turnOn();\n            console.log(\"Thanks for opting into telemetry to help us improve weexpack.\");\n        } else {\n            telemetry.turnOff();\n            console.log(\"You have been opted out of telemetry. To change this, run: weexpack telemetry on.\");\n        }\n    } catch (ex) {\n        cmdSuccess = false;\n    }\n\n    // track or not track ?, that is the question\n\n    if (!turnOn) {\n        // Always track telemetry opt-outs (whether user opted out or not!)\n        telemetry.track('telemetry', 'off', 'via-cordova-telemetry-cmd', cmdSuccess ? 'successful': 'unsuccessful');\n        return Q();\n    }\n\n    if(isOptedIn) {\n        telemetry.track('telemetry', 'on', 'via-cordova-telemetry-cmd', cmdSuccess ? 'successful' : 'unsuccessful');\n    }\n\n    return Q();\n}\n\nfunction cli(inputArgs) {\n    // When changing command line arguments, update doc/help.txt accordingly.\n    var knownOpts =\n        { 'verbose' : Boolean\n        , 'version' : Boolean\n        , 'help' : Boolean\n        , 'silent' : Boolean\n        , 'experimental' : Boolean\n        , 'noregistry' : Boolean\n        , 'nohooks': Array\n        , 'shrinkwrap' : Boolean\n        , 'copy-from' : String\n        , 'link-to' : path\n        , 'searchpath' : String\n        , 'variable' : Array\n        , 'link': Boolean\n        , 'force': Boolean\n        // Flags to be passed to `cordova build/run/emulate`\n        , 'debug' : Boolean\n        , 'release' : Boolean\n        , 'market':String\n        , 'archs' : String\n        , 'device' : Boolean\n        , 'emulator': Boolean\n        , 'target' : String\n        , 'browserify': Boolean\n        , 'noprepare': Boolean\n        , 'fetch': Boolean\n        , 'nobuild': Boolean\n        , 'list': Boolean\n        , 'buildConfig' : String\n        , 'template' : String\n        , 'ali' : Boolean\n\n        };\n\n    var shortHands =\n        { 'd' : '--verbose'\n        , 'v' : '--version'\n        , 'h' : '--help'\n        , 'src' : '--copy-from'\n        , 't' : '--template'\n        , 'a' : '--ali'\n        };\n\n    checkForUpdates();\n\n    var args = nopt(knownOpts, shortHands, inputArgs);\n    // For CordovaError print only the message without stack trace unless we\n    // are in a verbose mode.\n    process.on('uncaughtException', function(err) {\n        logger.error(err);\n        // Don't send exception details, just send that it happened\n        if(shouldCollectTelemetry) {\n            telemetry.track('uncaughtException');\n        }\n        process.exit(1);\n    });\n\n    logger.subscribe(events);\n\n    if (args.silent) {\n        logger.setLevel('error');\n    }\n\n    if (args.verbose) {\n        logger.setLevel('verbose');\n    }\n\n    var cliVersion = require('../package').version;\n    // TODO: Use semver.prerelease when it gets released\n    var usingPrerelease = /-nightly|-dev$/.exec(cliVersion);\n    if (args.version || usingPrerelease) {\n        var libVersion = require('cordova-lib/package').version;\n        var toPrint = cliVersion;\n        if (cliVersion != libVersion || usingPrerelease) {\n            toPrint += ' (cordova-lib@' + libVersion + ')';\n        }\n\n        if (args.version) {\n            logger.results(toPrint);\n            return Q();\n        } else {\n            // Show a warning and continue\n            logger.warn('Warning: using prerelease version ' + toPrint);\n        }\n    }\n\n    if (/^v0.\\d+[.\\d+]*/.exec(process.version)) { // matches v0.*\n        var msg = 'Warning: using node version ' + process.version +\n                ' which has been deprecated. Please upgrade to the latest node version available (v6.x is recommended).';\n        logger.warn(msg);\n    }\n\n    // If there were arguments protected from nopt with a double dash, keep\n    // them in unparsedArgs. For example:\n    // cordova build ios -- --verbose --whatever\n    // In this case \"--verbose\" is not parsed by nopt and args.vergbose will be\n    // false, the unparsed args after -- are kept in unparsedArgs and can be\n    // passed downstream to some scripts invoked by Cordova.\n    var unparsedArgs = [];\n    var parseStopperIdx =  args.argv.original.indexOf('--');\n    if (parseStopperIdx != -1) {\n        unparsedArgs = args.argv.original.slice(parseStopperIdx + 1);\n    }\n\n    // args.argv.remain contains both the undashed args (like platform names)\n    // and whatever unparsed args that were protected by \" -- \".\n    // \"undashed\" stores only the undashed args without those after \" -- \" .\n    var remain = args.argv.remain;\n    var undashed = remain.slice(0, remain.length - unparsedArgs.length);\n    var cmd = undashed[0];\n    var subcommand;\n    var msg;\n    var known_platforms = Object.keys(cordova_lib.cordova_platforms);\n\n    if ( !cmd || cmd == 'help' || args.help ) {\n        if (!args.help && remain[0] == 'help') {\n            remain.shift();\n        }\n        return help(remain);\n    }\n\n    if ( !cordova.hasOwnProperty(cmd) ) {\n        msg =\n            'weexpack doesn\\'t know command: ' + cmd + '; try ` weexpack help` for a list of all the available commands.';\n        throw new WeexpackError(msg);\n    }\n\n    var opts = {\n        platforms: [],\n        options: [],\n        verbose: args.verbose || false,\n        silent: args.silent || false,\n        browserify: args.browserify || false,\n        fetch: args.fetch || false,\n        nohooks: args.nohooks || [],\n        searchpath : args.searchpath,\n        ali:args.ali\n    };\n\n    var cmdList = [\n      'emulate',\n     // 'build',\n     //  'run'\n      'prepare',\n      'compile',\n      'clean'\n    ];\n\n    if (cmdList.indexOf(cmd)>=0) {\n        // All options without dashes are assumed to be platform names\n        opts.platforms = undashed.slice(1);\n        var badPlatforms = _.difference(opts.platforms, known_platforms);\n        if( !_.isEmpty(badPlatforms) ) {\n            msg = 'Unknown platforms: ' + badPlatforms.join(', ');\n            throw new WeexpackError(msg);\n        }\n\n        // Pass nopt-parsed args to PlatformApi through opts.options\n        opts.options = args;\n        opts.options.argv = unparsedArgs;\n\n        if (cmd === 'run' && args.list && cordova.raw.targets) {\n            return cordova.raw.targets.call(null, opts);\n        }\n\n        return cordova.raw[cmd].call(null, opts);\n    } else if (cmd === 'requirements') {\n        // All options without dashes are assumed to be platform names\n        opts.platforms = undashed.slice(1);\n        var badPlatforms = _.difference(opts.platforms, known_platforms);\n        if( !_.isEmpty(badPlatforms) ) {\n            msg = 'Unknown platforms: ' + badPlatforms.join(', ');\n            throw new CordovaError(msg);\n        }\n\n        return cordova.raw[cmd].call(null, opts.platforms)\n            .then(function(platformChecks) {\n\n                var someChecksFailed = Object.keys(platformChecks).map(function(platformName) {\n                    events.emit('log', '\\nRequirements check results for ' + platformName + ':');\n                    var platformCheck = platformChecks[platformName];\n                    if (platformCheck instanceof CordovaError) {\n                        events.emit('warn', 'Check failed for ' + platformName + ' due to ' + platformCheck);\n                        return true;\n                    }\n\n                    var someChecksFailed = false;\n                    platformCheck.forEach(function(checkItem) {\n                        var checkSummary = checkItem.name + ': ' +\n                            (checkItem.installed ? 'installed ' : 'not installed ') +\n                            (checkItem.metadata.version || '');\n                        events.emit('log', checkSummary);\n                        if (!checkItem.installed) {\n                            someChecksFailed = true;\n                            events.emit('warn', checkItem.metadata.reason);\n                        }\n                    });\n\n                    return someChecksFailed;\n                }).some(function(isCheckFailedForPlatform) {\n                    return isCheckFailedForPlatform;\n                });\n\n                if (someChecksFailed) throw new CordovaError('Some of requirements check failed');\n            });\n    } else if (cmd == 'serve') {\n        var port = undashed[1];\n        return cordova.raw.serve(port);\n    } else if (cmd == 'create') {\n        return create();\n    } else {\n        // platform/plugins add/rm [target(s)]\n        subcommand = undashed[1]; // sub-command like \"add\", \"ls\", \"rm\" etc.\n        var targets = undashed.slice(2); // array of targets, either platforms or plugins\n        var cli_vars = {};\n        if (args.variable) {\n            args.variable.forEach(function (s) {\n                // CB-9171\n                var eq = s.indexOf('=');\n                if (eq == -1)\n                    throw new WeexpackError(\"invalid variable format: \" + s);\n                var key = s.substr(0, eq).toUpperCase();\n                var val = s.substr(eq + 1, s.length);\n                cli_vars[key] = val;\n            });\n        }\n        var download_opts = { searchpath : args.searchpath\n                            , noregistry : args.noregistry\n                            , nohooks : args.nohooks\n                            , cli_variables : cli_vars\n                            , browserify: args.browserify || false\n                            , fetch: args.fetch || false\n                            , link: args.link || false\n                            , save: args.save || false\n                            , shrinkwrap: args.shrinkwrap || false\n                            , force: args.force || false\n                            , ali: args.ali || false\n                            };\n\n        return cordova.raw[cmd](subcommand, targets, download_opts);\n    }\n\n    function create() {\n        var cfg;            // Create config\n        var customWww;      // Template path\n        var wwwCfg;         // Template config\n\n        // If we got a fourth parameter, consider it to be JSON to init the config.\n        if (undashed[4])\n            cfg = JSON.parse(undashed[4]);\n        else\n            cfg = {};\n\n        customWww = args['copy-from'] || args['link-to'] || args.template;\n\n        if (customWww) {\n            if (!args.template && !args['copy-from'] && customWww.indexOf('http') === 0) {\n                throw new CordovaError(\n                    'Only local paths for custom www assets are supported for linking' + customWww\n                );\n            }\n\n            // Resolve tilda\n            if (customWww.substr(0,1) === '~')\n                customWww = path.join(process.env.HOME,  customWww.substr(1));\n\n            wwwCfg = {\n                url: customWww,\n                template: false,\n                link: false\n            };\n\n            if (args['link-to']) {\n                wwwCfg.link = true;\n            }\n            if (args.template) {\n                wwwCfg.template = true;\n            } else if (args['copy-from']) {\n                logger.warn('Warning: --copy-from option is being deprecated. Consider using --template instead.');\n                wwwCfg.template = true;\n            }\n\n            cfg.lib = cfg.lib || {};\n            cfg.lib.www = wwwCfg;\n        }\n\n        return cordova.raw.create( undashed[1]  // dir to create the project in\n            , undashed[2]  // App id\n            , undashed[3]  // App name\n            , cfg\n            , events || undefined\n        );\n    }\n}\n\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/help.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\nvar fs = require('fs'),\n    cordova_lib = require('../lib'),\n    cordova = cordova_lib.cordova,\n    Q = require('q'),\n    path = require('path');\n\nmodule.exports = function help (args) {\n    var command,\n        file,\n        raw,\n        docdir;\n    args = args || [];\n    command = ((args)[0] || 'weexpack');\n    docdir = path.join(__dirname, '..', 'doc');\n    file = [\n      command + '.md',\n      command + '.txt',\n      'cordova.md',\n      'cordova.txt',\n    ].map(function (file) {\n        var f = path.join(docdir, file);\n        if (fs.existsSync(f)) {\n           return f;\n        }\n        return null;\n    }).filter(function (f) {\n        return f !== null;\n    });\n    if(file && file[0] ) {\n      raw = fs.readFileSync(file[0]).toString('utf8').replace(/cordova-cli/g, cordova_lib.binname);\n      cordova.emit('results', raw);\n    }\n\n    return Q();\n};\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/index.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n// For now expose plugman and cordova just as they were in the old repos\n\n\nfunction addProperty(obj, property, modulePath) {\n    // Add properties as getter to delay load the modules on first invocation\n    Object.defineProperty(obj, property, {\n        configurable: true,\n        get: function () {\n            var module = require(modulePath);\n            // We do not need the getter any more\n            obj[property] = module;\n            return module;\n        }\n    });\n}\n\nexports = module.exports = {\n    set binname(name) {\n        this.cordova.binname = name;\n    },\n    get binname() {\n        return this.cordova.binname;\n    },\n    get events() { return require('weexpack-common').events },\n    get configparser() { return require('weexpack-common').ConfigParser },\n    get PluginInfo() { return require('weexpack-common').PluginInfo },\n    get CordovaError() { return require('weexpack-common').CordovaError }\n\n};\n\naddProperty(module.exports, 'plugman', './src/plugman/plugman');\naddProperty(module.exports, 'cordova', './src/cordova/cordova');\naddProperty(module.exports, 'cordova_platforms', './src/platforms/platforms');","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/cordova/cordova.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar cordova_events = require('weexpack-common').events;\nvar cordova_util = require('./util');\n\nvar off = function() {\n    cordova_events.removeListener.apply(cordova_events, arguments);\n};\n\nvar emit = function() {\n    cordova_events.emit.apply(cordova_events, arguments);\n};\n\nexports = module.exports = {\n    get binname() { return cordova_util.binname; },\n    set binname(name) { cordova_util.binname = name; },\n    on:        function() {\n        cordova_events.on.apply(cordova_events, arguments);\n    },\n    off:       off,\n    removeListener:off,\n    removeAllListeners:function() {\n        cordova_events.removeAllListeners.apply(cordova_events, arguments);\n    },\n    emit:      emit,\n    trigger:   emit,\n    raw: {}\n};\n\nexports.findProjectRoot = function(opt_startDir) {\n    return cordova_util.isCordova(opt_startDir);\n};\n\n// Each of these APIs takes a final parameter that is a callback function.\n// The callback is passed the error object upon failure, or undefined upon success.\n// To use a promise instead, call the APIs via cordova.raw.FOO(), which returns\n// a promise instead of using a final-parameter-callback.\nvar addModuleProperty = cordova_util.addModuleProperty;\naddModuleProperty(module, 'prepare', './prepare', true);\naddModuleProperty(module, 'build', './build', true);\naddModuleProperty(module, 'help', './help');\naddModuleProperty(module, 'config', './config');\naddModuleProperty(module, 'create', './create', true);\naddModuleProperty(module, 'emulate', './emulate', true);\naddModuleProperty(module, 'plugin', './plugin', true);\naddModuleProperty(module, 'plugins', './plugin', true);\naddModuleProperty(module, 'serve', './serve');\naddModuleProperty(module, 'platform', './platform', true);\naddModuleProperty(module, 'platforms', './platform', true);\naddModuleProperty(module, 'compile', './compile', true);\naddModuleProperty(module, 'run', './run', true);\naddModuleProperty(module, 'info', './info', true);\naddModuleProperty(module, 'targets', './targets', true);\naddModuleProperty(module, 'requirements', './requirements', true);\naddModuleProperty(module, 'projectMetadata', './project_metadata', true);\naddModuleProperty(module, 'clean', './clean', true);\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/cordova-common.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar addProperty = require('./src/util/addProperty');\n\nmodule.exports = { };\n\naddProperty(module, 'events', './src/events');\naddProperty(module, 'superspawn', './src/superspawn');\n\naddProperty(module, 'ActionStack', './src/ActionStack');\naddProperty(module, 'CordovaError', './src/CordovaError/CordovaError');\naddProperty(module, 'CordovaLogger', './src/CordovaLogger');\naddProperty(module, 'CordovaCheck', './src/CordovaCheck');\naddProperty(module, 'CordovaExternalToolErrorContext', './src/CordovaError/CordovaExternalToolErrorContext');\naddProperty(module, 'PlatformJson', './src/PlatformJson');\naddProperty(module, 'ConfigParser', './src/ConfigParser/ConfigParser');\naddProperty(module, 'FileUpdater', './src/FileUpdater');\n\naddProperty(module, 'PluginInfo', './src/PluginInfo/PluginInfo');\naddProperty(module, 'PluginInfoProvider', './src/PluginInfo/PluginInfoProvider');\n\naddProperty(module, 'PluginManager', './src/PluginManager');\n\naddProperty(module, 'ConfigChanges', './src/ConfigChanges/ConfigChanges');\naddProperty(module, 'ConfigKeeper', './src/ConfigChanges/ConfigKeeper');\naddProperty(module, 'ConfigFile', './src/ConfigChanges/ConfigFile');\naddProperty(module, 'mungeUtil', './src/ConfigChanges/munge-util');\n\naddProperty(module, 'xmlHelpers', './src/util/xml-helpers');\n\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/util/addProperty.js":"/*\n       Licensed to the Apache Software Foundation (ASF) under one\n       or more contributor license agreements.  See the NOTICE file\n       distributed with this work for additional information\n       regarding copyright ownership.  The ASF licenses this file\n       to you under the Apache License, Version 2.0 (the\n       \"License\"); you may not use this file except in compliance\n       with the License.  You may obtain a copy of the License at\n\n         http://www.apache.org/licenses/LICENSE-2.0\n\n       Unless required by applicable law or agreed to in writing,\n       software distributed under the License is distributed on an\n       \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n       KIND, either express or implied.  See the License for the\n       specific language governing permissions and limitations\n       under the License.\n*/\n\nmodule.exports = function addProperty(module, property, modulePath, obj) {\n    \n    obj = obj || module.exports;\n    // Add properties as getter to delay load the modules on first invocation\n    Object.defineProperty(obj, property, {\n        configurable: true,\n        get: function () {\n            var delayLoadedModule = module.require(modulePath);\n            obj[property] = delayLoadedModule;\n            return delayLoadedModule;\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/events.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar INSTANCE = new EventEmitter();\nvar EVENTS_RECEIVER;\n\nmodule.exports = INSTANCE;\n\n/**\n * Sets up current instance to forward emitted events to another EventEmitter\n *   instance.\n *\n * @param   {EventEmitter}  [eventEmitter]  The emitter instance to forward\n *   events to. Falsy value, when passed, disables forwarding.\n */\nmodule.exports.forwardEventsTo = function (eventEmitter) {\n\n    // If no argument is specified disable events forwarding\n    if (!eventEmitter) {\n        EVENTS_RECEIVER = undefined;\n        return;\n    }\n\n    if (!(eventEmitter instanceof EventEmitter))\n        throw new Error('weexpack events can be redirected to another EventEmitter instance only');\n\n    // CB-10940 Skipping forwarding to self to avoid infinite recursion.\n    // This is the case when the modules are npm-linked.\n    if (this !== eventEmitter) {\n        EVENTS_RECEIVER = eventEmitter;\n    } else {\n        // Reset forwarding if we are subscribing to self\n        EVENTS_RECEIVER = undefined;\n    }\n};\n\nvar emit = INSTANCE.emit;\n\n/**\n * This method replaces original 'emit' method to allow events forwarding.\n *\n * @return  {eventEmitter}  Current instance to allow calls chaining, as\n *   original 'emit' does\n */\nmodule.exports.emit = function () {\n\n    var args = Array.prototype.slice.call(arguments);\n\n    if (EVENTS_RECEIVER) {\n        EVENTS_RECEIVER.emit.apply(EVENTS_RECEIVER, args);\n    }\n\n    return emit.apply(this, args);\n};\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/cordova/util.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint sub:true */\nvar fs            = require('fs'),\n    path          = require('path'),\n    events        = require('weexpack-common').events,\n    CordovaError  = require('weexpack-common').CordovaError,\n    shell         = require('shelljs'),\n    url           = require('url'),\n    nopt          = require('nopt'),\n    Q             = require('q'),\n    semver        = require('semver');\n\n// Global configuration paths\nvar global_config_path = process.env['CORDOVA_HOME'];\nif (!global_config_path) {\n    var HOME = process.env[(process.platform.slice(0, 3) == 'win') ? 'USERPROFILE' : 'HOME'];\n    global_config_path = path.join(HOME, '.cordova');\n}\n\nvar origCwd = null;\n\nvar lib_path = path.join(global_config_path, 'lib');\n\n\nexports.binname = 'weexpack';\nexports.globalConfig = global_config_path;\n\n// defer defining libDirectory on exports so we don't create it if\n// someone simply requires this module\nObject.defineProperty(exports,'libDirectory', {\n        configurable: true,\n        get: function () {\n            shell.mkdir('-p', lib_path);\n            exports.libDirectory = lib_path;\n        return lib_path;\n    }\n});\n\naddModuleProperty(module, 'plugin_parser', './plugin_parser');\n\nexports.isCordova = isCordova;\nexports.cdProjectRoot = cdProjectRoot;\nexports.deleteSvnFolders = deleteSvnFolders;\nexports.listPlatforms = listPlatforms;\nexports.findPlugins = findPlugins;\nexports.appDir = appDir;\nexports.projectWww = projectWww;\nexports.projectConfig = projectConfig;\nexports.preProcessOptions = preProcessOptions;\nexports.addModuleProperty = addModuleProperty;\nexports.getOrigWorkingDirectory = getOrigWorkingDirectory;\nexports._resetOrigCwd = _resetOrigCwd;\nexports.fixRelativePath = fixRelativePath;\nexports.convertToRealPathSafe = convertToRealPathSafe;\nexports.isDirectory = isDirectory;\nexports.isUrl = isUrl;\nexports.getLatestMatchingNpmVersion = getLatestMatchingNpmVersion;\nexports.getAvailableNpmVersions = getAvailableNpmVersions;\nexports.getInstalledPlatformsWithVersions = getInstalledPlatformsWithVersions;\nexports.existsSync = existsSync;\nexports.isWeexPluginRoot = isWeexPluginRoot;\nexports.isIOSProject = isIOSProject;\nexports.isAndroidProject = isAndroidProject;\n\nfunction isUrl(value) {\n    var u = value && url.parse(value);\n    return !!(u && u.protocol && u.protocol.length > 2); // Account for windows c:/ paths\n}\n\nfunction isWeexPluginRoot(dir){\n\n    if(exports.existsSync(dir)&&/Weexplugin$/.test(dir)){\n        return true\n    }\n}\n\nfunction isIOSProject(dir){\n    if (exports.existsSync(path.join(dir, 'Weexplugin.xcodeproj'))) {\n        return true\n    }\n}\n\nfunction isAndroidProject(dir){\n    if (exports.existsSync(path.join(dir, 'build.gradle'))) {\n        return true\n    }\n}\n\nfunction isRootDir(dir) {\n  /*\n    if (exports.existsSync(path.join(dir, 'web'))) {\n        if (exports.existsSync(path.join(dir, 'config.xml'))) {\n            // For sure is.\n            if (exports.existsSync(path.join(dir, 'platforms'))) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        // Might be (or may be under platforms/).\n        if (exports.existsSync(path.join(dir, 'www', 'config.xml'))) {\n            return 1;\n        }\n    }\n    */\n  //支持插件容器安装插件\n    if(isWeexPluginRoot(dir)){\n        return 1\n    }\n\n\n\n  if (exports.existsSync(path.join(dir, 'platforms'))) {\n    if (exports.existsSync(path.join(dir, 'web'))) {\n      // For sure is.\n      if (exports.existsSync(path.join(dir, 'config.xml'))) {\n        return 2;\n      } else {\n        return 1;\n      }\n    }\n  }\n    return 0;\n}\n\nfunction existsSync(fileSpec) {\n    // Since fs.existsSync() is deprecated\n    try {\n        fs.statSync(fileSpec);\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n\n\n// Runs up the directory chain looking for a .cordova directory.\n// IF it is found we are in a Cordova project.\n// Omit argument to use CWD.\nfunction isCordova(dir) {\n    if (!dir) {\n        // Prefer PWD over cwd so that symlinked dirs within your PWD work correctly (CB-5687).\n        var pwd = process.env.PWD;\n        var cwd = process.cwd();\n        if (pwd && pwd != cwd && pwd != 'undefined') {\n            return this.isCordova(pwd) || this.isCordova(cwd);\n        }\n        return this.isCordova(cwd);\n    }\n    var bestReturnValueSoFar = false;\n    for (var i = 0; i < 1000; ++i) {\n        var result = isRootDir(dir);\n        if (result === 2) {\n            return dir;\n        }\n        if (result === 1) {\n            bestReturnValueSoFar = dir;\n        }\n        var parentDir = path.normalize(path.join(dir, '..'));\n        // Detect fs root.\n        if (parentDir == dir) {\n            return bestReturnValueSoFar;\n        }\n        dir = parentDir;\n    }\n    console.error('Hit an unhandled case in util.isCordova');\n    return false;\n}\n\n// Cd to project root dir and return its path. Throw CordovaError if not in a Corodva project.\nfunction cdProjectRoot(dir) {\n    var projectRoot = this.isCordova(dir);\n    if (!projectRoot) {\n        throw new CordovaError('Current working directory is not a weexpack project.');\n    }\n    if (!origCwd) {\n        origCwd = process.env.PWD || process.cwd();\n    }\n    process.env.PWD = projectRoot;\n    process.chdir(projectRoot);\n    return projectRoot;\n}\n\nfunction getOrigWorkingDirectory() {\n    return origCwd || process.env.PWD || process.cwd();\n}\n\nfunction _resetOrigCwd() {\n    origCwd = null;\n}\n\n// Fixes up relative paths that are no longer valid due to chdir() within cdProjectRoot().\nfunction fixRelativePath(value, /* optional */ cwd) {\n    // Don't touch absolute paths.\n    if (value[1] == ':' || value[0] == path.sep) {\n        return value;\n    }\n    var newDir = cwd || process.env.PWD || process.cwd();\n    var origDir = getOrigWorkingDirectory();\n    var pathDiff = path.relative(newDir, origDir);\n    var ret = path.normalize(path.join(pathDiff, value));\n    return ret;\n}\n\n// Resolve any symlinks in order to avoid relative path issues. See https://issues.apache.org/jira/browse/CB-8757\nfunction convertToRealPathSafe(path) {\n    if (path && exports.existsSync(path)) {\n        return fs.realpathSync(path);\n    }\n\n    return path;\n}\n\n// Recursively deletes .svn folders from a target path\nfunction deleteSvnFolders(dir) {\n    var contents = fs.readdirSync(dir);\n    contents.forEach(function(entry) {\n        var fullpath = path.join(dir, entry);\n        if (fs.statSync(fullpath).isDirectory()) {\n            if (entry == '.svn') {\n                shell.rm('-rf', fullpath);\n            } else module.exports.deleteSvnFolders(fullpath);\n        }\n    });\n}\n\nfunction listPlatforms(project_dir) {\n    var core_platforms = require('../platforms/platforms');\n    var platforms_dir = path.join(project_dir, 'platforms');\n    if ( !exports.existsSync(platforms_dir)) {\n        return [];\n    }\n    var subdirs = fs.readdirSync(platforms_dir);\n    return subdirs.filter(function(p) {\n        return Object.keys(core_platforms).indexOf(p) > -1;\n    });\n}\n\nfunction getInstalledPlatformsWithVersions(project_dir) {\n    var result = {};\n    var platforms_on_fs = listPlatforms(project_dir);\n\n    return Q.all(platforms_on_fs.map(function(p) {\n        var superspawn    = require('weexpack-common').superspawn;\n        return superspawn.maybeSpawn(path.join(project_dir, 'platforms', p, 'cordova', 'version'), [], { chmod: true })\n        .then(function(v) {\n            result[p] = v || null;\n        }, function(v) {\n            result[p] = 'broken';\n        });\n    })).then(function() {\n        return result;\n    });\n}\n\n// list the directories in the path, ignoring any files\nfunction findPlugins(pluginPath) {\n    var plugins = [],\n        stats;\n\n    if (exports.existsSync(pluginPath)) {\n        plugins = fs.readdirSync(pluginPath).filter(function (fileName) {\n            stats = fs.statSync(path.join(pluginPath, fileName));\n            return fileName != '.svn' && fileName != 'CVS' && stats.isDirectory();\n        });\n    }\n\n    return plugins;\n}\n\nfunction appDir(projectDir) {\n    return projectDir;\n}\n\nfunction projectWww(projectDir) {\n    return path.join(projectDir, 'www');\n}\n\nfunction projectConfig(projectDir) {\n    var rootPath = path.join(projectDir, 'config.xml');\n    var wwwPath = path.join(projectDir, 'www', 'config.xml');\n    if (exports.existsSync(rootPath)) {\n        return rootPath;\n    } else if (exports.existsSync(wwwPath)) {\n        return wwwPath;\n    }\n    return false;\n}\n\nfunction preProcessOptions (inputOptions) {\n    /**\n     * Current Desired Arguments\n     * options: {verbose: boolean, platforms: [String], options: [String]}\n     * Accepted Arguments\n     * platformList: [String] -- assume just a list of platforms\n     * platform: String -- assume this is a platform\n     */\n    var result = inputOptions || {};\n    if (Array.isArray(inputOptions)) {\n        result = { platforms: inputOptions };\n    } else if (typeof inputOptions === 'string') {\n        result = { platforms: [inputOptions] };\n    }\n    result.verbose = result.verbose || false;\n    result.platforms = result.platforms || [];\n    result.options = ensurePlatformOptionsCompatible(result.options);\n\n    var projectRoot = this.isCordova();\n\n    if (!projectRoot) {\n        throw new CordovaError('Current working directory is not a weexpack project.');\n    }\n    var projectPlatforms = this.listPlatforms(projectRoot);\n    if (projectPlatforms.length === 0) {\n        throw new CordovaError('No platforms added to this project. Please use `'+exports.binname+' platform add <platform>`.');\n    }\n    if (result.platforms.length === 0) {\n        result.platforms = projectPlatforms;\n    }\n\n    if (!result.options.buildConfig && exports.existsSync(path.join(projectRoot, 'build.json'))) {\n        result.options.buildConfig = path.join(projectRoot, 'build.json');\n    }\n\n    return result;\n}\n\n/**\n * Converts options, which is passed to platformApi from old format (array of\n *   plain strings) to new - nopt-parsed object + array of platform-specific\n *   options. If options are already in new the format - returns them unchanged.\n *\n * @param   {Object|String[]}  platformOptions  A platform options (array of\n *   strings or object) which is passed down to platform scripts/platformApi\n *   polyfill.\n *\n * @return  {Object}                            Options, converted to new format\n */\nfunction ensurePlatformOptionsCompatible (platformOptions) {\n    var opts = platformOptions || {};\n\n    if (!Array.isArray(opts))\n        return opts;\n\n    events.emit('warn', 'The format of cordova.raw.* methods \"options\" argument was changed in 5.4.0. ' +\n        '\"options.options\" property now should be an object instead of an array of plain strings. Though the old format ' +\n        'is still supported, consider updating your cordova.raw.* method calls to use new argument format.');\n\n    var knownArgs = [\n        'debug',\n        'release',\n        'device',\n        'emulator',\n        'nobuild',\n        'list',\n        'buildConfig',\n        'target',\n        'archs'\n    ];\n\n    opts = nopt({}, {}, opts, 0);\n    opts.argv = Object.keys(opts)\n    .filter(function (arg) {\n        return arg !== 'argv' && knownArgs.indexOf(arg) === -1;\n    }).map(function (arg) {\n        return opts[arg] === true ?\n            '--' + arg :\n            '--' + arg + '=' + opts[arg].toString();\n    });\n\n    return opts;\n}\n\nfunction isDirectory(dir) {\n    try {\n        return fs.lstatSync(dir).isDirectory();\n    } catch (e) {\n        return false;\n    }\n}\n\n// opt_wrap is a boolean: True means that a callback-based wrapper for the promise-based function\n// should be created.\nfunction addModuleProperty(module, symbol, modulePath, opt_wrap, opt_obj) {\n    var val = null;\n    if (opt_wrap) {\n        module.exports[symbol] = function() {\n            val = val || module.require(modulePath);\n            if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n                // If args exist and the last one is a function, it's the callback.\n                var args = Array.prototype.slice.call(arguments);\n                var cb = args.pop();\n                val.apply(module.exports, args).done(function(result) { cb(undefined, result); }, cb);\n            } else {\n                val.apply(module.exports, arguments).done(null, function(err) { throw err; });\n            }\n        };\n    } else {\n        Object.defineProperty(opt_obj || module.exports, symbol, {\n            get : function() { val = val || module.require(modulePath); return val; },\n            set : function(v) { val = v; }\n        });\n    }\n\n    // Add the module.raw.foo as well.\n    if(module.exports.raw) {\n        Object.defineProperty(module.exports.raw, symbol, {\n            get : function() { val = val || module.require(modulePath); return val; },\n            set : function(v) { val = v; }\n        });\n    }\n}\n\n/**\n * Returns the latest version of the specified module on npm that matches the specified version or range.\n * @param {string} module_name - npm module name.\n * @param {string} version - semver version or range (loose allowed).\n * @returns {Promise} Promise for version (a valid semver version if one is found, otherwise whatever was provided).\n */\nfunction getLatestMatchingNpmVersion(module_name, version) {\n    if (!version) {\n        // If no version specified, get the latest\n        return getLatestNpmVersion(module_name);\n    }\n\n    var validVersion = semver.valid(version, /* loose */ true);\n    if (validVersion) {\n        // This method is really intended to work with ranges, so if a version rather than a range is specified, we just\n        // assume it is available and return it, bypassing the need for the npm call.\n        return Q(validVersion);\n    }\n\n    var validRange = semver.validRange(version, /* loose */ true);\n    if (!validRange) {\n        // Just return what we were passed\n        return Q(version);\n    }\n\n    return getAvailableNpmVersions(module_name).then(function (versions) {\n        return semver.maxSatisfying(versions, validRange) || version;\n    });\n}\n\n/**\n * Returns a promise for an array of versions available for the specified npm module.\n * @param {string} module_name - npm module name.\n * @returns {Promise} Promise for an array of versions.\n */\nfunction getAvailableNpmVersions(module_name) {\n    var npm = require('npm');\n    return Q.nfcall(npm.load).then(function () {\n        return Q.ninvoke(npm.commands, 'view', [module_name, 'versions'], /* silent = */ true).then(function (result) {\n            // result is an object in the form:\n            //     {'<version>': {versions: ['1.2.3', '1.2.4', ...]}}\n            // (where <version> is the latest version)\n            return result[Object.keys(result)[0]].versions;\n        });\n    });\n}\n\n/**\n * Returns a promise for the latest version available for the specified npm module.\n * @param {string} module_name - npm module name.\n * @returns {Promise} Promise for an array of versions.\n */\nfunction getLatestNpmVersion(module_name) {\n    var npm = require('npm');\n    return Q.nfcall(npm.load).then(function () {\n        return Q.ninvoke(npm.commands, 'view', [module_name, 'version'], /* silent = */ true).then(function (result) {\n            // result is an object in the form:\n            //     {'<version>': {version: '<version>'}}\n            // (where <version> is the latest version)\n            return Object.keys(result)[0];\n        });\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/CordovaError/CordovaError.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint proto:true */\n\nvar EOL = require('os').EOL;\n\n/**\n * A derived exception class. See usage example in cli.js\n * Based on:\n * stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/8460753#8460753\n * @param {String} message Error message\n * @param {Number} [code=0] Error code\n * @param {CordovaExternalToolErrorContext} [context] External tool error context object\n * @constructor\n */\nfunction CordovaError(message, code, context) {\n    Error.captureStackTrace(this, this.constructor);\n   // this.name = this.constructor.name;\n    this.name = 'weexpack error';\n    // WEEX_HOOK_START\n    message = message.replace(/Cordova/ig,\"weexpack\")\n    // WEEX_HOOK_END\n    this.message = message;\n    this.code = code || CordovaError.UNKNOWN_ERROR;\n    this.context = context;\n}\n\nCordovaError.prototype.__proto__ = Error.prototype;\n\n// TODO: Extend error codes according the projects specifics\nCordovaError.UNKNOWN_ERROR = 0;\nCordovaError.EXTERNAL_TOOL_ERROR = 1;\n\n/**\n * Translates instance's error code number into error code name, e.g. 0 -> UNKNOWN_ERROR\n * @returns {string} Error code string name\n */\nCordovaError.prototype.getErrorCodeName = function() {\n    for(var key in CordovaError) {\n        if(CordovaError.hasOwnProperty(key)) {\n            if(CordovaError[key] === this.code) {\n                return key;\n            }\n        }\n    }\n};\n\n/**\n * Converts CordovaError instance to string representation\n * @param   {Boolean}  [isVerbose]  Set up verbose mode. Used to provide more\n *   details including information about error code name and context\n * @return  {String}              Stringified error representation\n */\nCordovaError.prototype.toString = function(isVerbose) {\n    var message = '', codePrefix = '';\n\n    if(this.code !== CordovaError.UNKNOWN_ERROR) {\n        codePrefix = 'code: ' + this.code + (isVerbose ? (' (' + this.getErrorCodeName() + ')') : '') + ' ';\n    }\n\n    if(this.code === CordovaError.EXTERNAL_TOOL_ERROR) {\n        if(typeof this.context !== 'undefined') {\n            if(isVerbose) {\n                message = codePrefix + EOL + this.context.toString(isVerbose) + '\\n failed with an error: ' +\n                    this.message + EOL + 'Stack trace: ' + this.stack;\n            } else {\n                message = codePrefix + '\\'' + this.context.toString(isVerbose) + '\\' ' + this.message;\n            }\n        } else {\n            message = 'External tool failed with an error: ' + this.message;\n        }\n    } else {\n        message = isVerbose ? codePrefix + this.stack : codePrefix + this.message;\n    }\n\n    return message;\n};\n\nmodule.exports = CordovaError;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/telemetry.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint node:true, bitwise:true, undef:true, trailing:true, quotmark:true,\n          indent:4, unused:vars, latedef:nofunc,\n          laxcomma:true\n*/\n\n\n\n// For further details on telemetry, see:\n// https://github.com/cordova/cordova-discuss/pull/43\n\nvar Q = require('q');\n\n// Google Analytics tracking code\nvar GA_TRACKING_CODE = 'UA-64283057-7';\n\nvar pkg = require('../package.json');\nvar Insight = require('insight');\nvar insight = new Insight({\n    trackingCode: GA_TRACKING_CODE,\n    pkg: pkg\n});\n\n/**\n * Returns true if the user opted in, and false otherwise\n */\nfunction showPrompt() {\n\n    var deferred = Q.defer();\n    \n    var msg = \"May weexpack anonymously report usage statistics to improve the tool over time?\";\n    insight.askPermission(msg, function (unused, optIn) {\n        var EOL = require('os').EOL;\n        if (optIn) {\n            console.log(EOL + \"Thanks for opting into telemetry to help us improve weexpack.\");\n            track('telemetry', 'on', 'via-cli-prompt-choice', 'successful');\n        } else {\n            console.log(EOL + \"You have been opted out of telemetry. To change this, run: weexpack telemetry on.\");\n            // Always track telemetry opt-outs! (whether opted-in or opted-out)\n            track('telemetry', 'off', 'via-cli-prompt-choice', 'successful');\n        }\n        \n        deferred.resolve(optIn); \n    });\n    \n    return deferred.promise;\n}\n\nfunction track() {\n    // Remove empty, null or undefined strings from arguments\n    for (var property in arguments) {\n        var val = arguments[property]; \n        if (!val || val.length === 0) {\n            delete arguments.property;\n        }\n    }\n    insight.track.apply(insight, arguments);\n}\n\nfunction turnOn() {\n    insight.optOut = false;\n}\n\nfunction turnOff() {\n    insight.optOut = true;\n}\n\n/**\n * Clears telemetry setting\n * Has the same effect as if user never answered the telemetry prompt\n * Useful for testing purposes\n */\nfunction clear() {\n    insight.optOut = undefined;\n}\n\nfunction isOptedIn() {\n    return !insight.optOut;\n}\n\n/**\n * Has the user already answered the telemetry prompt? (thereby opting in or out?)\n */\nfunction hasUserOptedInOrOut() {\n    return !(insight.optOut === undefined);\n}\n\n/**\n * Is the environment variable 'CI' specified ?\n */\nfunction isCI(env) {\n    return !!env.CI;\n}\n\n/**\n * Has the user ran a command of the form: `cordova run --no-telemetry` ?\n */\nfunction isNoTelemetryFlag(args) {\n    return args.indexOf('--no-telemetry') > -1;\n}\n\nmodule.exports = {\n    track: track,\n    turnOn: turnOn,\n    turnOff: turnOff,\n    clear: clear,\n    isOptedIn: isOptedIn,\n    hasUserOptedInOrOut: hasUserOptedInOrOut,\n    isCI: isCI,\n    showPrompt: showPrompt,\n    isNoTelemetryFlag: isNoTelemetryFlag\n};","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/utils/npm.js":"/**\n * Created by godsong on 16/12/7.\n */\nconst child_process = require('child_process');\nconst ProgressBar = require('./ProgressBar');\nconst Chalk = require('chalk');\nconst npm = require(\"npm\");\nconst path = require(\"path\");\nconst fs = require(\"fs\")\n\nconst tar    = require('tar'),\n    zlib   = require('zlib');\n\nexports.publish = function publish(tnpm, verbose, dir) {\n  let pb = new ProgressBar(3000, 'publish', 'uploading...');\n  let cmd = tnpm ? 'tnpm' : 'npm';\n  return new Promise(function (resolve, reject) {\n    let npm = child_process.exec(cmd + ' publish', {cwd: dir || process.cwd()}, function (error, stdout, stderr) {\n      pb.complete(function () {\n        if (error) {\n          console.log();\n          let match=stderr.toString().replace(/npm ERR! /g,'').match(/\\n\\n([\\s\\w\\W]+?)\\n\\n/);\n          if(match&&match[1]){\n            console.error(Chalk.red(match[1]))\n          }\n          else{\n            console.error(Chalk.red(stderr.toString()))\n          }\n          console.log();\n         return  resolve(false);\n        }\n        resolve(true);\n      })\n    });\n  });\n};\n\n\n\nexports.getLastestVersion =  function (name, callback){\n  var trynum = 0\n  npm.load(function() {\n\n    var load = function(npmName){\n        npm.commands.info([npmName, \"version\"], true, function (error, result) {\n          if (error&&trynum==0) {\n            trynum++\n            if(npmName == \"weex-gcanvas\"){\n              var  prefix = \"weex-plugin--\"\n            }\n            else {\n              var  prefix = \"weex-plugin-\"\n            }\n            load(prefix+npmName)\n          }\n          else if(error&&trynum!==0){\n            throw  new Error(error)\n          }\n          else {\n            var version;\n            for (var p in result) {\n              version = p;\n            }\n            callback(version)\n          }\n\n        })\n\n\n    }\n\n\n      load(name);\n\n\n\n  })\n}\n\n\nexports.fetchCache  = function (npmName, version, callback){\n\n  npm.load(function() {\n    npm.commands.cache(['add', (npmName + '@' + version)],  function (error, result) {\n      if(error){\n        throw  new Error(error)\n      }\n      else {\n\n        var packageDir = path.resolve(npm.cache, result.name, result.version, 'package');\n        var packageTGZ = path.resolve(npm.cache, result.name, result.version, 'package.tgz');\n        callback(packageTGZ, packageDir)\n      }\n\n\n    })\n  })\n\n}\n\nexports.unpackTgz = function(package_tgz, unpackTarget, callback) {\n\n    var extractOpts = { type: 'Directory', path: unpackTarget, strip: 1 };\n\n    fs.createReadStream(package_tgz)\n        .on('error', function (err) {\n          console.warn('Unable to open tarball ' + package_tgz + ': ' + err);\n        })\n        .pipe(zlib.createUnzip())\n        .on('error', function (err) {\n          console.warn('Error during unzip for ' + package_tgz + ': ' + err);\n        })\n        .pipe(tar.Extract(extractOpts))\n        .on('error', function(err) {\n          console.warn('Error during untar for ' + package_tgz + ': ' + err);\n\n        })\n        .on('end', function(result){\n          callback(result)\n        });\n\n}\n\n\n\n\n\n\n\nexports.prefix = 'weex-plugin--';\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/utils/ProgressBar.js":"/**\n * Created by godsong on 16/12/9.\n */\nconst Gauge = require(\"gauge\");\nclass ProgressBar {\n  constructor(duration, title, content, stream=process.stdout) {\n    let completed = 0,interval=50,factor=0.2+Math.random()*0.7;\n    this._complete = false;\n    this.title = title;\n    this.content = content;\n    let gauge = new Gauge(stream, {\n      updateInterval: 20,\n    });\n    this.progress = setInterval(()=> {\n      if (this._complete) {\n        completed = duration;\n        if (factor <= 1) {\n          factor += 0.1;\n        }\n        else {\n          clearInterval(this.progress);\n          gauge.hide();\n          this.isOver=true;\n          this.callback&&this.callback();\n          return;\n        }\n      }\n      if (completed <= duration) {\n        gauge.show(this.title, completed / duration * factor);\n        if (Math.random() * 10 < 6&&completed < duration) {\n          completed += interval;\n        }\n      }\n\n      gauge.pulse(this.content)\n    }, interval);\n  }\n  complete(callback){\n    this._complete=true;\n    if(this.isOver){\n      callback();\n    }\n    else{\n      this.callback=callback;\n    }\n  }\n}\nmodule.exports = ProgressBar;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/CordovaLogger.js":"/*\r\n Licensed to the Apache Software Foundation (ASF) under one\r\n or more contributor license agreements.  See the NOTICE file\r\n distributed with this work for additional information\r\n regarding copyright ownership.  The ASF licenses this file\r\n to you under the Apache License, Version 2.0 (the\r\n \"License\"); you may not use this file except in compliance\r\n with the License.  You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing,\r\n software distributed under the License is distributed on an\r\n \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n KIND, either express or implied.  See the License for the\r\n specific language governing permissions and limitations\r\n under the License.\r\n */\r\n\r\nvar ansi = require('ansi');\r\nvar EventEmitter = require('events').EventEmitter;\r\nvar CordovaError = require('./CordovaError/CordovaError');\r\nvar EOL = require('os').EOL;\r\n\r\nvar INSTANCE;\r\n\r\n/**\r\n * @class CordovaLogger\r\n *\r\n * Implements logging facility that anybody could use. Should not be\r\n *   instantiated directly, `CordovaLogger.get()` method should be used instead\r\n *   to acquire logger instance\r\n */\r\nfunction CordovaLogger () {\r\n    this.levels = {};\r\n    this.colors = {};\r\n    this.stdout = process.stdout;\r\n    this.stderr = process.stderr;\r\n\r\n    this.stdoutCursor = ansi(this.stdout);\r\n    this.stderrCursor = ansi(this.stderr);\r\n\r\n    this.addLevel('verbose', 1000, 'grey');\r\n    this.addLevel('normal' , 2000);\r\n    this.addLevel('warn'   , 2000, 'yellow');\r\n    this.addLevel('info'   , 3000, 'blue');\r\n    this.addLevel('error'  , 5000, 'red');\r\n    this.addLevel('results' , 10000);\r\n\r\n    this.setLevel('normal');\r\n}\r\n\r\n/**\r\n * Static method to create new or acquire existing instance.\r\n *\r\n * @return  {CordovaLogger}  Logger instance\r\n */\r\nCordovaLogger.get = function () {\r\n    return INSTANCE || (INSTANCE = new CordovaLogger());\r\n};\r\n\r\nCordovaLogger.VERBOSE = 'verbose';\r\nCordovaLogger.NORMAL = 'normal';\r\nCordovaLogger.WARN = 'warn';\r\nCordovaLogger.INFO = 'info';\r\nCordovaLogger.ERROR = 'error';\r\nCordovaLogger.RESULTS = 'results';\r\n\r\n/**\r\n * Emits log message to process' stdout/stderr depending on message's severity\r\n *   and current log level. If severity is less than current logger's level,\r\n *   then the message is ignored.\r\n *\r\n * @param   {String}  logLevel  The message's log level. The logger should have\r\n *   corresponding level added (via logger.addLevel), otherwise\r\n *   `CordovaLogger.NORMAL` level will be used.\r\n * @param   {String}  message   The message, that should be logged to process'\r\n *   stdio\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.log = function (logLevel, message) {\r\n    // if there is no such logLevel defined, or provided level has\r\n    // less severity than active level, then just ignore this call and return\r\n    if (!this.levels[logLevel] || this.levels[logLevel] < this.levels[this.logLevel])\r\n        // return instance to allow to chain calls\r\n        return this;\r\n\r\n    var isVerbose = this.logLevel === 'verbose';\r\n    var cursor = this.stdoutCursor;\r\n\r\n    if (message instanceof Error || logLevel === CordovaLogger.ERROR) {\r\n        message = formatError(message, isVerbose);\r\n        cursor = this.stderrCursor;\r\n    }\r\n\r\n    var color = this.colors[logLevel];\r\n    if (color) {\r\n        cursor.bold().fg[color]();\r\n    }\r\n\r\n    cursor.write(message).reset().write(EOL);\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Adds a new level to logger instance. This method also creates a shortcut\r\n *   method to log events with the level provided (i.e. after adding new level\r\n *   'debug', the method `debug(message)`, equal to logger.log('debug', message),\r\n *   will be added to logger instance)\r\n *\r\n * @param  {String}  level     A log level name. The levels with the following\r\n *   names added by default to every instance: 'verbose', 'normal', 'warn',\r\n *   'info', 'error', 'results'\r\n * @param  {Number}  severity  A number that represents level's severity.\r\n * @param  {String}  color     A valid color name, that will be used to log\r\n *   messages with this level. Any CSS color code or RGB value is allowed\r\n *   (according to ansi documentation:\r\n *   https://github.com/TooTallNate/ansi.js#features)\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.addLevel = function (level, severity, color) {\r\n\r\n    this.levels[level] = severity;\r\n\r\n    if (color) {\r\n        this.colors[level] = color;\r\n    }\r\n\r\n    // Define own method with corresponding name\r\n    if (!this[level]) {\r\n        this[level] = this.log.bind(this, level);\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the current logger level to provided value. If logger doesn't have level\r\n *   with this name, `CordovaLogger.NORMAL` will be used.\r\n *\r\n * @param  {String}  logLevel  Level name. The level with this name should be\r\n *   added to logger before.\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.setLevel = function (logLevel) {\r\n    this.logLevel = this.levels[logLevel] ? logLevel : CordovaLogger.NORMAL;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Adjusts the current logger level according to the passed options.\r\n *\r\n * @param   {Object|Array}  opts  An object or args array with options\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.adjustLevel = function (opts) {\r\n    if (opts.verbose || (Array.isArray(opts) && opts.indexOf('--verbose') !== -1)) {\r\n        this.setLevel('verbose');\r\n    } else if (opts.silent || (Array.isArray(opts) && opts.indexOf('--silent') !== -1)) {\r\n        this.setLevel('error');\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Attaches logger to EventEmitter instance provided.\r\n *\r\n * @param   {EventEmitter}  eventEmitter  An EventEmitter instance to attach\r\n *   logger to.\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.subscribe = function (eventEmitter) {\r\n\r\n    if (!(eventEmitter instanceof EventEmitter))\r\n        throw new Error('Subscribe method only accepts an EventEmitter instance as argument');\r\n\r\n    eventEmitter.on('verbose', this.verbose)\r\n        .on('log', this.normal)\r\n        .on('info', this.info)\r\n        .on('warn', this.warn)\r\n        .on('warning', this.warn)\r\n        // Set up event handlers for logging and results emitted as events.\r\n        .on('results', this.results);\r\n\r\n    return this;\r\n};\r\n\r\nfunction formatError(error, isVerbose) {\r\n    var message = '';\r\n\r\n    if (error instanceof CordovaError) {\r\n        message = error.toString(isVerbose);\r\n    } else if (error instanceof Error) {\r\n        if (isVerbose) {\r\n            message = error.stack;\r\n        } else {\r\n            message = error.message;\r\n        }\r\n    } else {\r\n        // Plain text error message\r\n        message = error;\r\n    }\r\n\r\n    if (typeof message === 'string' && message.toUpperCase().indexOf('ERROR:') !== 0) {\r\n        // Needed for backward compatibility with external tools\r\n        message = 'Error: ' + message;\r\n    }\r\n\r\n    return message;\r\n}\r\n\r\nmodule.exports = CordovaLogger;\r\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/publish/publish.js":"/**\n * Created by godsong on 16/11/29.\n */\nconst PluginInfo = require('weexpack-common').PluginInfo;\nconst Chalk = require('chalk');\nconst Npm = require('../utils/npm');\nconst Fs = require('fs');\nconst Market = require('./market');\nconst Cache = require('../utils/cache');\nconst Path = require('path');\nmodule.exports = function (ali) {\n\n  var dir = process.cwd();\n  var xmlFilePath = Path.join(dir, 'plugin.xml');\n  Cache.init();\n  if (!Fs.existsSync(xmlFilePath)) {\n    //新版本\n    var pkg = require(Path.join(dir,\"./package.json\"))\n    pkg.weexpack = \"0.4.0\"\n    if (ali) {\n      pkg.publishConfig = {\n        registry: 'http://registry.npm.alibaba-inc.com'\n      }\n    }\n    _doPublish(pkg, pkg.name, '', pkg.name, ali, [], pkg)\n    return;\n  }\n  \n  let plugin;\n  try {\n    plugin = new PluginInfo('./');\n  } catch (e) {\n    if (e.message.indexOf('Cannot find plugin.xml for plugin') != -1) {\n      console.log();\n      console.log(Chalk.red('  weex plugin project not found !'));\n      console.log();\n      console.log(`  You should run ${Chalk.blue('weexpack plugin create')} first`);\n      console.log();\n      process.exit();\n    }\n    else {\n      console.log();\n      console.log(Chalk.red(e.message));\n      console.log();\n    }\n  }\n\n  if (plugin.version > Cache.get('latestVersion', '0.0.0')) {\n    let deps = plugin.getDependencies()\n    if (deps.length > 0) {\n      Promise.all(deps.map(d=>Market.info(d.id))).then(function (data) {\n\n        deps = data.map((info)=> {\n          return {name: info.name, fullname: info.fullname}\n        });\n        Cache.deps = deps;\n        _publish(plugin, deps, ali)\n      })\n    }\n    else {\n      _publish(plugin, [], ali)\n    }\n\n\n  }\n  else if (Cache.get('nameInfo')) {\n    let nameInfo = Cache.get('nameInfo');\n    Market.publish(plugin.id, nameInfo.namespace || '', nameInfo.fullname, ali, plugin.version).then(function () {\n\n    });\n  }\n};\nfunction _publish(plugin, deps, ali) {\n\n  var package = {};\n  package.version = plugin.version;\n  package.platform = plugin.getPlatformsArray();\n  package.description = plugin.description;\n  package.keywords = plugin.keywords;\n  package.license = plugin.license;\n  package.description = plugin.description;\n  let jsPkgJson;\n  try {\n    jsPkgJson = JSON.parse(Fs.readFileSync('./js/package.json').toString());\n  } catch (e) {\n    jsPkgJson = {}\n  }\n  if (jsPkgJson.main) {\n    package.main = Path.join('./js', jsPkgJson.main);\n  }\n  let dependencies = jsPkgJson.dependencies || {};\n  if (deps.length > 0) {\n    deps = deps.filter((d)=> {\n      dependencies[d.fullname] = '*';\n      return d.fullname !== d.name;\n    });\n\n  }\n  if (Object.keys(dependencies).length > 0) {\n    package.dependencies = dependencies\n  }\n  if (ali) {\n    package.publishConfig = {\n      registry: 'http://registry.npm.alibaba-inc.com'\n    }\n  }\n  let nameInfo = Cache.get('nameInfo');\n  if (!nameInfo) {\n    Market.apply(plugin.id, ali).then(function (result) {\n      Cache.cache.nameInfo = result;\n      package.name = result.fullname;\n      _doPublish(package, plugin.id, result.namespace || '', result.fullname, ali, deps)\n    }, function () {\n\n    });\n  }\n  else {\n    package.name = nameInfo.fullname;\n    _doPublish(package, nameInfo.name, nameInfo.namespace || '', nameInfo.fullname, ali, deps)\n  }\n\n\n}\n\n\nfunction _doPublish(package, name, namespace, fullname, ali, deps,extend) {\n\n  if (deps.length > 0) {\n    package.scripts = {\n      'postinstall': 'node ./weexpack-hook.js'\n    };\n    let source = Fs.readFileSync(Path.join(__dirname, 'weexpack-hook.js')).toString();\n    let code = 'var deps=' + JSON.stringify(deps) + ';\\n';\n    if (name !== fullname) {\n      code += 'var self=' + JSON.stringify({name, fullname}) + ';\\n';\n    }\n    Fs.writeFileSync('./weexpack-hook.js', code + source)\n  }\n  Fs.writeFileSync('./package.json', JSON.stringify(package, null, 4));\n  Npm.publish(ali, true).then(function (success) {\n    if (success) {\n      Market.publish(name, namespace, fullname, ali, package.version, extend);\n      Cache.cache.latestVersion = package.version;\n      Cache.save();\n    }\n\n  }, function () {\n  })\n}\nfunction removePackageJson() {\n  try {\n    Fs.unlink('./package.json', function () {\n    });\n  } catch (e) {\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/PluginInfo/PluginInfo.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint sub:true, laxcomma:true, laxbreak:true */\n\n/*\nA class for holidng the information currently stored in plugin.xml\nIt should also be able to answer questions like whether the plugin\nis compatible with a given engine version.\n\nTODO (kamrik): refactor this to not use sync functions and return promises.\n*/\n\n\nvar path = require('path')\n  , fs = require('fs')\n  , xml_helpers = require('../util/xml-helpers')\n  , CordovaError = require('../CordovaError/CordovaError')\n  ;\n\nfunction PluginInfo(dirname) {\n    var self = this;\n\n    // METHODS\n    // Defined inside the constructor to avoid the \"this\" binding problems.\n\n    // <preference> tag\n    // Example: <preference name=\"API_KEY\" />\n    // Used to require a variable to be specified via --variable when installing the plugin.\n    // returns { key : default | null}\n    self.getPreferences = getPreferences;\n    function getPreferences(platform) {\n        return _getTags(self._et, 'preference', platform, _parsePreference)\n        .reduce(function (preferences, pref) {\n            preferences[pref.preference] = pref.default;\n            return preferences;\n        }, {});\n    }\n\n    function _parsePreference(prefTag) {\n        var name = prefTag.attrib.name.toUpperCase();\n        var def = prefTag.attrib.default || null;\n        return {preference: name, default: def};\n    }\n\n    // <asset>\n    self.getAssets = getAssets;\n    function getAssets(platform) {\n        var assets = _getTags(self._et, 'asset', platform, _parseAsset);\n        return assets;\n    }\n\n    function _parseAsset(tag) {\n        var src = tag.attrib.src;\n        var target = tag.attrib.target;\n\n        if ( !src || !target) {\n            var msg =\n                'Malformed <asset> tag. Both \"src\" and \"target\" attributes'\n                + 'must be specified in\\n'\n                + self.filepath\n                ;\n            throw new Error(msg);\n        }\n\n        var asset = {\n            itemType: 'asset',\n            src: src,\n            target: target\n        };\n        return asset;\n    }\n\n\n    // <dependency>\n    // Example:\n    // <dependency id=\"com.plugin.id\"\n    //     url=\"https://github.com/myuser/someplugin\"\n    //     commit=\"428931ada3891801\"\n    //     subdir=\"some/path/here\" />\n    self.getDependencies = getDependencies;\n    function getDependencies(platform) {\n        var deps = _getTags(\n                self._et,\n                'dependency',\n                platform,\n                _parseDependency\n        );\n        return deps;\n    }\n\n    function _parseDependency(tag) {\n        var dep =\n            { id : tag.attrib.id\n            , url : tag.attrib.url || ''\n            , subdir : tag.attrib.subdir || ''\n            , commit : tag.attrib.commit\n            };\n\n        dep.git_ref = dep.commit;\n\n        if ( !dep.id ) {\n            var msg =\n                '<dependency> tag is missing id attribute in '\n                + self.filepath\n                ;\n            throw new CordovaError(msg);\n        }\n        return dep;\n    }\n\n\n    // <config-file> tag\n    self.getConfigFiles = getConfigFiles;\n    function getConfigFiles(platform) {\n        var configFiles = _getTags(self._et, 'config-file', platform, _parseConfigFile);\n        return configFiles;\n    }\n\n    function _parseConfigFile(tag) {\n        var configFile =\n            { target : tag.attrib['target']\n            , parent : tag.attrib['parent']\n            , after : tag.attrib['after']\n            , xmls : tag.getchildren()\n            // To support demuxing via versions\n            , versions : tag.attrib['versions']\n            , deviceTarget: tag.attrib['device-target']\n            };\n        return configFile;\n    }\n\n    self.getEditConfigs = getEditConfigs;\n    function getEditConfigs(platform) {\n        var editConfigs = _getTags(self._et, 'edit-config', platform, _parseEditConfigs);\n        return editConfigs;\n    }\n\n    function _parseEditConfigs(tag) {\n        var editConfig =\n        { file : tag.attrib['file']\n        , target : tag.attrib['target']\n        , mode : tag.attrib['mode']\n        , xmls : tag.getchildren()\n        };\n        return editConfig;\n    }\n\n    // <info> tags, both global and within a <platform>\n    // TODO (kamrik): Do we ever use <info> under <platform>? Example wanted.\n    self.getInfo = getInfo;\n    function getInfo(platform) {\n        var infos = _getTags(\n                self._et,\n                'info',\n                platform,\n                function(elem) { return elem.text; }\n        );\n        // Filter out any undefined or empty strings.\n        infos = infos.filter(Boolean);\n        return infos;\n    }\n\n    // <source-file>\n    // Examples:\n    // <source-file src=\"src/ios/someLib.a\" framework=\"true\" />\n    // <source-file src=\"src/ios/someLib.a\" compiler-flags=\"-fno-objc-arc\" />\n    self.getSourceFiles = getSourceFiles;\n    function getSourceFiles(platform) {\n        var sourceFiles = _getTagsInPlatform(self._et, 'source-file', platform, _parseSourceFile);\n        return sourceFiles;\n    }\n\n    function _parseSourceFile(tag) {\n        return {\n            itemType: 'source-file',\n            src: tag.attrib.src,\n            framework: isStrTrue(tag.attrib.framework),\n            weak: isStrTrue(tag.attrib.weak),\n            compilerFlags: tag.attrib['compiler-flags'],\n            targetDir: tag.attrib['target-dir']\n        };\n    }\n\n    // <header-file>\n    // Example:\n    // <header-file src=\"CDVFoo.h\" />\n    self.getHeaderFiles = getHeaderFiles;\n    function getHeaderFiles(platform) {\n        var headerFiles = _getTagsInPlatform(self._et, 'header-file', platform, function(tag) {\n            return {\n                itemType: 'header-file',\n                src: tag.attrib.src,\n                targetDir: tag.attrib['target-dir']\n            };\n        });\n        return headerFiles;\n    }\n\n    // <resource-file>\n    // Example:\n    // <resource-file src=\"FooPluginStrings.xml\" target=\"res/values/FooPluginStrings.xml\" device-target=\"win\" arch=\"x86\" versions=\"&gt;=8.1\" />\n    self.getResourceFiles = getResourceFiles;\n    function getResourceFiles(platform) {\n        var resourceFiles = _getTagsInPlatform(self._et, 'resource-file', platform, function(tag) {\n            return {\n                itemType: 'resource-file',\n                src: tag.attrib.src,\n                target: tag.attrib.target,\n                versions: tag.attrib.versions,\n                deviceTarget: tag.attrib['device-target'],\n                arch: tag.attrib.arch\n            };\n        });\n        return resourceFiles;\n    }\n\n    // <lib-file>\n    // Example:\n    // <lib-file src=\"src/BlackBerry10/native/device/libfoo.so\" arch=\"device\" />\n    self.getLibFiles = getLibFiles;\n    function getLibFiles(platform) {\n        var libFiles = _getTagsInPlatform(self._et, 'lib-file', platform, function(tag) {\n            return {\n                itemType: 'lib-file',\n                src: tag.attrib.src,\n                arch: tag.attrib.arch,\n                Include: tag.attrib.Include,\n                versions: tag.attrib.versions,\n                deviceTarget: tag.attrib['device-target'] || tag.attrib.target\n            };\n        });\n        return libFiles;\n    }\n\n    // <hook>\n    // Example:\n    // <hook type=\"before_build\" src=\"scripts/beforeBuild.js\" />\n    self.getHookScripts = getHookScripts;\n    function getHookScripts(hook, platforms) {\n        var scriptElements =  self._et.findall('./hook');\n\n        if(platforms) {\n            platforms.forEach(function (platform) {\n                scriptElements = scriptElements.concat(self._et.findall('./platform[@name=\"' + platform + '\"]/hook'));\n            });\n        }\n\n        function filterScriptByHookType(el) {\n            return el.attrib.src && el.attrib.type && el.attrib.type.toLowerCase() === hook;\n        }\n\n        return scriptElements.filter(filterScriptByHookType);\n    }\n\n    self.getJsModules = getJsModules;\n    function getJsModules(platform) {\n        var modules = _getTags(self._et, 'js-module', platform, _parseJsModule);\n        return modules;\n    }\n\n    function _parseJsModule(tag) {\n        var ret = {\n            itemType: 'js-module',\n            name: tag.attrib.name,\n            src: tag.attrib.src,\n            clobbers: tag.findall('clobbers').map(function(tag) { return { target: tag.attrib.target }; }),\n            merges: tag.findall('merges').map(function(tag) { return { target: tag.attrib.target }; }),\n            runs: tag.findall('runs').length > 0\n        };\n\n        return ret;\n    }\n\n    self.getEngines = function() {\n        return self._et.findall('engines/engine').map(function(n) {\n            return {\n                name: n.attrib.name,\n                version: n.attrib.version,\n                platform: n.attrib.platform,\n                scriptSrc: n.attrib.scriptSrc\n            };\n        });\n    };\n\n    self.getPlatforms = function() {\n        return self._et.findall('platform').map(function(n) {\n            return { name: n.attrib.name };\n        });\n    };\n\n    self.getPlatformsArray = function() {\n        return self._et.findall('platform').map(function(n) {\n            return n.attrib.name;\n        });\n    };\n    self.getFrameworks = function(platform) {\n        return _getTags(self._et, 'framework', platform, function(el) {\n            var ret = {\n                itemType: 'framework',\n                type: el.attrib.type,\n                parent: el.attrib.parent,\n                custom: isStrTrue(el.attrib.custom),\n                src: el.attrib.src,\n                spec: el.attrib.spec,\n                weak: isStrTrue(el.attrib.weak),\n                versions: el.attrib.versions,\n                targetDir: el.attrib['target-dir'],\n                deviceTarget: el.attrib['device-target'] || el.attrib.target,\n                arch: el.attrib.arch\n            };\n            return ret;\n        });\n    };\n\n    self.getFilesAndFrameworks = getFilesAndFrameworks;\n    function getFilesAndFrameworks(platform) {\n        // Please avoid changing the order of the calls below, files will be\n        // installed in this order.\n        var items = [].concat(\n            self.getSourceFiles(platform),\n            self.getHeaderFiles(platform),\n            self.getResourceFiles(platform),\n            self.getFrameworks(platform),\n            self.getLibFiles(platform)\n        );\n        return items;\n    }\n    ///// End of PluginInfo methods /////\n\n\n    ///// PluginInfo Constructor logic  /////\n    self.filepath = path.join(dirname, 'plugin.xml');\n    if (!fs.existsSync(self.filepath)) {\n        throw new CordovaError('Cannot find plugin.xml for plugin \"' + path.basename(dirname) + '\". Please try adding it again.');\n    }\n\n    self.dir = dirname;\n    var et = self._et = xml_helpers.parseElementtreeSync(self.filepath);\n    var pelem = et.getroot();\n    self.id = pelem.attrib.id;\n    self.version = pelem.attrib.version;\n\n    // Optional fields\n    self.name = pelem.findtext('name');\n    self.description = pelem.findtext('description');\n    self.license = pelem.findtext('license');\n    self.repo = pelem.findtext('repo');\n    self.issue = pelem.findtext('issue');\n    self.keywords = pelem.findtext('keywords');\n    self.info = pelem.findtext('info');\n    if (self.keywords) {\n        self.keywords = self.keywords.split(',').map( function(s) { return s.trim(); } );\n    }\n    self.getKeywordsAndPlatforms = function () {\n        var ret = self.keywords || [];\n        return ret.concat('ecosystem:cordova').concat(addCordova(self.getPlatformsArray()));\n    };\n}  // End of PluginInfo constructor.\n\n// Helper function used to prefix every element of an array with cordova-\n// Useful when we want to modify platforms to be cordova-platform\nfunction addCordova(someArray) {\n    var newArray = someArray.map(function(element) {\n        return 'cordova-' + element;\n    });\n    return newArray;\n}\n\n// Helper function used by most of the getSomething methods of PluginInfo.\n// Get all elements of a given name. Both in root and in platform sections\n// for the given platform. If transform is given and is a function, it is\n// applied to each element.\nfunction _getTags(pelem, tag, platform, transform) {\n    var platformTag = pelem.find('./platform[@name=\"' + platform + '\"]');\n    var tagsInRoot = pelem.findall(tag);\n    tagsInRoot = tagsInRoot || [];\n    var tagsInPlatform = platformTag ? platformTag.findall(tag) : [];\n    var tags = tagsInRoot.concat(tagsInPlatform);\n    if ( typeof transform === 'function' ) {\n        tags = tags.map(transform);\n    }\n    return tags;\n}\n\n// Same as _getTags() but only looks inside a platform section.\nfunction _getTagsInPlatform(pelem, tag, platform, transform) {\n    var platformTag = pelem.find('./platform[@name=\"' + platform + '\"]');\n    var tags = platformTag ? platformTag.findall(tag) : [];\n    if ( typeof transform === 'function' ) {\n        tags = tags.map(transform);\n    }\n    return tags;\n}\n\n// Check if x is a string 'true'.\nfunction isStrTrue(x) {\n    return String(x).toLowerCase() == 'true';\n}\n\nmodule.exports = PluginInfo;\n// Backwards compat:\nPluginInfo.PluginInfo = PluginInfo;\nPluginInfo.loadPluginsDir = function(dir) {\n    var PluginInfoProvider = require('./PluginInfoProvider');\n    return new PluginInfoProvider().getAllWithinSearchPath(dir);\n};\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/util/xml-helpers.js":"/*\n *\n * Copyright 2013 Anis Kadri\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* jshint sub:true, laxcomma:true */\n\n/**\n * contains XML utility functions, some of which are specific to elementtree\n */\n\nvar fs = require('fs')\n  , path = require('path')\n  , _ = require('underscore')\n  , et = require('elementtree')\n  ;\n\n  var ROOT = /^\\/([^\\/]*)/,\n      ABSOLUTE = /^\\/([^\\/]*)\\/(.*)/;\n\nmodule.exports = {\n    // compare two et.XML nodes, see if they match\n    // compares tagName, text, attributes and children (recursively)\n    equalNodes: function(one, two) {\n        if (one.tag != two.tag) {\n            return false;\n        } else if (one.text.trim() != two.text.trim()) {\n            return false;\n        } else if (one._children.length != two._children.length) {\n            return false;\n        }\n\n        if (!attribMatch(one, two)) return false;\n\n        for (var i = 0; i < one._children.length; i++) {\n            if (!module.exports.equalNodes(one._children[i], two._children[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    },\n\n    // adds node to doc at selector, creating parent if it doesn't exist\n    graftXML: function(doc, nodes, selector, after) {\n        var parent = module.exports.resolveParent(doc, selector);\n        if (!parent) {\n            //Try to create the parent recursively if necessary\n            try {\n                var parentToCreate = et.XML('<' + path.basename(selector) + '>'),\n                    parentSelector = path.dirname(selector);\n\n                this.graftXML(doc, [parentToCreate], parentSelector);\n            } catch (e) {\n                return false;\n            }\n            parent = module.exports.resolveParent(doc, selector);\n            if (!parent) return false;\n        }\n\n        nodes.forEach(function (node) {\n            // check if child is unique first\n            if (uniqueChild(node, parent)) {\n                var children = parent.getchildren();\n                var insertIdx = after ? findInsertIdx(children, after) : children.length;\n\n                //TODO: replace with parent.insert after the bug in ElementTree is fixed\n                parent.getchildren().splice(insertIdx, 0, node);\n            }\n        });\n\n        return true;\n    },\n\n    // adds new attributes to doc at selector\n    // Will only merge if attribute has not been modified already or --force is used\n    graftXMLMerge: function(doc, nodes, selector, xml) {\n        var target = module.exports.resolveParent(doc, selector);\n        if (!target) return false;\n\n        // saves the attributes of the original xml before making changes\n        xml.oldAttrib = _.extend({}, target.attrib);\n\n        nodes.forEach(function (node) {\n            var attributes = node.attrib;\n            for (var attribute in attributes) {\n                target.attrib[attribute] = node.attrib[attribute];\n            }\n        });\n\n        return true;\n    },\n\n    // overwrite all attributes to doc at selector with new attributes\n    // Will only overwrite if attribute has not been modified already or --force is used\n    graftXMLOverwrite: function(doc, nodes, selector, xml) {\n        var target = module.exports.resolveParent(doc, selector);\n        if (!target) return false;\n\n        // saves the attributes of the original xml before making changes\n        xml.oldAttrib = _.extend({}, target.attrib);\n\n        // remove old attributes from target\n        var targetAttributes = target.attrib;\n        for (var targetAttribute in targetAttributes) {\n            delete targetAttributes[targetAttribute];\n        }\n\n        // add new attributes to target\n        nodes.forEach(function (node) {\n            var attributes = node.attrib;\n            for (var attribute in attributes) {\n                target.attrib[attribute] = node.attrib[attribute];\n            }\n        });\n\n        return true;\n    },\n\n    // removes node from doc at selector\n    pruneXML: function(doc, nodes, selector) {\n        var parent = module.exports.resolveParent(doc, selector);\n        if (!parent) return false;\n\n        nodes.forEach(function (node) {\n            var matchingKid = null;\n            if ((matchingKid = findChild(node, parent)) !== null) {\n                // stupid elementtree takes an index argument it doesn't use\n                // and does not conform to the python lib\n                parent.remove(matchingKid);\n            }\n        });\n\n        return true;\n    },\n\n    // restores attributes from doc at selector\n    pruneXMLRestore: function(doc, selector, xml) {\n        var target = module.exports.resolveParent(doc, selector);\n        if (!target) return false;\n\n        if (xml.oldAttrib) {\n            target.attrib = _.extend({}, xml.oldAttrib);\n        }\n\n        return true;\n    },\n\n    prunXMLRemove: function(doc, selector, nodes) {\n        var target = module.exports.resolveParent(doc, selector);\n        if (!target) return false;\n\n        nodes.forEach(function (node) {\n            var attributes = node.attrib;\n            for (var attribute in attributes) {\n                if (target.attrib[attribute]) {\n                    delete target.attrib[attribute];\n                }\n            }\n        });\n\n        return true;\n\n    },\n\n\n    parseElementtreeSync: function (filename) {\n        var contents = fs.readFileSync(filename, 'utf-8');\n        if(contents) {\n            //Windows is the BOM. Skip the Byte Order Mark.\n            contents = contents.substring(contents.indexOf('<'));\n        }\n        return new et.ElementTree(et.XML(contents));\n    },\n\n    resolveParent: function (doc, selector) {\n        var parent, tagName, subSelector;\n\n        // handle absolute selector (which elementtree doesn't like)\n        if (ROOT.test(selector)) {\n            tagName = selector.match(ROOT)[1];\n            // test for wildcard \"any-tag\" root selector\n            if (tagName == '*' || tagName === doc._root.tag) {\n                parent = doc._root;\n\n                // could be an absolute path, but not selecting the root\n                if (ABSOLUTE.test(selector)) {\n                    subSelector = selector.match(ABSOLUTE)[2];\n                    parent = parent.find(subSelector);\n                }\n            } else {\n                return false;\n            }\n        } else {\n            parent = doc.find(selector);\n        }\n        return parent;\n    }\n};\n\nfunction findChild(node, parent) {\n    var matchingKids = parent.findall(node.tag)\n      , i, j;\n\n    for (i = 0, j = matchingKids.length ; i < j ; i++) {\n        if (module.exports.equalNodes(node, matchingKids[i])) {\n            return matchingKids[i];\n        }\n    }\n    return null;\n}\n\nfunction uniqueChild(node, parent) {\n    var matchingKids = parent.findall(node.tag)\n      , i = 0;\n\n    if (matchingKids.length === 0) {\n        return true;\n    } else  {\n        for (i; i < matchingKids.length; i++) {\n            if (module.exports.equalNodes(node, matchingKids[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// Find the index at which to insert an entry. After is a ;-separated priority list\n// of tags after which the insertion should be made. E.g. If we need to\n// insert an element C, and the rule is that the order of children has to be\n// As, Bs, Cs. After will be equal to \"C;B;A\".\nfunction findInsertIdx(children, after) {\n    var childrenTags = children.map(function(child) { return child.tag; });\n    var afters = after.split(';');\n    var afterIndexes = afters.map(function(current) { return childrenTags.lastIndexOf(current); });\n    var foundIndex = _.find(afterIndexes, function(index) { return index != -1; });\n\n    //add to the beginning if no matching nodes are found\n    return typeof foundIndex === 'undefined' ? 0 : foundIndex+1;\n}\n\nvar BLACKLIST = ['platform', 'feature','plugin','engine'];\nvar SINGLETONS = ['content', 'author', 'name'];\nfunction mergeXml(src, dest, platform, clobber) {\n    // Do nothing for blacklisted tags.\n    if (BLACKLIST.indexOf(src.tag) != -1) return;\n\n    //Handle attributes\n    Object.getOwnPropertyNames(src.attrib).forEach(function (attribute) {\n        if (clobber || !dest.attrib[attribute]) {\n            dest.attrib[attribute] = src.attrib[attribute];\n        }\n    });\n    //Handle text\n    if (src.text && (clobber || !dest.text)) {\n        dest.text = src.text;\n    }\n    //Handle children\n    src.getchildren().forEach(mergeChild);\n\n    //Handle platform\n    if (platform) {\n        src.findall('platform[@name=\"' + platform + '\"]').forEach(function (platformElement) {\n            platformElement.getchildren().forEach(mergeChild);\n        });\n    }\n\n    //Handle duplicate preference tags (by name attribute)\n    removeDuplicatePreferences(dest);\n\n    function mergeChild (srcChild) {\n        var srcTag = srcChild.tag,\n            destChild = new et.Element(srcTag),\n            foundChild,\n            query = srcTag + '',\n            shouldMerge = true;\n\n        if (BLACKLIST.indexOf(srcTag) !== -1) return;\n\n        if (SINGLETONS.indexOf(srcTag) !== -1) {\n            foundChild = dest.find(query);\n            if (foundChild) {\n                destChild = foundChild;\n                dest.remove(destChild);\n            }\n        } else {\n            //Check for an exact match and if you find one don't add\n            var mergeCandidates = dest.findall(query)\n            .filter(function (foundChild) {\n                return foundChild && textMatch(srcChild, foundChild) && attribMatch(srcChild, foundChild);\n            });\n\n            if (mergeCandidates.length > 0) {\n                destChild = mergeCandidates[0];\n                dest.remove(destChild);\n                shouldMerge = false;\n            }\n        }\n\n        mergeXml(srcChild, destChild, platform, clobber && shouldMerge);\n        dest.append(destChild);\n    }\n\n    function removeDuplicatePreferences(xml) {\n        // reduce preference tags to a hashtable to remove dupes\n        var prefHash = xml.findall('preference[@name][@value]').reduce(function(previousValue, currentValue) {\n            previousValue[ currentValue.attrib.name ] = currentValue.attrib.value;\n            return previousValue;\n        }, {});\n\n        // remove all preferences\n        xml.findall('preference[@name][@value]').forEach(function(pref) {\n            xml.remove(pref);\n        });\n\n        // write new preferences\n        Object.keys(prefHash).forEach(function(key, index) {\n            var element = et.SubElement(xml, 'preference');\n            element.set('name', key);\n            element.set('value', this[key]);\n        }, prefHash);\n    }\n}\n\n// Expose for testing.\nmodule.exports.mergeXml = mergeXml;\n\nfunction textMatch(elm1, elm2) {\n    var text1 = elm1.text ? elm1.text.replace(/\\s+/, '') : '',\n        text2 = elm2.text ? elm2.text.replace(/\\s+/, '') : '';\n    return (text1 === '' || text1 === text2);\n}\n\nfunction attribMatch(one, two) {\n    var oneAttribKeys = Object.keys(one.attrib);\n    var twoAttribKeys = Object.keys(two.attrib);\n\n    if (oneAttribKeys.length != twoAttribKeys.length) {\n        return false;\n    }\n\n    for (var i = 0; i < oneAttribKeys.length; i++) {\n        var attribName = oneAttribKeys[i];\n\n        if (one.attrib[attribName] != two.attrib[attribName]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/underscore/underscore.js":"//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/publish/market.js":"const Url = require('url');\nconst Http = require('http');\nconst chalk = require('chalk');\nconst crypto = require('crypto');\nconst Fs = require('fs');\nconst Path = require('path');\nconst os = require('os');\nvar _mapper = {};\nconst TMP_DIR = typeof os.tmpdir === 'function' ? os.tmpdir() : os.tmpDir();\nconst CACHE_FILE_NAME = 'registry_map.json';\ntry {\n  _mapper = JSON.parse(Fs.readFileSync(Path.join(TMP_DIR, CACHE_FILE_NAME)));\n} catch (e) {\n\n}\nlet marketEnv = 'online';\nlet marketUrlMap = {\n  'online': 'http://market.dotwe.org',\n  'pre': 'http://market-pre.dotwe.org',\n  'daily': 'http://weex-market.taobao.net'\n};\nlet argv = process.argv.join(' ');\nlet match = /--market(?:\\s+|=)(.+)(\\s|$)/.exec(argv);\nif (match) {\n  marketEnv = match[1];\n}\nfunction resolveFullName(name,namespace){\n  return namespace?namespace+'-'+name:name\n}\nexports.domain = marketUrlMap[marketEnv];\nexports.publish = function (name, namespace, fullname,ali, version, extend) {\n  extend = extend || {}\n  return new Promise(function (resolve, reject) {\n    let url = exports.domain + '/json/sync/sync.json?name=' + name +  '&fullname=' + fullname + '&p=' + !!ali+(namespace?'&namespace=' + namespace :'');\n    if(extend&&extend.weexpack == \"0.4.0\"){\n      url += \"&wpv=4\"\n    }\n\n    post(url, extend).then(function (res) {\n      if (res.success) {\n        console.log();\n        console.log(chalk.yellow('plugin [' + name + '@' + version + '] publish success! sync to market maybe need a few minutes.'));\n        console.log(chalk.yellow(`you can visit ${exports.domain} see your plugin. if not exist you can retry ${chalk.blue('weexpack plugin publish')}`))\n        console.log();\n        resolve()\n      }\n      else if (res.data.code == 10004) {\n        console.error(chalk.red(`Market sync rejected! Namespace unmatched!`));\n      }\n    }).catch(function (e) {\n      console.error(chalk.red(`Market sync failed! Please retry ${chalk.blue('weexpack plugin publish')}`));\n      console.error(chalk.grey('error info:'+e));\n    })\n  })\n\n};\n\nexports.apply = function (name, p) {\n  return new Promise((resolve, reject)=> {\n    post(exports.domain + '/json/sync/apply.json?name=' + name + '&p=' + !!p).then(function (res) {\n      if (res.success) {\n        resolve(res.data);\n      }\n      else {\n        throw new Error('apply plugin fullname error!');\n      }\n\n    }).catch(function (e) {\n      console.error(chalk.red(`\\nMarket apply failed! Please retry ${chalk.blue('weexpack plugin publish')}\\n`));\n      console.error(chalk.grey('error info:'+e));\n    })\n  })\n};\nglobal.WeexMarket = {};\n\nglobal.WeexMarket.info = exports.info = function (name) {\n  if (_mapper[name]) {\n    return Promise.resolve(_mapper[name]);\n  }\n  else {\n    return new Promise((resolve, reject)=> {\n      post(exports.domain + '/json/sync/info.json?name=' + name).then(function (res) {\n        if (res.success) {\n          _mapper[name] = res.data;\n          try {\n            Fs.writeFileSync(Path.join(TMP_DIR, CACHE_FILE_NAME), JSON.stringify(_mapper, null, 4))\n          } catch (e) {\n            console.error('registry map save error');\n          }\n          resolve(res.data)\n        }\n        else {\n          if (res.data && res.data.code === '10001') {\n            reject('plugin \"' + name + '\" not found')\n          }\n          else {\n            reject('market error:' + JSON.stringify(res));\n          }\n        }\n\n      }, function (e) {\n        reject(e.toString());\n      })\n    })\n  }\n}\nvar post = function (url, data) {\n  return new Promise(function (resolve, reject) {\n    var urlObj = Url.parse(url);\n    if (data) {\n      data = new Buffer(JSON.stringify(data));\n      var headers = {\n        \"Content-Type\": 'application/json;charset=UTF-8',\n        \"Content-Length\": data.length\n      }\n    }\n    else {\n      headers = {\n        \"Content-Length\": 0\n      }\n    }\n\n    var req = Http.request({\n      host: urlObj.hostname,\n      method: 'post',\n      path: urlObj.path,\n      port: urlObj.port || 80,\n      headers: headers\n    }, function (res) {\n      var body = '';\n      res.on('data', function (chunk) {\n        body += chunk.toString();\n      });\n      res.on('end', function () {\n        if (res.statusCode == 200) {\n          try {\n            resolve(JSON.parse(body));\n          } catch (e) {\n            resolve(body);\n          }\n        }\n        else {\n          reject(res.statusCode);\n        }\n      });\n    });\n\n    req.on('error', function (err) {\n      var e = new Error('Connect Error for request for ' + url);\n      e.name = 'Http Request Error';\n      reject(e);\n    });\n    if (data != null)req.write(data);\n    req.end();\n  })\n};\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/utils/cache.js":"/**\n * Created by godsong on 16/12/21.\n */\nconst Fs = require('fs');\nconst Path = require('path');\nclass CacheManager {\n  constructor(defaultCache = {}) {\n    this.cache = defaultCache;\n  }\n  init(path) {\n    this.path = path||Path.join(process.cwd(), '.weexpack.cache');\n    try {\n      this.cache = JSON.parse(Fs.readFileSync(this.path).toString());\n    } catch (e) {\n    }\n  }\n\n  get(prop, defaultValue) {\n    let props = prop.split('.'), p, cur = this.cache;\n    while (p = props.shift()) {\n      cur = cur[p];\n      if (cur === undefined || cur ===null)break;\n    }\n    return cur || defaultValue;\n  }\n  save() {\n    Fs.writeFileSync(this.path, JSON.stringify(this.cache, null, 4));\n  }\n}\nmodule.exports = new CacheManager();\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/config/android.config.js":"","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/config/ios.config.js":"","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/config/weex.config.js":"","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/create.js":"/*\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar CordovaCliCreate = function () {\n\n}; \n\n/**\n * provides logic for exposing cordova-lib create functionality to the command line\n * the create argument is implied from the call to this function, all other cl arguments should be passed in unmodified\n * \n * @args  - \n * @undashed \n */\nCordovaCliCreate.prototype.run = function (args, undashed) {\n    var cfg = {},\n        customWww;\n\n    // parseConfig will determine if there's a valid config JSON string\n    cfg = this.parseConfig(undashed[4]);\n    \n    // create(dir, id, name, cfg)\n    cordova.raw.create( undashed[1]  // dir to create the project in\n                      , undashed[2]  // App id\n                      , undashed[3]  // App name\n                      , cfg\n    ).done();\n};\n\n/**\n * parseConfig\n * generic parser, if it's valid json, returns the resulting object\n * if anything resolving to false is passed in, return an empty object \n * invalid json results in an error message and process exit with status code 2.\n *\n * jsondata - a json data string\n *\n */\nCordovaCliCreate.prototype.parseConfig = function (jsondata) {\n    if (!jsondata) return {};\n\n    try {\n        cfg = JSON.parse(jsondata);\n    } catch (e) {\n        console.error('Error while parsing json data\\nError: '+ e +'\\nData:' + jsondata);\n        process.exit(2); \n    }\n};\nCordovaCliCreate.prototype.customWww = function (args) {\n\n    // handle custom www\n    if (customWww = args['copy-from'] || args['link-to']) {\n\n        if (customWww.indexOf(':') != -1) {\n            throw new CordovaError(\n            'Only local paths for custom www assets are supported.'\n            );\n\n        }\n\n        if ( customWww.substr(0,1) === '~' ) {  // resolve tilde in a naive way.\n            customWww = path.join(process.env.HOME,  customWww.substr(1));\n        }\n\n        customWww = path.resolve(customWww);\n        var wwwCfg = { uri: customWww };\n        if (args['link-to']) {\n            wwwCfg.link = true;\n        }\n\n        cfg.lib = cfg.lib || {};\n        cfg.lib.www = wwwCfg;\n    }\n};\n\nmodule.exports = new CordovaCliCreate();\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/weexapp/webpack.config.js":"require('webpack');\nrequire('weex-loader');\nvar path = require('path');\nvar fs = require('fs');\nvar entry = {};\n\nfunction walk(dir, root) {\n  var directory = path.join(__dirname, root, dir)\n  fs.readdirSync(directory).forEach(function (file) {\n      var fullpath = path.join(directory, file)\n      var stat = fs.statSync(fullpath)\n        // support for vue file\n      if (stat.isFile() && (path.extname(fullpath) === '.we' || path.extname(fullpath) === '.vue')) {\n          var name = path.join(dir, path.basename(file, '.we'))\n          entry[name] = fullpath + '?entry=true'\n        }\n        else if (stat.isDirectory()) {\n          var subdir = path.join(dir, file)\n          walk(subdir, root)\n        }\n      })\n  }\n  walk('./', 'src');\n  module.exports = {\n    entry: entry\n    , output: {\n      path: 'dist'\n      , filename: '[name].js'\n    }\n    , devtool: 'inline-source-map'\n    , module: {\n      loaders: [\n        {\n          test: /\\.we(\\?[^?]+)?$/\n          , loaders: ['weex-loader']\n      }\n        , {\n          test: /\\.vue(\\?[^?]+)?$/\n          , loaders: ['vue']\n      }\n    ]\n    }\n  }","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/CordovaExternalToolErrorContext.js":"/**\n Licensed to the Apache Software Foundation (ASF) under one\n or more contributor license agreements.  See the NOTICE file\n distributed with this work for additional information\n regarding copyright ownership.  The ASF licenses this file\n to you under the Apache License, Version 2.0 (the\n \"License\"); you may not use this file except in compliance\n with the License.  You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing,\n software distributed under the License is distributed on an\n \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n KIND, either express or implied.  See the License for the\n specific language governing permissions and limitations\n under the License.\n */\n\n/* jshint proto:true */\n\nvar path = require('path');\n\n/**\n * @param {String} cmd Command full path\n * @param {String[]} args Command args\n * @param {String} [cwd] Command working directory\n * @constructor\n */\nfunction CordovaExternalToolErrorContext(cmd, args, cwd) {\n    this.cmd = cmd;\n    // Helper field for readability\n    this.cmdShortName = path.basename(cmd);\n    this.args = args;\n    this.cwd = cwd;\n}\n\nCordovaExternalToolErrorContext.prototype.toString = function(isVerbose) {\n    if(isVerbose) {\n        return 'External tool \\'' + this.cmdShortName + '\\'' +\n            '\\nCommand full path: ' + this.cmd + '\\nCommand args: ' + this.args +\n            (typeof this.cwd !== 'undefined' ? '\\nCommand cwd: ' + this.cwd : '');\n    }\n\n    return this.cmdShortName;\n};\n\nmodule.exports = CordovaExternalToolErrorContext;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/gitclone.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar  Q             = require('q'),\n     shell         = require('shelljs'),\n     events        = require('weexpack-common').events,\n     path          = require('path'),\n     superspawn    = require('weexpack-common').superspawn,\n     os            = require('os');\n\n\nexports.clone = clone;\n\n//  clone_dir, if provided is the directory that git will clone into.\n//  if no clone_dir is supplied, a temp directory will be created and used by git.\nfunction clone(git_url, git_ref, clone_dir){\n    \n    var needsGitCheckout = !!git_ref;\n    if (!shell.which('git')) {\n        return Q.reject(new Error('\"git\" command line tool is not installed: make sure it is accessible on your PATH.'));\n    }\n\n    // If no clone_dir is specified, create a tmp dir which git will clone into.\n    var tmp_dir = clone_dir;\n    if(!tmp_dir){\n        tmp_dir = path.join(os.tmpdir(), 'git', String((new Date()).valueOf()));\n    }\n    shell.rm('-rf', tmp_dir);\n    shell.mkdir('-p', tmp_dir);\n    \n    var cloneArgs = ['clone'];\n    if(!needsGitCheckout) {\n        // only get depth of 1 if there is no branch/commit specified\n        cloneArgs.push('--depth=1');\n    }\n    cloneArgs.push(git_url, tmp_dir);\n    return superspawn.spawn('git', cloneArgs)\n    .then(function() {\n        if (needsGitCheckout){\n            return superspawn.spawn('git', ['checkout', git_ref], {\n                cwd: tmp_dir\n            });\n        }\n    })\n    .then(function(){\n        events.emit('log', 'Repository \"' + git_url + '\" checked out to git ref \"' + (git_ref || 'master') + '\".');\n        return tmp_dir;\n    })\n    .fail(function (err) {\n        shell.rm('-rf', tmp_dir);\n        return Q.reject(err);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/superspawn.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar child_process = require('child_process');\nvar fs = require('fs');\nvar path = require('path');\nvar _ = require('underscore');\nvar Q = require('q');\nvar shell = require('shelljs');\nvar events = require('./events');\nvar iswin32 = process.platform == 'win32';\n\n// On Windows, spawn() for batch files requires absolute path & having the extension.\nfunction resolveWindowsExe(cmd) {\n    var winExtensions = ['.exe', '.bat', '.cmd', '.js', '.vbs'];\n    function isValidExe(c) {\n        return winExtensions.indexOf(path.extname(c)) !== -1 && fs.existsSync(c);\n    }\n    if (isValidExe(cmd)) {\n        return cmd;\n    }\n    cmd = shell.which(cmd) || cmd;\n    if (!isValidExe(cmd)) {\n        winExtensions.some(function(ext) {\n            if (fs.existsSync(cmd + ext)) {\n                cmd = cmd + ext;\n                return true;\n            }\n        });\n    }\n    return cmd;\n}\n\nfunction maybeQuote(a) {\n    if (/^[^\"].*[ &].*[^\"]/.test(a)) return '\"' + a + '\"';\n    return a;\n}\n\n/**\n * A special implementation for child_process.spawn that handles\n *   Windows-specific issues with batch files and spaces in paths. Returns a\n *   promise that succeeds only for return code 0. It is also possible to\n *   subscribe on spawned process' stdout and stderr streams using progress\n *   handler for resultant promise.\n *\n * @example spawn('mycommand', [], {stdio: 'pipe'}) .progress(function (stdio){\n *   if (stdio.stderr) { console.error(stdio.stderr); } })\n *   .then(function(result){ // do other stuff })\n *\n * @param   {String}   cmd       A command to spawn\n * @param   {String[]} [args=[]]  An array of arguments, passed to spawned\n *   process\n * @param   {Object}   [opts={}]  A configuration object\n * @param   {String|String[]|Object} opts.stdio Property that configures how\n *   spawned process' stdio will behave. Has the same meaning and possible\n *   values as 'stdio' options for child_process.spawn method\n *   (https://nodejs.org/api/child_process.html#child_process_options_stdio).\n * @param {Object}     [env={}]  A map of extra environment variables\n * @param {String}     [cwd=process.cwd()]  Working directory for the command\n * @param {Boolean}    [chmod=false]  If truthy, will attempt to set the execute\n *   bit before executing on non-Windows platforms\n *\n * @return  {Promise}        A promise that is either fulfilled if the spawned\n *   process is exited with zero error code or rejected otherwise. If the\n *   'stdio' option set to 'default' or 'pipe', the promise also emits progress\n *   messages with the following contents:\n *   {\n *       'stdout': ...,\n *       'stderr': ...\n *   }\n */\nexports.spawn = function(cmd, args, opts) {\n    args = args || [];\n    opts = opts || {};\n    var spawnOpts = {};\n    var d = Q.defer();\n\n    if (iswin32) {\n        cmd = resolveWindowsExe(cmd);\n        // If we couldn't find the file, likely we'll end up failing,\n        // but for things like \"del\", cmd will do the trick.\n        if (path.extname(cmd) != '.exe') {\n            var cmdArgs = '\"' + [cmd].concat(args).map(maybeQuote).join(' ') + '\"';\n            // We need to use /s to ensure that spaces are parsed properly with cmd spawned content\n            args = [['/s', '/c', cmdArgs].join(' ')];\n            cmd = 'cmd';\n            spawnOpts.windowsVerbatimArguments = true;\n        } else if (!fs.existsSync(cmd)) {\n            // We need to use /s to ensure that spaces are parsed properly with cmd spawned content\n            args = ['/s', '/c', cmd].concat(args).map(maybeQuote);\n        }\n    }\n\n    if (opts.stdio !== 'default') {\n        // Ignore 'default' value for stdio because it corresponds to child_process's default 'pipe' option\n        spawnOpts.stdio = opts.stdio;\n    }\n\n    if (opts.cwd) {\n        spawnOpts.cwd = opts.cwd;\n    }\n\n    if (opts.env) {\n        spawnOpts.env = _.extend(_.extend({}, process.env), opts.env);\n    }\n\n    if (opts.chmod && !iswin32) {\n        try {\n            // This fails when module is installed in a system directory (e.g. via sudo npm install)\n            fs.chmodSync(cmd, '755');\n        } catch (e) {\n            // If the perms weren't set right, then this will come as an error upon execution.\n        }\n    }\n\n    events.emit(opts.printCommand ? 'log' : 'verbose', 'Running command: ' + maybeQuote(cmd) + ' ' + args.map(maybeQuote).join(' '));\n\n    var child = child_process.spawn(cmd, args, spawnOpts);\n    var capturedOut = '';\n    var capturedErr = '';\n\n    if (child.stdout) {\n        child.stdout.setEncoding('utf8');\n        child.stdout.on('data', function(data) {\n            capturedOut += data;\n            d.notify({'stdout': data});\n        });\n    }\n\n    if (child.stderr) {\n        child.stderr.setEncoding('utf8');\n        child.stderr.on('data', function(data) {\n            capturedErr += data;\n            d.notify({'stderr': data});\n        });\n    }\n\n    child.on('close', whenDone);\n    child.on('error', whenDone);\n    function whenDone(arg) {\n        child.removeListener('close', whenDone);\n        child.removeListener('error', whenDone);\n        var code = typeof arg == 'number' ? arg : arg && arg.code;\n\n        events.emit('verbose', 'Command finished with error code ' + code + ': ' + cmd + ' ' + args);\n        if (code === 0) {\n            d.resolve(capturedOut.trim());\n        } else {\n            var errMsg = cmd + ': Command failed with exit code ' + code;\n            if (capturedErr) {\n                errMsg += ' Error output:\\n' + capturedErr.trim();\n            }\n            var err = new Error(errMsg);\n            err.code = code;\n            d.reject(err);\n        }\n    }\n\n    return d.promise;\n};\n\nexports.maybeSpawn = function(cmd, args, opts) {\n    if (fs.existsSync(cmd)) {\n        return exports.spawn(cmd, args, opts);\n    }\n    return Q(null);\n};\n\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/q/q.js":"// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.toString()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you don’t need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Miller’s explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {\n    obj[prop] = descriptor.value;\n    return obj;\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n                object_defineProperty(error, \"__minimumStackCounter__\", {value: p.stackCounter, configurable: true});\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        var stack = filterStackString(concatedStacks);\n        object_defineProperty(error, \"stack\", {value: stack, configurable: true});\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n/**\n * The counter is used to determine the stopping point for building\n * long stack traces. In makeStackTraceLong we walk backwards through\n * the linked list of promises, only stacks which were created before\n * the rejection are concatenated.\n */\nvar longStackCounter = 1;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n            promise.stackCounter = longStackCounter++;\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n\n        if (Q.longStackSupport && hasStacks) {\n            // Only hold a reference to the new promise if long stacks\n            // are enabled to reduce memory usage\n            promise.source = newPromise;\n        }\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If it’s a fulfilled promise, the fulfillment value is nearer.\n * If it’s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected(err) {\n            pendingCount--;\n            if (pendingCount === 0) {\n                err.message = (\"Q can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected. Last error message: \" + err.message);\n                deferred.reject(err);\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    if (!callback || typeof callback.apply !== \"function\") {\n        throw new Error(\"Q can't apply finally callback\");\n    }\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    if (callback === undefined) {\n        throw new Error(\"Q can't wrap an undefined function\");\n    }\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/shell.js":"//\n// ShellJS\n// Unix shell commands on top of Node's API\n//\n// Copyright (c) 2012 Artur Adib\n// http://github.com/arturadib/shelljs\n//\n\nvar common = require('./src/common');\n\n\n//@\n//@ All commands run synchronously, unless otherwise stated.\n//@\n\n//@include ./src/cd\nvar _cd = require('./src/cd');\nexports.cd = common.wrap('cd', _cd);\n\n//@include ./src/pwd\nvar _pwd = require('./src/pwd');\nexports.pwd = common.wrap('pwd', _pwd);\n\n//@include ./src/ls\nvar _ls = require('./src/ls');\nexports.ls = common.wrap('ls', _ls);\n\n//@include ./src/find\nvar _find = require('./src/find');\nexports.find = common.wrap('find', _find);\n\n//@include ./src/cp\nvar _cp = require('./src/cp');\nexports.cp = common.wrap('cp', _cp);\n\n//@include ./src/rm\nvar _rm = require('./src/rm');\nexports.rm = common.wrap('rm', _rm);\n\n//@include ./src/mv\nvar _mv = require('./src/mv');\nexports.mv = common.wrap('mv', _mv);\n\n//@include ./src/mkdir\nvar _mkdir = require('./src/mkdir');\nexports.mkdir = common.wrap('mkdir', _mkdir);\n\n//@include ./src/test\nvar _test = require('./src/test');\nexports.test = common.wrap('test', _test);\n\n//@include ./src/cat\nvar _cat = require('./src/cat');\nexports.cat = common.wrap('cat', _cat);\n\n//@include ./src/to\nvar _to = require('./src/to');\nString.prototype.to = common.wrap('to', _to);\n\n//@include ./src/toEnd\nvar _toEnd = require('./src/toEnd');\nString.prototype.toEnd = common.wrap('toEnd', _toEnd);\n\n//@include ./src/sed\nvar _sed = require('./src/sed');\nexports.sed = common.wrap('sed', _sed);\n\n//@include ./src/grep\nvar _grep = require('./src/grep');\nexports.grep = common.wrap('grep', _grep);\n\n//@include ./src/which\nvar _which = require('./src/which');\nexports.which = common.wrap('which', _which);\n\n//@include ./src/echo\nvar _echo = require('./src/echo');\nexports.echo = _echo; // don't common.wrap() as it could parse '-options'\n\n//@include ./src/dirs\nvar _dirs = require('./src/dirs').dirs;\nexports.dirs = common.wrap(\"dirs\", _dirs);\nvar _pushd = require('./src/dirs').pushd;\nexports.pushd = common.wrap('pushd', _pushd);\nvar _popd = require('./src/dirs').popd;\nexports.popd = common.wrap(\"popd\", _popd);\n\n//@include ./src/ln\nvar _ln = require('./src/ln');\nexports.ln = common.wrap('ln', _ln);\n\n//@\n//@ ### exit(code)\n//@ Exits the current process with the given exit code.\nexports.exit = process.exit;\n\n//@\n//@ ### env['VAR_NAME']\n//@ Object containing environment variables (both getter and setter). Shortcut to process.env.\nexports.env = process.env;\n\n//@include ./src/exec\nvar _exec = require('./src/exec');\nexports.exec = common.wrap('exec', _exec, {notUnix:true});\n\n//@include ./src/chmod\nvar _chmod = require('./src/chmod');\nexports.chmod = common.wrap('chmod', _chmod);\n\n\n\n//@\n//@ ## Non-Unix commands\n//@\n\n//@include ./src/tempdir\nvar _tempDir = require('./src/tempdir');\nexports.tempdir = common.wrap('tempdir', _tempDir);\n\n\n//@include ./src/error\nvar _error = require('./src/error');\nexports.error = _error;\n\n\n\n//@\n//@ ## Configuration\n//@\n\nexports.config = common.config;\n\n//@\n//@ ### config.silent\n//@ Example:\n//@\n//@ ```javascript\n//@ var sh = require('shelljs');\n//@ var silentState = sh.config.silent; // save old silent state\n//@ sh.config.silent = true;\n//@ /* ... */\n//@ sh.config.silent = silentState; // restore old silent state\n//@ ```\n//@\n//@ Suppresses all command output if `true`, except for `echo()` calls.\n//@ Default is `false`.\n\n//@\n//@ ### config.fatal\n//@ Example:\n//@\n//@ ```javascript\n//@ require('shelljs/global');\n//@ config.fatal = true;\n//@ cp('this_file_does_not_exist', '/dev/null'); // dies here\n//@ /* more commands... */\n//@ ```\n//@\n//@ If `true` the script will die on errors. Default is `false`.\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/common.js":"var os = require('os');\nvar fs = require('fs');\nvar _ls = require('./ls');\n\n// Module globals\nvar config = {\n  silent: false,\n  fatal: false\n};\nexports.config = config;\n\nvar state = {\n  error: null,\n  currentCmd: 'shell.js',\n  tempDir: null\n};\nexports.state = state;\n\nvar platform = os.type().match(/^Win/) ? 'win' : 'unix';\nexports.platform = platform;\n\nfunction log() {\n  if (!config.silent)\n    console.log.apply(this, arguments);\n}\nexports.log = log;\n\n// Shows error message. Throws unless _continue or config.fatal are true\nfunction error(msg, _continue) {\n  if (state.error === null)\n    state.error = '';\n  state.error += state.currentCmd + ': ' + msg + '\\n';\n\n  if (msg.length > 0)\n    log(state.error);\n\n  if (config.fatal)\n    process.exit(1);\n\n  if (!_continue)\n    throw '';\n}\nexports.error = error;\n\n// In the future, when Proxies are default, we can add methods like `.to()` to primitive strings.\n// For now, this is a dummy function to bookmark places we need such strings\nfunction ShellString(str) {\n  return str;\n}\nexports.ShellString = ShellString;\n\n// Returns {'alice': true, 'bob': false} when passed a dictionary, e.g.:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\nfunction parseOptions(str, map) {\n  if (!map)\n    error('parseOptions() internal error: no map given');\n\n  // All options are false by default\n  var options = {};\n  for (var letter in map)\n    options[map[letter]] = false;\n\n  if (!str)\n    return options; // defaults\n\n  if (typeof str !== 'string')\n    error('parseOptions() internal error: wrong str');\n\n  // e.g. match[1] = 'Rf' for str = '-Rf'\n  var match = str.match(/^\\-(.+)/);\n  if (!match)\n    return options;\n\n  // e.g. chars = ['R', 'f']\n  var chars = match[1].split('');\n\n  chars.forEach(function(c) {\n    if (c in map)\n      options[map[c]] = true;\n    else\n      error('option not recognized: '+c);\n  });\n\n  return options;\n}\nexports.parseOptions = parseOptions;\n\n// Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\nfunction expand(list) {\n  var expanded = [];\n  list.forEach(function(listEl) {\n    // Wildcard present on directory names ?\n    if(listEl.search(/\\*[^\\/]*\\//) > -1 || listEl.search(/\\*\\*[^\\/]*\\//) > -1) {\n      var match = listEl.match(/^([^*]+\\/|)(.*)/);\n      var root = match[1];\n      var rest = match[2];\n      var restRegex = rest.replace(/\\*\\*/g, \".*\").replace(/\\*/g, \"[^\\\\/]*\");\n      restRegex = new RegExp(restRegex);\n      \n      _ls('-R', root).filter(function (e) {\n        return restRegex.test(e);\n      }).forEach(function(file) {\n        expanded.push(file);\n      });\n    }\n    // Wildcard present on file names ?\n    else if (listEl.search(/\\*/) > -1) {\n      _ls('', listEl).forEach(function(file) {\n        expanded.push(file);\n      });\n    } else {\n      expanded.push(listEl);\n    }\n  });\n  return expanded;\n}\nexports.expand = expand;\n\n// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch(e) {\n    // Try to override file permission\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\nexports.unlinkSync = unlinkSync;\n\n// e.g. 'shelljs_a5f185d0443ca...'\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1)\n      return parseInt(16*Math.random(), 10).toString(16);\n    else {\n      var hash = '';\n      for (var i=0; i<count; i++)\n        hash += randomHash(1);\n      return hash;\n    }\n  }\n\n  return 'shelljs_'+randomHash(20);\n}\nexports.randomFileName = randomFileName;\n\n// extend(target_obj, source_obj1 [, source_obj2 ...])\n// Shallow extend, e.g.:\n//    extend({A:1}, {b:2}, {c:3}) returns {A:1, b:2, c:3}\nfunction extend(target) {\n  var sources = [].slice.call(arguments, 1);\n  sources.forEach(function(source) {\n    for (var key in source)\n      target[key] = source[key];\n  });\n\n  return target;\n}\nexports.extend = extend;\n\n// Common wrapper for all Unix-like commands\nfunction wrap(cmd, fn, options) {\n  return function() {\n    var retValue = null;\n\n    state.currentCmd = cmd;\n    state.error = null;\n\n    try {\n      var args = [].slice.call(arguments, 0);\n\n      if (options && options.notUnix) {\n        retValue = fn.apply(this, args);\n      } else {\n        if (args.length === 0 || typeof args[0] !== 'string' || args[0][0] !== '-')\n          args.unshift(''); // only add dummy option if '-option' not already present\n        retValue = fn.apply(this, args);\n      }\n    } catch (e) {\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        console.log('shell.js: internal error');\n        console.log(e.stack || e);\n        process.exit(1);\n      }\n      if (config.fatal)\n        throw e;\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\nexports.wrap = wrap;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/ls.js":"var path = require('path');\nvar fs = require('fs');\nvar common = require('./common');\nvar _cd = require('./cd');\nvar _pwd = require('./pwd');\n\n//@\n//@ ### ls([options ,] path [,path ...])\n//@ ### ls([options ,] path_array)\n//@ Available options:\n//@\n//@ + `-R`: recursive\n//@ + `-A`: all files (include files beginning with `.`, except for `.` and `..`)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ls('projs/*.js');\n//@ ls('-R', '/users/me', '/tmp');\n//@ ls('-R', ['/users/me', '/tmp']); // same as above\n//@ ```\n//@\n//@ Returns array of files in the given path, or in current directory if no path provided.\nfunction _ls(options, paths) {\n  options = common.parseOptions(options, {\n    'R': 'recursive',\n    'A': 'all',\n    'a': 'all_deprecated'\n  });\n\n  if (options.all_deprecated) {\n    // We won't support the -a option as it's hard to image why it's useful\n    // (it includes '.' and '..' in addition to '.*' files)\n    // For backwards compatibility we'll dump a deprecated message and proceed as before\n    common.log('ls: Option -a is deprecated. Use -A instead');\n    options.all = true;\n  }\n\n  if (!paths)\n    paths = ['.'];\n  else if (typeof paths === 'object')\n    paths = paths; // assume array\n  else if (typeof paths === 'string')\n    paths = [].slice.call(arguments, 1);\n\n  var list = [];\n\n  // Conditionally pushes file to list - returns true if pushed, false otherwise\n  // (e.g. prevents hidden files to be included unless explicitly told so)\n  function pushFile(file, query) {\n    // hidden file?\n    if (path.basename(file)[0] === '.') {\n      // not explicitly asking for hidden files?\n      if (!options.all && !(path.basename(query)[0] === '.' && path.basename(query).length > 1))\n        return false;\n    }\n\n    if (common.platform === 'win')\n      file = file.replace(/\\\\/g, '/');\n\n    list.push(file);\n    return true;\n  }\n\n  paths.forEach(function(p) {\n    if (fs.existsSync(p)) {\n      var stats = fs.statSync(p);\n      // Simple file?\n      if (stats.isFile()) {\n        pushFile(p, p);\n        return; // continue\n      }\n\n      // Simple dir?\n      if (stats.isDirectory()) {\n        // Iterate over p contents\n        fs.readdirSync(p).forEach(function(file) {\n          if (!pushFile(file, p))\n            return;\n\n          // Recursive?\n          if (options.recursive) {\n            var oldDir = _pwd();\n            _cd('', p);\n            if (fs.statSync(file).isDirectory())\n              list = list.concat(_ls('-R'+(options.all?'A':''), file+'/*'));\n            _cd('', oldDir);\n          }\n        });\n        return; // continue\n      }\n    }\n\n    // p does not exist - possible wildcard present\n\n    var basename = path.basename(p);\n    var dirname = path.dirname(p);\n    // Wildcard present on an existing dir? (e.g. '/tmp/*.js')\n    if (basename.search(/\\*/) > -1 && fs.existsSync(dirname) && fs.statSync(dirname).isDirectory) {\n      // Escape special regular expression chars\n      var regexp = basename.replace(/(\\^|\\$|\\(|\\)|<|>|\\[|\\]|\\{|\\}|\\.|\\+|\\?)/g, '\\\\$1');\n      // Translates wildcard into regex\n      regexp = '^' + regexp.replace(/\\*/g, '.*') + '$';\n      // Iterate over directory contents\n      fs.readdirSync(dirname).forEach(function(file) {\n        if (file.match(new RegExp(regexp))) {\n          if (!pushFile(path.normalize(dirname+'/'+file), basename))\n            return;\n\n          // Recursive?\n          if (options.recursive) {\n            var pp = dirname + '/' + file;\n            if (fs.lstatSync(pp).isDirectory())\n              list = list.concat(_ls('-R'+(options.all?'A':''), pp+'/*'));\n          } // recursive\n        } // if file matches\n      }); // forEach\n      return;\n    }\n\n    common.error('no such file or directory: ' + p, true);\n  });\n\n  return list;\n}\nmodule.exports = _ls;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/cd.js":"var fs = require('fs');\nvar common = require('./common');\n\n//@\n//@ ### cd('dir')\n//@ Changes to directory `dir` for the duration of the script\nfunction _cd(options, dir) {\n  if (!dir)\n    common.error('directory not specified');\n\n  if (!fs.existsSync(dir))\n    common.error('no such file or directory: ' + dir);\n\n  if (!fs.statSync(dir).isDirectory())\n    common.error('not a directory: ' + dir);\n\n  process.chdir(dir);\n}\nmodule.exports = _cd;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/pwd.js":"var path = require('path');\nvar common = require('./common');\n\n//@\n//@ ### pwd()\n//@ Returns the current directory.\nfunction _pwd(options) {\n  var pwd = path.resolve(process.cwd());\n  return common.ShellString(pwd);\n}\nmodule.exports = _pwd;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/find.js":"var fs = require('fs');\nvar common = require('./common');\nvar _ls = require('./ls');\n\n//@\n//@ ### find(path [,path ...])\n//@ ### find(path_array)\n//@ Examples:\n//@\n//@ ```javascript\n//@ find('src', 'lib');\n//@ find(['src', 'lib']); // same as above\n//@ find('.').filter(function(file) { return file.match(/\\.js$/); });\n//@ ```\n//@\n//@ Returns array of all files (however deep) in the given paths.\n//@\n//@ The main difference from `ls('-R', path)` is that the resulting file names\n//@ include the base directories, e.g. `lib/resources/file1` instead of just `file1`.\nfunction _find(options, paths) {\n  if (!paths)\n    common.error('no path specified');\n  else if (typeof paths === 'object')\n    paths = paths; // assume array\n  else if (typeof paths === 'string')\n    paths = [].slice.call(arguments, 1);\n\n  var list = [];\n\n  function pushFile(file) {\n    if (common.platform === 'win')\n      file = file.replace(/\\\\/g, '/');\n    list.push(file);\n  }\n\n  // why not simply do ls('-R', paths)? because the output wouldn't give the base dirs\n  // to get the base dir in the output, we need instead ls('-R', 'dir/*') for every directory\n\n  paths.forEach(function(file) {\n    pushFile(file);\n\n    if (fs.statSync(file).isDirectory()) {\n      _ls('-RA', file+'/*').forEach(function(subfile) {\n        pushFile(subfile);\n      });\n    }\n  });\n\n  return list;\n}\nmodule.exports = _find;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/cp.js":"var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar os = require('os');\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile) {\n  if (!fs.existsSync(srcFile))\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n\n  var BUF_LENGTH = 64*1024,\n      buf = new Buffer(BUF_LENGTH),\n      bytesRead = BUF_LENGTH,\n      pos = 0,\n      fdr = null,\n      fdw = null;\n\n  try {\n    fdr = fs.openSync(srcFile, 'r');\n  } catch(e) {\n    common.error('copyFileSync: could not read src file ('+srcFile+')');\n  }\n\n  try {\n    fdw = fs.openSync(destFile, 'w');\n  } catch(e) {\n    common.error('copyFileSync: could not write to dest file (code='+e.code+'):'+destFile);\n  }\n\n  while (bytesRead === BUF_LENGTH) {\n    bytesRead = fs.readSync(fdr, buf, 0, BUF_LENGTH, pos);\n    fs.writeSync(fdw, buf, 0, bytesRead);\n    pos += bytesRead;\n  }\n\n  fs.closeSync(fdr);\n  fs.closeSync(fdw);\n\n  fs.chmodSync(destFile, fs.statSync(srcFile).mode);\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, opts) {\n  if (!opts) opts = {};\n\n  /* Create the directory where all our junk is moving to; read the mode of the source directory and mirror it */\n  var checkDir = fs.statSync(sourceDir);\n  try {\n    fs.mkdirSync(destDir, checkDir.mode);\n  } catch (e) {\n    //if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + \"/\" + files[i];\n    var destFile = destDir + \"/\" + files[i];\n    var srcFileStat = fs.lstatSync(srcFile);\n\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, opts);\n    } else if (srcFileStat.isSymbolicLink()) {\n      var symlinkFull = fs.readlinkSync(srcFile);\n      fs.symlinkSync(symlinkFull, destFile, os.platform() === \"win32\" ? \"junction\" : null);\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && !opts.force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile);\n      }\n    }\n\n  } // for files\n} // cpdirSyncRecursive\n\n\n//@\n//@ ### cp([options ,] source [,source ...], dest)\n//@ ### cp([options ,] source_array, dest)\n//@ Available options:\n//@\n//@ + `-f`: force\n//@ + `-r, -R`: recursive\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files. The wildcard `*` is accepted.\nfunction _cp(options, sources, dest) {\n  options = common.parseOptions(options, {\n    'f': 'force',\n    'R': 'recursive',\n    'r': 'recursive'\n  });\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else if ('length' in sources) {\n    sources = sources; // no-op for array\n  } else {\n    common.error('invalid arguments');\n  }\n\n  var exists = fs.existsSync(dest),\n      stats = exists && fs.statSync(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1)\n    common.error('dest is not a directory (too many sources)');\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && !options.force)\n    common.error('dest file already exists: ' + dest);\n\n  if (options.recursive) {\n    // Recursive allows the shortcut syntax \"sourcedir/\" for \"sourcedir/*\"\n    // (see Github issue #15)\n    sources.forEach(function(src, i) {\n      if (src[src.length - 1] === '/')\n        sources[i] += '*';\n    });\n\n    // Create dest\n    try {\n      fs.mkdirSync(dest, parseInt('0777', 8));\n    } catch (e) {\n      // like Unix's cp, keep going even if we can't create dest dir\n    }\n  }\n\n  sources = common.expand(sources);\n\n  sources.forEach(function(src) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: '+src, true);\n      return; // skip file\n    }\n\n    // If here, src exists\n    if (fs.statSync(src).isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.log(src + ' is a directory (not copied)');\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = path.join(dest, path.basename(src)),\n            checkDir = fs.statSync(src);\n        try {\n          fs.mkdirSync(newDest, checkDir.mode);\n        } catch (e) {\n          //if the directory already exists, that's okay\n          if (e.code !== 'EEXIST') {\n            common.error('dest file no such file or directory: ' + newDest, true);\n            throw e;\n          }\n        }\n\n        cpdirSyncRecursive(src, newDest, {force: options.force});\n      }\n      return; // done with dir\n    }\n\n    // If here, src is a file\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && fs.statSync(dest).isDirectory())\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n\n    if (fs.existsSync(thisDest) && !options.force) {\n      common.error('dest file already exists: ' + thisDest, true);\n      return; // skip file\n    }\n\n    copyFileSync(src, thisDest);\n  }); // forEach(src)\n}\nmodule.exports = _cp;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/rm.js":"var common = require('./common');\nvar fs = require('fs');\n\n// Recursively removes 'dir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction rmdirSyncRecursive(dir, force) {\n  var files;\n\n  files = fs.readdirSync(dir);\n\n  // Loop through and delete everything in the sub-tree after checking it\n  for(var i = 0; i < files.length; i++) {\n    var file = dir + \"/\" + files[i],\n        currFile = fs.lstatSync(file);\n\n    if(currFile.isDirectory()) { // Recursive function back to the beginning\n      rmdirSyncRecursive(file, force);\n    }\n\n    else if(currFile.isSymbolicLink()) { // Unlink symlinks\n      if (force || isWriteable(file)) {\n        try {\n          common.unlinkSync(file);\n        } catch (e) {\n          common.error('could not remove file (code '+e.code+'): ' + file, true);\n        }\n      }\n    }\n\n    else // Assume it's a file - perhaps a try/catch belongs here?\n      if (force || isWriteable(file)) {\n        try {\n          common.unlinkSync(file);\n        } catch (e) {\n          common.error('could not remove file (code '+e.code+'): ' + file, true);\n        }\n      }\n  }\n\n  // Now that we know everything in the sub-tree has been deleted, we can delete the main directory.\n  // Huzzah for the shopkeep.\n\n  var result;\n  try {\n    // Retry on windows, sometimes it takes a little time before all the files in the directory are gone\n    var start = Date.now();\n    while (true) {\n      try {\n        result = fs.rmdirSync(dir);\n        if (fs.existsSync(dir)) throw { code: \"EAGAIN\" }\n        break;\n      } catch(er) {\n        // In addition to error codes, also check if the directory still exists and loop again if true\n        if (process.platform === \"win32\" && (er.code === \"ENOTEMPTY\" || er.code === \"EBUSY\" || er.code === \"EPERM\" || er.code === \"EAGAIN\")) {\n          if (Date.now() - start > 1000) throw er;\n        } else if (er.code === \"ENOENT\") {\n          // Directory did not exist, deletion was successful\n          break;\n        } else {\n          throw er;\n        }\n      }\n    }\n  } catch(e) {\n    common.error('could not remove directory (code '+e.code+'): ' + dir, true);\n  }\n\n  return result;\n} // rmdirSyncRecursive\n\n// Hack to determine if file has write permissions for current user\n// Avoids having to check user, group, etc, but it's probably slow\nfunction isWriteable(file) {\n  var writePermission = true;\n  try {\n    var __fd = fs.openSync(file, 'a');\n    fs.closeSync(__fd);\n  } catch(e) {\n    writePermission = false;\n  }\n\n  return writePermission;\n}\n\n//@\n//@ ### rm([options ,] file [, file ...])\n//@ ### rm([options ,] file_array)\n//@ Available options:\n//@\n//@ + `-f`: force\n//@ + `-r, -R`: recursive\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ rm('-rf', '/tmp/*');\n//@ rm('some_file.txt', 'another_file.txt');\n//@ rm(['some_file.txt', 'another_file.txt']); // same as above\n//@ ```\n//@\n//@ Removes files. The wildcard `*` is accepted.\nfunction _rm(options, files) {\n  options = common.parseOptions(options, {\n    'f': 'force',\n    'r': 'recursive',\n    'R': 'recursive'\n  });\n  if (!files)\n    common.error('no paths given');\n\n  if (typeof files === 'string')\n    files = [].slice.call(arguments, 1);\n  // if it's array leave it as it is\n\n  files = common.expand(files);\n\n  files.forEach(function(file) {\n    if (!fs.existsSync(file)) {\n      // Path does not exist, no force flag given\n      if (!options.force)\n        common.error('no such file or directory: '+file, true);\n\n      return; // skip file\n    }\n\n    // If here, path exists\n\n    var stats = fs.lstatSync(file);\n    if (stats.isFile() || stats.isSymbolicLink()) {\n\n      // Do not check for file writing permissions\n      if (options.force) {\n        common.unlinkSync(file);\n        return;\n      }\n\n      if (isWriteable(file))\n        common.unlinkSync(file);\n      else\n        common.error('permission denied: '+file, true);\n\n      return;\n    } // simple file\n\n    // Path is an existing directory, but no -r flag given\n    if (stats.isDirectory() && !options.recursive) {\n      common.error('path is a directory', true);\n      return; // skip path\n    }\n\n    // Recursively remove existing directory\n    if (stats.isDirectory() && options.recursive) {\n      rmdirSyncRecursive(file, options.force);\n    }\n  }); // forEach(file)\n} // rm\nmodule.exports = _rm;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/mv.js":"var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\n\n//@\n//@ ### mv(source [, source ...], dest')\n//@ ### mv(source_array, dest')\n//@ Available options:\n//@\n//@ + `f`: force\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-f', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves files. The wildcard `*` is accepted.\nfunction _mv(options, sources, dest) {\n  options = common.parseOptions(options, {\n    'f': 'force'\n  });\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else if ('length' in sources) {\n    sources = sources; // no-op for array\n  } else {\n    common.error('invalid arguments');\n  }\n\n  sources = common.expand(sources);\n\n  var exists = fs.existsSync(dest),\n      stats = exists && fs.statSync(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1)\n    common.error('dest is not a directory (too many sources)');\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && !options.force)\n    common.error('dest file already exists: ' + dest);\n\n  sources.forEach(function(src) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: '+src, true);\n      return; // skip file\n    }\n\n    // If here, src exists\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && fs.statSync(dest).isDirectory())\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n\n    if (fs.existsSync(thisDest) && !options.force) {\n      common.error('dest file already exists: ' + thisDest, true);\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: '+src, true);\n      return; // skip file\n    }\n\n    fs.renameSync(src, thisDest);\n  }); // forEach(src)\n} // mv\nmodule.exports = _mv;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/mkdir.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\n// Recursively creates 'dir'\nfunction mkdirSyncRecursive(dir) {\n  var baseDir = path.dirname(dir);\n\n  // Base dir exists, no recursion necessary\n  if (fs.existsSync(baseDir)) {\n    fs.mkdirSync(dir, parseInt('0777', 8));\n    return;\n  }\n\n  // Base dir does not exist, go recursive\n  mkdirSyncRecursive(baseDir);\n\n  // Base dir created, can create dir\n  fs.mkdirSync(dir, parseInt('0777', 8));\n}\n\n//@\n//@ ### mkdir([options ,] dir [, dir ...])\n//@ ### mkdir([options ,] dir_array)\n//@ Available options:\n//@\n//@ + `p`: full path (will create intermediate dirs if necessary)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mkdir('-p', '/tmp/a/b/c/d', '/tmp/e/f/g');\n//@ mkdir('-p', ['/tmp/a/b/c/d', '/tmp/e/f/g']); // same as above\n//@ ```\n//@\n//@ Creates directories.\nfunction _mkdir(options, dirs) {\n  options = common.parseOptions(options, {\n    'p': 'fullpath'\n  });\n  if (!dirs)\n    common.error('no paths given');\n\n  if (typeof dirs === 'string')\n    dirs = [].slice.call(arguments, 1);\n  // if it's array leave it as it is\n\n  dirs.forEach(function(dir) {\n    if (fs.existsSync(dir)) {\n      if (!options.fullpath)\n          common.error('path already exists: ' + dir, true);\n      return; // skip dir\n    }\n\n    // Base dir does not exist, and no -p option given\n    var baseDir = path.dirname(dir);\n    if (!fs.existsSync(baseDir) && !options.fullpath) {\n      common.error('no such file or directory: ' + baseDir, true);\n      return; // skip dir\n    }\n\n    if (options.fullpath)\n      mkdirSyncRecursive(dir);\n    else\n      fs.mkdirSync(dir, parseInt('0777', 8));\n  });\n} // mkdir\nmodule.exports = _mkdir;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/test.js":"var common = require('./common');\nvar fs = require('fs');\n\n//@\n//@ ### test(expression)\n//@ Available expression primaries:\n//@\n//@ + `'-b', 'path'`: true if path is a block device\n//@ + `'-c', 'path'`: true if path is a character device\n//@ + `'-d', 'path'`: true if path is a directory\n//@ + `'-e', 'path'`: true if path exists\n//@ + `'-f', 'path'`: true if path is a regular file\n//@ + `'-L', 'path'`: true if path is a symboilc link\n//@ + `'-p', 'path'`: true if path is a pipe (FIFO)\n//@ + `'-S', 'path'`: true if path is a socket\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ if (test('-d', path)) { /* do something with dir */ };\n//@ if (!test('-f', path)) continue; // skip if it's a regular file\n//@ ```\n//@\n//@ Evaluates expression using the available primaries and returns corresponding value.\nfunction _test(options, path) {\n  if (!path)\n    common.error('no path given');\n\n  // hack - only works with unary primaries\n  options = common.parseOptions(options, {\n    'b': 'block',\n    'c': 'character',\n    'd': 'directory',\n    'e': 'exists',\n    'f': 'file',\n    'L': 'link',\n    'p': 'pipe',\n    'S': 'socket'\n  });\n\n  var canInterpret = false;\n  for (var key in options)\n    if (options[key] === true) {\n      canInterpret = true;\n      break;\n    }\n\n  if (!canInterpret)\n    common.error('could not interpret expression');\n\n  if (options.link) {\n    try {\n      return fs.lstatSync(path).isSymbolicLink();\n    } catch(e) {\n      return false;\n    }\n  }\n\n  if (!fs.existsSync(path))\n    return false;\n\n  if (options.exists)\n    return true;\n\n  var stats = fs.statSync(path);\n\n  if (options.block)\n    return stats.isBlockDevice();\n\n  if (options.character)\n    return stats.isCharacterDevice();\n\n  if (options.directory)\n    return stats.isDirectory();\n\n  if (options.file)\n    return stats.isFile();\n\n  if (options.pipe)\n    return stats.isFIFO();\n\n  if (options.socket)\n    return stats.isSocket();\n} // test\nmodule.exports = _test;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/cat.js":"var common = require('./common');\nvar fs = require('fs');\n\n//@\n//@ ### cat(file [, file ...])\n//@ ### cat(file_array)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var str = cat('file*.txt');\n//@ var str = cat('file1', 'file2');\n//@ var str = cat(['file1', 'file2']); // same as above\n//@ ```\n//@\n//@ Returns a string containing the given file, or a concatenated string\n//@ containing the files if more than one file is given (a new line character is\n//@ introduced between each file). Wildcard `*` accepted.\nfunction _cat(options, files) {\n  var cat = '';\n\n  if (!files)\n    common.error('no paths given');\n\n  if (typeof files === 'string')\n    files = [].slice.call(arguments, 1);\n  // if it's array leave it as it is\n\n  files = common.expand(files);\n\n  files.forEach(function(file) {\n    if (!fs.existsSync(file))\n      common.error('no such file or directory: ' + file);\n\n    cat += fs.readFileSync(file, 'utf8') + '\\n';\n  });\n\n  if (cat[cat.length-1] === '\\n')\n    cat = cat.substring(0, cat.length-1);\n\n  return common.ShellString(cat);\n}\nmodule.exports = _cat;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/to.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\n//@\n//@ ### 'string'.to(file)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cat('input.txt').to('output.txt');\n//@ ```\n//@\n//@ Analogous to the redirection operator `>` in Unix, but works with JavaScript strings (such as\n//@ those returned by `cat`, `grep`, etc). _Like Unix redirections, `to()` will overwrite any existing file!_\nfunction _to(options, file) {\n  if (!file)\n    common.error('wrong arguments');\n\n  if (!fs.existsSync( path.dirname(file) ))\n      common.error('no such file or directory: ' + path.dirname(file));\n\n  try {\n    fs.writeFileSync(file, this.toString(), 'utf8');\n  } catch(e) {\n    common.error('could not write to file (code '+e.code+'): '+file, true);\n  }\n}\nmodule.exports = _to;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/toEnd.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\n//@\n//@ ### 'string'.toEnd(file)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cat('input.txt').toEnd('output.txt');\n//@ ```\n//@\n//@ Analogous to the redirect-and-append operator `>>` in Unix, but works with JavaScript strings (such as\n//@ those returned by `cat`, `grep`, etc).\nfunction _toEnd(options, file) {\n  if (!file)\n    common.error('wrong arguments');\n\n  if (!fs.existsSync( path.dirname(file) ))\n      common.error('no such file or directory: ' + path.dirname(file));\n\n  try {\n    fs.appendFileSync(file, this.toString(), 'utf8');\n  } catch(e) {\n    common.error('could not append to file (code '+e.code+'): '+file, true);\n  }\n}\nmodule.exports = _toEnd;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/sed.js":"var common = require('./common');\nvar fs = require('fs');\n\n//@\n//@ ### sed([options ,] search_regex, replacement, file)\n//@ Available options:\n//@\n//@ + `-i`: Replace contents of 'file' in-place. _Note that no backups will be created!_\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ sed('-i', 'PROGRAM_VERSION', 'v0.1.3', 'source.js');\n//@ sed(/.*DELETE_THIS_LINE.*\\n/, '', 'source.js');\n//@ ```\n//@\n//@ Reads an input string from `file` and performs a JavaScript `replace()` on the input\n//@ using the given search regex and replacement string or function. Returns the new string after replacement.\nfunction _sed(options, regex, replacement, file) {\n  options = common.parseOptions(options, {\n    'i': 'inplace'\n  });\n\n  if (typeof replacement === 'string' || typeof replacement === 'function')\n    replacement = replacement; // no-op\n  else if (typeof replacement === 'number')\n    replacement = replacement.toString(); // fallback\n  else\n    common.error('invalid replacement string');\n\n  if (!file)\n    common.error('no file given');\n\n  if (!fs.existsSync(file))\n    common.error('no such file or directory: ' + file);\n\n  var result = fs.readFileSync(file, 'utf8').replace(regex, replacement);\n  if (options.inplace)\n    fs.writeFileSync(file, result, 'utf8');\n\n  return common.ShellString(result);\n}\nmodule.exports = _sed;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/grep.js":"var common = require('./common');\nvar fs = require('fs');\n\n//@\n//@ ### grep([options ,] regex_filter, file [, file ...])\n//@ ### grep([options ,] regex_filter, file_array)\n//@ Available options:\n//@\n//@ + `-v`: Inverse the sense of the regex and print the lines not matching the criteria.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ grep('-v', 'GLOBAL_VARIABLE', '*.js');\n//@ grep('GLOBAL_VARIABLE', '*.js');\n//@ ```\n//@\n//@ Reads input string from given files and returns a string containing all lines of the\n//@ file that match the given `regex_filter`. Wildcard `*` accepted.\nfunction _grep(options, regex, files) {\n  options = common.parseOptions(options, {\n    'v': 'inverse'\n  });\n\n  if (!files)\n    common.error('no paths given');\n\n  if (typeof files === 'string')\n    files = [].slice.call(arguments, 2);\n  // if it's array leave it as it is\n\n  files = common.expand(files);\n\n  var grep = '';\n  files.forEach(function(file) {\n    if (!fs.existsSync(file)) {\n      common.error('no such file or directory: ' + file, true);\n      return;\n    }\n\n    var contents = fs.readFileSync(file, 'utf8'),\n        lines = contents.split(/\\r*\\n/);\n    lines.forEach(function(line) {\n      var matched = line.match(regex);\n      if ((options.inverse && !matched) || (!options.inverse && matched))\n        grep += line + '\\n';\n    });\n  });\n\n  return common.ShellString(grep);\n}\nmodule.exports = _grep;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/which.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\n// Cross-platform method for splitting environment PATH variables\nfunction splitPath(p) {\n  for (i=1;i<2;i++) {}\n\n  if (!p)\n    return [];\n\n  if (common.platform === 'win')\n    return p.split(';');\n  else\n    return p.split(':');\n}\n\nfunction checkPath(path) {\n  return fs.existsSync(path) && fs.statSync(path).isDirectory() == false;\n}\n\n//@\n//@ ### which(command)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var nodeExec = which('node');\n//@ ```\n//@\n//@ Searches for `command` in the system's PATH. On Windows looks for `.exe`, `.cmd`, and `.bat` extensions.\n//@ Returns string containing the absolute path to the command.\nfunction _which(options, cmd) {\n  if (!cmd)\n    common.error('must specify command');\n\n  var pathEnv = process.env.path || process.env.Path || process.env.PATH,\n      pathArray = splitPath(pathEnv),\n      where = null;\n\n  // No relative/absolute paths provided?\n  if (cmd.search(/\\//) === -1) {\n    // Search for command in PATH\n    pathArray.forEach(function(dir) {\n      if (where)\n        return; // already found it\n\n      var attempt = path.resolve(dir + '/' + cmd);\n      if (checkPath(attempt)) {\n        where = attempt;\n        return;\n      }\n\n      if (common.platform === 'win') {\n        var baseAttempt = attempt;\n        attempt = baseAttempt + '.exe';\n        if (checkPath(attempt)) {\n          where = attempt;\n          return;\n        }\n        attempt = baseAttempt + '.cmd';\n        if (checkPath(attempt)) {\n          where = attempt;\n          return;\n        }\n        attempt = baseAttempt + '.bat';\n        if (checkPath(attempt)) {\n          where = attempt;\n          return;\n        }\n      } // if 'win'\n    });\n  }\n\n  // Command not found anywhere?\n  if (!checkPath(cmd) && !where)\n    return null;\n\n  where = where || path.resolve(cmd);\n\n  return common.ShellString(where);\n}\nmodule.exports = _which;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/echo.js":"var common = require('./common');\n\n//@\n//@ ### echo(string [,string ...])\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo('hello world');\n//@ var str = echo('hello world');\n//@ ```\n//@\n//@ Prints string to stdout, and returns string with additional utility methods\n//@ like `.to()`.\nfunction _echo() {\n  var messages = [].slice.call(arguments, 0);\n  console.log.apply(this, messages);\n  return common.ShellString(messages.join(' '));\n}\nmodule.exports = _echo;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/dirs.js":"var common = require('./common');\nvar _cd = require('./cd');\nvar path = require('path');\n\n// Pushd/popd/dirs internals\nvar _dirStack = [];\n\nfunction _isStackIndex(index) {\n  return (/^[\\-+]\\d+$/).test(index);\n}\n\nfunction _parseStackIndex(index) {\n  if (_isStackIndex(index)) {\n    if (Math.abs(index) < _dirStack.length + 1) { // +1 for pwd\n      return (/^-/).test(index) ? Number(index) - 1 : Number(index);\n    } else {\n      common.error(index + ': directory stack index out of range');\n    }\n  } else {\n    common.error(index + ': invalid number');\n  }\n}\n\nfunction _actualDirStack() {\n  return [process.cwd()].concat(_dirStack);\n}\n\n//@\n//@ ### pushd([options,] [dir | '-N' | '+N'])\n//@\n//@ Available options:\n//@\n//@ + `-n`: Suppresses the normal change of directory when adding directories to the stack, so that only the stack is manipulated.\n//@\n//@ Arguments:\n//@\n//@ + `dir`: Makes the current working directory be the top of the stack, and then executes the equivalent of `cd dir`.\n//@ + `+N`: Brings the Nth directory (counting from the left of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.\n//@ + `-N`: Brings the Nth directory (counting from the right of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ // process.cwd() === '/usr'\n//@ pushd('/etc'); // Returns /etc /usr\n//@ pushd('+1');   // Returns /usr /etc\n//@ ```\n//@\n//@ Save the current directory on the top of the directory stack and then cd to `dir`. With no arguments, pushd exchanges the top two directories. Returns an array of paths in the stack.\nfunction _pushd(options, dir) {\n  if (_isStackIndex(options)) {\n    dir = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'n' : 'no-cd'\n  });\n\n  var dirs = _actualDirStack();\n\n  if (dir === '+0') {\n    return dirs; // +0 is a noop\n  } else if (!dir) {\n    if (dirs.length > 1) {\n      dirs = dirs.splice(1, 1).concat(dirs);\n    } else {\n      return common.error('no other directory');\n    }\n  } else if (_isStackIndex(dir)) {\n    var n = _parseStackIndex(dir);\n    dirs = dirs.slice(n).concat(dirs.slice(0, n));\n  } else {\n    if (options['no-cd']) {\n      dirs.splice(1, 0, dir);\n    } else {\n      dirs.unshift(dir);\n    }\n  }\n\n  if (options['no-cd']) {\n    dirs = dirs.slice(1);\n  } else {\n    dir = path.resolve(dirs.shift());\n    _cd('', dir);\n  }\n\n  _dirStack = dirs;\n  return _dirs('');\n}\nexports.pushd = _pushd;\n\n//@\n//@ ### popd([options,] ['-N' | '+N'])\n//@\n//@ Available options:\n//@\n//@ + `-n`: Suppresses the normal change of directory when removing directories from the stack, so that only the stack is manipulated.\n//@\n//@ Arguments:\n//@\n//@ + `+N`: Removes the Nth directory (counting from the left of the list printed by dirs), starting with zero.\n//@ + `-N`: Removes the Nth directory (counting from the right of the list printed by dirs), starting with zero.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo(process.cwd()); // '/usr'\n//@ pushd('/etc');       // '/etc /usr'\n//@ echo(process.cwd()); // '/etc'\n//@ popd();              // '/usr'\n//@ echo(process.cwd()); // '/usr'\n//@ ```\n//@\n//@ When no arguments are given, popd removes the top directory from the stack and performs a cd to the new top directory. The elements are numbered from 0 starting at the first directory listed with dirs; i.e., popd is equivalent to popd +0. Returns an array of paths in the stack.\nfunction _popd(options, index) {\n  if (_isStackIndex(options)) {\n    index = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'n' : 'no-cd'\n  });\n\n  if (!_dirStack.length) {\n    return common.error('directory stack empty');\n  }\n\n  index = _parseStackIndex(index || '+0');\n\n  if (options['no-cd'] || index > 0 || _dirStack.length + index === 0) {\n    index = index > 0 ? index - 1 : index;\n    _dirStack.splice(index, 1);\n  } else {\n    var dir = path.resolve(_dirStack.shift());\n    _cd('', dir);\n  }\n\n  return _dirs('');\n}\nexports.popd = _popd;\n\n//@\n//@ ### dirs([options | '+N' | '-N'])\n//@\n//@ Available options:\n//@\n//@ + `-c`: Clears the directory stack by deleting all of the elements.\n//@\n//@ Arguments:\n//@\n//@ + `+N`: Displays the Nth directory (counting from the left of the list printed by dirs when invoked without options), starting with zero.\n//@ + `-N`: Displays the Nth directory (counting from the right of the list printed by dirs when invoked without options), starting with zero.\n//@\n//@ Display the list of currently remembered directories. Returns an array of paths in the stack, or a single path if +N or -N was specified.\n//@\n//@ See also: pushd, popd\nfunction _dirs(options, index) {\n  if (_isStackIndex(options)) {\n    index = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'c' : 'clear'\n  });\n\n  if (options['clear']) {\n    _dirStack = [];\n    return _dirStack;\n  }\n\n  var stack = _actualDirStack();\n\n  if (index) {\n    index = _parseStackIndex(index);\n\n    if (index < 0) {\n      index = stack.length + index;\n    }\n\n    common.log(stack[index]);\n    return stack[index];\n  }\n\n  common.log(stack.join(' '));\n\n  return stack;\n}\nexports.dirs = _dirs;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/ln.js":"var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar os = require('os');\n\n//@\n//@ ### ln(options, source, dest)\n//@ ### ln(source, dest)\n//@ Available options:\n//@\n//@ + `s`: symlink\n//@ + `f`: force\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ln('file', 'newlink');\n//@ ln('-sf', 'file', 'existing');\n//@ ```\n//@\n//@ Links source to dest. Use -f to force the link, should dest already exist.\nfunction _ln(options, source, dest) {\n  options = common.parseOptions(options, {\n    's': 'symlink',\n    'f': 'force'\n  });\n\n  if (!source || !dest) {\n    common.error('Missing <source> and/or <dest>');\n  }\n\n  source = path.resolve(process.cwd(), String(source));\n  dest = path.resolve(process.cwd(), String(dest));\n\n  if (!fs.existsSync(source)) {\n    common.error('Source file does not exist', true);\n  }\n\n  if (fs.existsSync(dest)) {\n    if (!options.force) {\n      common.error('Destination file exists', true);\n    }\n\n    fs.unlinkSync(dest);\n  }\n\n  if (options.symlink) {\n    fs.symlinkSync(source, dest, os.platform() === \"win32\" ? \"junction\" : null);\n  } else {\n    fs.linkSync(source, dest, os.platform() === \"win32\" ? \"junction\" : null);\n  }\n}\nmodule.exports = _ln;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/exec.js":"var common = require('./common');\nvar _tempDir = require('./tempdir');\nvar _pwd = require('./pwd');\nvar path = require('path');\nvar fs = require('fs');\nvar child = require('child_process');\n\n// Hack to run child_process.exec() synchronously (sync avoids callback hell)\n// Uses a custom wait loop that checks for a flag file, created when the child process is done.\n// (Can't do a wait loop that checks for internal Node variables/messages as\n// Node is single-threaded; callbacks and other internal state changes are done in the\n// event loop).\nfunction execSync(cmd, opts) {\n  var tempDir = _tempDir();\n  var stdoutFile = path.resolve(tempDir+'/'+common.randomFileName()),\n      codeFile = path.resolve(tempDir+'/'+common.randomFileName()),\n      scriptFile = path.resolve(tempDir+'/'+common.randomFileName()),\n      sleepFile = path.resolve(tempDir+'/'+common.randomFileName());\n\n  var options = common.extend({\n    silent: common.config.silent\n  }, opts);\n\n  var previousStdoutContent = '';\n  // Echoes stdout changes from running process, if not silent\n  function updateStdout() {\n    if (options.silent || !fs.existsSync(stdoutFile))\n      return;\n\n    var stdoutContent = fs.readFileSync(stdoutFile, 'utf8');\n    // No changes since last time?\n    if (stdoutContent.length <= previousStdoutContent.length)\n      return;\n\n    process.stdout.write(stdoutContent.substr(previousStdoutContent.length));\n    previousStdoutContent = stdoutContent;\n  }\n\n  function escape(str) {\n    return (str+'').replace(/([\\\\\"'])/g, \"\\\\$1\").replace(/\\0/g, \"\\\\0\");\n  }\n\n  if (fs.existsSync(scriptFile)) common.unlinkSync(scriptFile);\n  if (fs.existsSync(stdoutFile)) common.unlinkSync(stdoutFile);\n  if (fs.existsSync(codeFile)) common.unlinkSync(codeFile);\n\n  var execCommand = '\"'+process.execPath+'\" '+scriptFile;\n  var execOptions = {\n    env: process.env,\n    cwd: _pwd(),\n    maxBuffer: 20*1024*1024\n  };\n\n  if (typeof child.execSync === 'function') {\n    var script = [\n      \"var child = require('child_process')\",\n      \"  , fs = require('fs');\",\n      \"var childProcess = child.exec('\"+escape(cmd)+\"', {env: process.env, maxBuffer: 20*1024*1024}, function(err) {\",\n      \"  fs.writeFileSync('\"+escape(codeFile)+\"', err ? err.code.toString() : '0');\",\n      \"});\",\n      \"var stdoutStream = fs.createWriteStream('\"+escape(stdoutFile)+\"');\",\n      \"childProcess.stdout.pipe(stdoutStream, {end: false});\",\n      \"childProcess.stderr.pipe(stdoutStream, {end: false});\",\n      \"childProcess.stdout.pipe(process.stdout);\",\n      \"childProcess.stderr.pipe(process.stderr);\",\n      \"var stdoutEnded = false, stderrEnded = false;\",\n      \"function tryClosing(){ if(stdoutEnded && stderrEnded){ stdoutStream.end(); } }\",\n      \"childProcess.stdout.on('end', function(){ stdoutEnded = true; tryClosing(); });\",\n      \"childProcess.stderr.on('end', function(){ stderrEnded = true; tryClosing(); });\"\n    ].join('\\n');\n\n    fs.writeFileSync(scriptFile, script);\n\n    if (options.silent) {\n      execOptions.stdio = 'ignore';\n    } else {\n      execOptions.stdio = [0, 1, 2];\n    }\n\n    // Welcome to the future\n    child.execSync(execCommand, execOptions);\n  } else {\n    cmd += ' > '+stdoutFile+' 2>&1'; // works on both win/unix\n\n    var script = [\n      \"var child = require('child_process')\",\n      \"  , fs = require('fs');\",\n      \"var childProcess = child.exec('\"+escape(cmd)+\"', {env: process.env, maxBuffer: 20*1024*1024}, function(err) {\",\n      \"  fs.writeFileSync('\"+escape(codeFile)+\"', err ? err.code.toString() : '0');\",\n      \"});\"\n    ].join('\\n');\n\n    fs.writeFileSync(scriptFile, script);\n\n    child.exec(execCommand, execOptions);\n\n    // The wait loop\n    // sleepFile is used as a dummy I/O op to mitigate unnecessary CPU usage\n    // (tried many I/O sync ops, writeFileSync() seems to be only one that is effective in reducing\n    // CPU usage, though apparently not so much on Windows)\n    while (!fs.existsSync(codeFile)) { updateStdout(); fs.writeFileSync(sleepFile, 'a'); }\n    while (!fs.existsSync(stdoutFile)) { updateStdout(); fs.writeFileSync(sleepFile, 'a'); }\n  }\n\n  // At this point codeFile exists, but it's not necessarily flushed yet.\n  // Keep reading it until it is.\n  var code = parseInt('', 10);\n  while (isNaN(code)) {\n    code = parseInt(fs.readFileSync(codeFile, 'utf8'), 10);\n  }\n\n  var stdout = fs.readFileSync(stdoutFile, 'utf8');\n\n  // No biggie if we can't erase the files now -- they're in a temp dir anyway\n  try { common.unlinkSync(scriptFile); } catch(e) {}\n  try { common.unlinkSync(stdoutFile); } catch(e) {}\n  try { common.unlinkSync(codeFile); } catch(e) {}\n  try { common.unlinkSync(sleepFile); } catch(e) {}\n\n  // some shell return codes are defined as errors, per http://tldp.org/LDP/abs/html/exitcodes.html\n  if (code === 1 || code === 2 || code >= 126)  {\n      common.error('', true); // unix/shell doesn't really give an error message after non-zero exit codes\n  }\n  // True if successful, false if not\n  var obj = {\n    code: code,\n    output: stdout\n  };\n  return obj;\n} // execSync()\n\n// Wrapper around exec() to enable echoing output to console in real time\nfunction execAsync(cmd, opts, callback) {\n  var output = '';\n\n  var options = common.extend({\n    silent: common.config.silent\n  }, opts);\n\n  var c = child.exec(cmd, {env: process.env, maxBuffer: 20*1024*1024}, function(err) {\n    if (callback)\n      callback(err ? err.code : 0, output);\n  });\n\n  c.stdout.on('data', function(data) {\n    output += data;\n    if (!options.silent)\n      process.stdout.write(data);\n  });\n\n  c.stderr.on('data', function(data) {\n    output += data;\n    if (!options.silent)\n      process.stdout.write(data);\n  });\n\n  return c;\n}\n\n//@\n//@ ### exec(command [, options] [, callback])\n//@ Available options (all `false` by default):\n//@\n//@ + `async`: Asynchronous execution. Defaults to true if a callback is provided.\n//@ + `silent`: Do not echo program output to console.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var version = exec('node --version', {silent:true}).output;\n//@\n//@ var child = exec('some_long_running_process', {async:true});\n//@ child.stdout.on('data', function(data) {\n//@   /* ... do something with data ... */\n//@ });\n//@\n//@ exec('some_long_running_process', function(code, output) {\n//@   console.log('Exit code:', code);\n//@   console.log('Program output:', output);\n//@ });\n//@ ```\n//@\n//@ Executes the given `command` _synchronously_, unless otherwise specified.\n//@ When in synchronous mode returns the object `{ code:..., output:... }`, containing the program's\n//@ `output` (stdout + stderr)  and its exit `code`. Otherwise returns the child process object, and\n//@ the `callback` gets the arguments `(code, output)`.\n//@\n//@ **Note:** For long-lived processes, it's best to run `exec()` asynchronously as\n//@ the current synchronous implementation uses a lot of CPU. This should be getting\n//@ fixed soon.\nfunction _exec(command, options, callback) {\n  if (!command)\n    common.error('must specify command');\n\n  // Callback is defined instead of options.\n  if (typeof options === 'function') {\n    callback = options;\n    options = { async: true };\n  }\n\n  // Callback is defined with options.\n  if (typeof options === 'object' && typeof callback === 'function') {\n    options.async = true;\n  }\n\n  options = common.extend({\n    silent: common.config.silent,\n    async: false\n  }, options);\n\n  if (options.async)\n    return execAsync(command, options, callback);\n  else\n    return execSync(command, options);\n}\nmodule.exports = _exec;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/tempdir.js":"var common = require('./common');\nvar os = require('os');\nvar fs = require('fs');\n\n// Returns false if 'dir' is not a writeable directory, 'dir' otherwise\nfunction writeableDir(dir) {\n  if (!dir || !fs.existsSync(dir))\n    return false;\n\n  if (!fs.statSync(dir).isDirectory())\n    return false;\n\n  var testFile = dir+'/'+common.randomFileName();\n  try {\n    fs.writeFileSync(testFile, ' ');\n    common.unlinkSync(testFile);\n    return dir;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n//@\n//@ ### tempdir()\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var tmp = tempdir(); // \"/tmp\" for most *nix platforms\n//@ ```\n//@\n//@ Searches and returns string containing a writeable, platform-dependent temporary directory.\n//@ Follows Python's [tempfile algorithm](http://docs.python.org/library/tempfile.html#tempfile.tempdir).\nfunction _tempDir() {\n  var state = common.state;\n  if (state.tempDir)\n    return state.tempDir; // from cache\n\n  state.tempDir = writeableDir(os.tempDir && os.tempDir()) || // node 0.8+\n                  writeableDir(process.env['TMPDIR']) ||\n                  writeableDir(process.env['TEMP']) ||\n                  writeableDir(process.env['TMP']) ||\n                  writeableDir(process.env['Wimp$ScrapDir']) || // RiscOS\n                  writeableDir('C:\\\\TEMP') || // Windows\n                  writeableDir('C:\\\\TMP') || // Windows\n                  writeableDir('\\\\TEMP') || // Windows\n                  writeableDir('\\\\TMP') || // Windows\n                  writeableDir('/tmp') ||\n                  writeableDir('/var/tmp') ||\n                  writeableDir('/usr/tmp') ||\n                  writeableDir('.'); // last resort\n\n  return state.tempDir;\n}\nmodule.exports = _tempDir;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/chmod.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\nvar PERMS = (function (base) {\n  return {\n    OTHER_EXEC  : base.EXEC,\n    OTHER_WRITE : base.WRITE,\n    OTHER_READ  : base.READ,\n\n    GROUP_EXEC  : base.EXEC  << 3,\n    GROUP_WRITE : base.WRITE << 3,\n    GROUP_READ  : base.READ << 3,\n\n    OWNER_EXEC  : base.EXEC << 6,\n    OWNER_WRITE : base.WRITE << 6,\n    OWNER_READ  : base.READ << 6,\n\n    // Literal octal numbers are apparently not allowed in \"strict\" javascript.  Using parseInt is\n    // the preferred way, else a jshint warning is thrown.\n    STICKY      : parseInt('01000', 8),\n    SETGID      : parseInt('02000', 8),\n    SETUID      : parseInt('04000', 8),\n\n    TYPE_MASK   : parseInt('0770000', 8)\n  };\n})({\n  EXEC  : 1,\n  WRITE : 2,\n  READ  : 4\n});\n\n//@\n//@ ### chmod(octal_mode || octal_string, file)\n//@ ### chmod(symbolic_mode, file)\n//@\n//@ Available options:\n//@\n//@ + `-v`: output a diagnostic for every file processed//@\n//@ + `-c`: like verbose but report only when a change is made//@\n//@ + `-R`: change files and directories recursively//@\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ chmod(755, '/Users/brandon');\n//@ chmod('755', '/Users/brandon'); // same as above\n//@ chmod('u+x', '/Users/brandon');\n//@ ```\n//@\n//@ Alters the permissions of a file or directory by either specifying the\n//@ absolute permissions in octal form or expressing the changes in symbols.\n//@ This command tries to mimic the POSIX behavior as much as possible.\n//@ Notable exceptions:\n//@\n//@ + In symbolic modes, 'a-r' and '-r' are identical.  No consideration is\n//@   given to the umask.\n//@ + There is no \"quiet\" option since default behavior is to run silent.\nfunction _chmod(options, mode, filePattern) {\n  if (!filePattern) {\n    if (options.length > 0 && options.charAt(0) === '-') {\n      // Special case where the specified file permissions started with - to subtract perms, which\n      // get picked up by the option parser as command flags.\n      // If we are down by one argument and options starts with -, shift everything over.\n      filePattern = mode;\n      mode = options;\n      options = '';\n    }\n    else {\n      common.error('You must specify a file.');\n    }\n  }\n\n  options = common.parseOptions(options, {\n    'R': 'recursive',\n    'c': 'changes',\n    'v': 'verbose'\n  });\n\n  if (typeof filePattern === 'string') {\n    filePattern = [ filePattern ];\n  }\n\n  var files;\n\n  if (options.recursive) {\n    files = [];\n    common.expand(filePattern).forEach(function addFile(expandedFile) {\n      var stat = fs.lstatSync(expandedFile);\n\n      if (!stat.isSymbolicLink()) {\n        files.push(expandedFile);\n\n        if (stat.isDirectory()) {  // intentionally does not follow symlinks.\n          fs.readdirSync(expandedFile).forEach(function (child) {\n            addFile(expandedFile + '/' + child);\n          });\n        }\n      }\n    });\n  }\n  else {\n    files = common.expand(filePattern);\n  }\n\n  files.forEach(function innerChmod(file) {\n    file = path.resolve(file);\n    if (!fs.existsSync(file)) {\n      common.error('File not found: ' + file);\n    }\n\n    // When recursing, don't follow symlinks.\n    if (options.recursive && fs.lstatSync(file).isSymbolicLink()) {\n      return;\n    }\n\n    var perms = fs.statSync(file).mode;\n    var type = perms & PERMS.TYPE_MASK;\n\n    var newPerms = perms;\n\n    if (isNaN(parseInt(mode, 8))) {\n      // parse options\n      mode.split(',').forEach(function (symbolicMode) {\n        /*jshint regexdash:true */\n        var pattern = /([ugoa]*)([=\\+-])([rwxXst]*)/i;\n        var matches = pattern.exec(symbolicMode);\n\n        if (matches) {\n          var applyTo = matches[1];\n          var operator = matches[2];\n          var change = matches[3];\n\n          var changeOwner = applyTo.indexOf('u') != -1 || applyTo === 'a' || applyTo === '';\n          var changeGroup = applyTo.indexOf('g') != -1 || applyTo === 'a' || applyTo === '';\n          var changeOther = applyTo.indexOf('o') != -1 || applyTo === 'a' || applyTo === '';\n\n          var changeRead   = change.indexOf('r') != -1;\n          var changeWrite  = change.indexOf('w') != -1;\n          var changeExec   = change.indexOf('x') != -1;\n          var changeSticky = change.indexOf('t') != -1;\n          var changeSetuid = change.indexOf('s') != -1;\n\n          var mask = 0;\n          if (changeOwner) {\n            mask |= (changeRead ? PERMS.OWNER_READ : 0) + (changeWrite ? PERMS.OWNER_WRITE : 0) + (changeExec ? PERMS.OWNER_EXEC : 0) + (changeSetuid ? PERMS.SETUID : 0);\n          }\n          if (changeGroup) {\n            mask |= (changeRead ? PERMS.GROUP_READ : 0) + (changeWrite ? PERMS.GROUP_WRITE : 0) + (changeExec ? PERMS.GROUP_EXEC : 0) + (changeSetuid ? PERMS.SETGID : 0);\n          }\n          if (changeOther) {\n            mask |= (changeRead ? PERMS.OTHER_READ : 0) + (changeWrite ? PERMS.OTHER_WRITE : 0) + (changeExec ? PERMS.OTHER_EXEC : 0);\n          }\n\n          // Sticky bit is special - it's not tied to user, group or other.\n          if (changeSticky) {\n            mask |= PERMS.STICKY;\n          }\n\n          switch (operator) {\n            case '+':\n              newPerms |= mask;\n              break;\n\n            case '-':\n              newPerms &= ~mask;\n              break;\n\n            case '=':\n              newPerms = type + mask;\n\n              // According to POSIX, when using = to explicitly set the permissions, setuid and setgid can never be cleared.\n              if (fs.statSync(file).isDirectory()) {\n                newPerms |= (PERMS.SETUID + PERMS.SETGID) & perms;\n              }\n              break;\n          }\n\n          if (options.verbose) {\n            log(file + ' -> ' + newPerms.toString(8));\n          }\n\n          if (perms != newPerms) {\n            if (!options.verbose && options.changes) {\n              log(file + ' -> ' + newPerms.toString(8));\n            }\n            fs.chmodSync(file, newPerms);\n          }\n        }\n        else {\n          common.error('Invalid symbolic mode change: ' + symbolicMode);\n        }\n      });\n    }\n    else {\n      // they gave us a full number\n      newPerms = type + parseInt(mode, 8);\n\n      // POSIX rules are that setuid and setgid can only be added using numeric form, but not cleared.\n      if (fs.statSync(file).isDirectory()) {\n        newPerms |= (PERMS.SETUID + PERMS.SETGID) & perms;\n      }\n\n      fs.chmodSync(file, newPerms);\n    }\n  });\n}\nmodule.exports = _chmod;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/shelljs/src/error.js":"var common = require('./common');\n\n//@\n//@ ### error()\n//@ Tests if error occurred in the last command. Returns `null` if no error occurred,\n//@ otherwise returns string explaining the error\nfunction error() {\n  return common.state.error;\n};\nmodule.exports = error;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/templates/base.js":"/**\n Licensed to the Apache Software Foundation (ASF) under one\n or more contributor license agreements.  See the NOTICE file\n distributed with this work for additional information\n regarding copyright ownership.  The ASF licenses this file\n to you under the Apache License, Version 2.0 (the\n \"License\"); you may not use this file except in compliance\n with the License.  You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing,\n software distributed under the License is distributed on an\n \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n KIND, either express or implied.  See the License for the\n specific language governing permissions and limitations\n under the License.\n */\n\nvar exec = require('cordova/exec');\n\nexports.coolMethod = function(arg0, success, error) {\n    exec(success, error, \"%pluginName%\", \"coolMethod\", [arg0]);\n};\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/plugin/fetch.js":"\nvar npm = require('npm'),\n    path = require('path'),\n    Q = require('q'),\n    unpack = require('./unpack');\n\nvar events = require('weexpack-common').events,\n    fs     = require('fs'),\n    Q      = require('q'),\n    tar    = require('tar'),\n    zlib   = require('zlib');\n\n\nvar utils = require('../utils/npm')\n\n\n\nvar HOME = process.env[(process.platform.slice(0, 3) == 'win') ? 'USERPROFILE' : 'HOME'];\nvar  global_config_path = path.join(HOME, '.weexpack');\nvar lib_path = path.join(global_config_path, 'lib');\n\n\nfunction fetchPackage(packageName, packageVersion, callback) {\n\n          return cachePackage(packageName, packageVersion, callback);\n\n}\n\n\n/**\n * Invokes \"npm cache add,\" and then returns a promise that resolves to a directory containing the downloaded,\n * or cached package.\n * @param packageName - name of an npm package\n * @param packageVersion - requested version (not a version range)\n */\nfunction cachePackage(packageName, packageVersion, callback) {\n\n  utils.fetchCache(packageName, packageVersion, callback)\n\n}\n\n\n\n\n\n// Returns a promise for the path to the unpacked tarball (unzip + untar).\nfunction unpackTgz(package_tgz, unpackTarget) {\n  return Q.promise(function(resolve, reject) {\n    var extractOpts = { type: 'Directory', path: unpackTarget, strip: 1 };\n\n    fs.createReadStream(package_tgz)\n        .on('error', function (err) {\n          events.emit('warn', 'Unable to open tarball ' + package_tgz + ': ' + err);\n          reject(err);\n        })\n        .pipe(zlib.createUnzip())\n        .on('error', function (err) {\n          events.emit('warn', 'Error during unzip for ' + package_tgz + ': ' + err);\n          reject(err);\n        })\n        .pipe(tar.Extract(extractOpts))\n        .on('error', function(err) {\n          events.emit('warn', 'Error during untar for ' + package_tgz + ': ' + err);\n          reject(err);\n        })\n        .on('end', resolve);\n  })\n      .then(function() {\n        return unpackTarget;\n      });\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/plugin/gradle.js":"const fs = require('fs');\nconst path = require('path');\nconst isWin = process.platform === 'win32';\n\n\nfunction applyPatch(file, patch, isProject) {\n  var content = fs.readFileSync(file, 'utf8');\n\n  if(content.match(patch.findPattern || patch.patch)){\n    content = content.replace(patch.findPattern || patch.patch, '')\n  }\n\n  if(patch.findProjectPattern){\n    content = content.replace(patch.findProjectPattern, '')\n  }\n\n\n  if(isProject){\n    content = content.replace(patch.pattern, match => `${match}${patch.projectPatch}`)\n  }\n  else{\n    content = content.replace(patch.pattern, match => `${match}${patch.patch}`)\n  }\n\n  fs.writeFileSync(file, content)\n};\n\nfunction makeBuildPatch(name,version, groupId, isProject) {\n  return {\n    pattern: /\\t*dependencies {\\n/,\n    projectPatch:`    compile project(':${name}')\\n`,\n    patch: `    compile '${groupId}:${name}:${version}'\\n`,\n    findPattern:new RegExp('\\t*compile\\\\s+\\''+groupId+':'+name+'.*\\'\\\\n',\"g\"),\n    findProjectPattern:new RegExp('\\t*compile\\\\s+project\\\\(\\':'+name+'\\'\\\\).*\\\\n',\"g\")\n  };\n};\n\n\nfunction makeSettingsPatch(name, projectDir) {\n\n  /*\n   * Fix for Windows\n   * Backslashes is the escape character and will result in\n   * an invalid path in settings.gradle\n   * https://github.com/rnpm/rnpm/issues/113\n   */\n  if (isWin) {\n    projectDir = projectDir.replace(/\\\\/g, '/');\n  }\n\n  return {\n    pattern: '\\n',\n    patch: `include ':${name}'\\n` +\n    `project(':${name}').projectDir = ` +\n    `new File('${projectDir}')\\n`,\n    findPattern:new RegExp(\"include ':\"+name+\"'\\\\nproject\\\\(':\"+name+\"'\\\\).projectDir = new File\\\\('\"+projectDir+\"'\\\\)\\\\n\",\"g\")\n  };\n};\n\nfunction revokePatch(file, patch) {\n\n  var content = fs.readFileSync(file, 'utf8');\n  var p = content.match(patch.findProjectPattern)\n\n   content = content.replace(patch.findPattern||patch.patch, '').replace(patch.findProjectPattern,'')\n  fs.writeFileSync(file,content)\n\n};\n\nmodule.exports = {\n  applyPatch,\n  makeBuildPatch,\n  revokePatch,\n  makeSettingsPatch\n}","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/plugin/install.js":"var npm = require(\"npm\");\nvar utils = require(\"../utils\");\nvar npmHelper = require(\"../utils/npm\")\nvar path = require(\"path\");\nvar shell = require('shelljs');\nvar fs = require(\"fs\");\nvar xcode = require(\"xcode\");\nvar plist = require(\"plist\");\nvar gradle = require(\"./gradle\")\nvar podfile = require(\"./podfile\")\nvar merge = require(\"merge\")\nvar cli = require(\"../cli\")\n\n\nvar cordova_lib = require('../../lib'),\n    cordova = cordova_lib.cordova;\n\nvar cordovaUtils = require('../../lib/src/cordova/util')\n\nconst semver = require('semver')\n\nfunction install(pluginName, args){\n  var version;\n  var target = pluginName\n  if(/@/ig.test(pluginName)){\n    var temp = pluginName.split(\"@\")\n    pluginName = temp[0];\n    version = temp[1]\n  }\n\n  var dir = process.cwd();\n\n  //get the lastest version\n  if(!version){\n    npmHelper.getLastestVersion(pluginName, function(version){\n      utils.isNewVersionPlugin(pluginName, version, function(result){\n         if(result){\n           handleInstall(dir, pluginName, version,  result)\n           if(result.pluginDependencies){\n             for(var pn in result.pluginDependencies){\n               install(pn, result.pluginDependencies[pn])\n             }\n           }\n         }\n         else{\n           cli(args)\n           //cordova.raw[\"plugin\"](\"add\", [target]);\n        }\n      })\n    })\n  }\n  else{\n    utils.isNewVersionPlugin(pluginName,version, function(result){\n      if(result){\n        handleInstall(dir, pluginName, version, result)\n        if(result.pluginDependencies){\n          for(var pn in result.pluginDependencies){\n            install(pn, result.pluginDependencies[pn])\n          }\n        }\n      }\n      else{\n        cli(args)\n        //cordova.raw[\"plugin\"](\"add\", [target]);\n      }\n    })\n  }\n\n  //判断是否是新版本\n\n}\n\n\nfunction handleInstall(dir, pluginName, version, option){\n  //check out the type of current project\n  var project\n  if(project = utils.isIOSProject(dir)){\n    if(!fs.existsSync(path.join(dir,\"Podfile\"))){\n      console.log(\"can't find Podfile file\");\n      return ;\n    }\n    var name = option.ios&&option.ios.name?option.ios.name:pluginName\n\n\n    if(option.ios&&option.ios.plist){\n      var projectPath;\n        if(!project.isWorkspace){\n          projectPath = path.join(dir,project.name,\"project.pbxproj\")\n        }\n        installPList(dir, projectPath, option.ios.plist||{})\n    }\n\n    if(option.ios&&option.ios.type==\"pod\"){\n\n      var iosVersion = option.ios&&option.ios.version || version\n      const buildPatch = podfile.makeBuildPatch(name, iosVersion);\n      podfile.applyPatch(path.join(dir,\"Podfile\"), buildPatch);\n      console.log(name +\" install success in ios project\")\n    }\n    else{\n      npmHelper.fetchCache(pluginName, version, function (packageTGZ, packageDir) {\n        npmHelper.unpackTgz(packageTGZ, path.join(process.cwd(),\"weexplugins\",pluginName), function(){\n          var targetPath = path.join(process.cwd(), \"weexplugins\", pluginName);\n          const buildPatch = podfile.makeBuildPatch(targetPath, \"\");\n          podfile.applyPatch(path.join(dir,\"Podfile\"), buildPatch);\n          console.log(name +\" install success in ios project\")\n        })\n      })\n    }\n\n\n  }\n  else if (utils.isAndroidProject(dir)){\n    var name = option.android&&option.android.name?option.android.name:pluginName\n    if(option.android&&option.android.type == \"maven\"){\n      var androidVersion =  option.android&&option.android.version || version\n      const buildPatch = gradle.makeBuildPatch(name, androidVersion, option.android.groupId||\"\");\n      gradle.applyPatch(path.join(dir,\"build.gradle\"), buildPatch);\n      console.log(name +\" install success in android project\")\n    }\n    else {\n        npmHelper.fetchCache(pluginName, version, function (packageTGZ, packageDir) {\n          npmHelper.unpackTgz(packageTGZ, path.join(process.cwd(),\"weexplugins\",pluginName), function(){\n            var targetPath = path.join(process.cwd(), \"weexplugins\", pluginName);\n            //\n            const settingPatch = gradle.makeSettingsPatch(pluginName, targetPath)\n            gradle.applyPatch(path.join(dir,\"settings.gradle\"), settingPatch);\n\n            const buildPatch = gradle.makeBuildPatch(name, version, option.android.groupId||\"\");\n            gradle.applyPatch(path.join(dir,\"build.gradle\"), buildPatch, true);\n            console.log(name +\" install success in android project\")\n          })\n        })\n    }\n\n\n  }\n  //cordova工程\n  else if(cordovaUtils.isCordova(dir)){\n\n    var platformList = cordovaUtils.listPlatforms(dir);\n    for(var i = 0; i < platformList.length;i++){\n      //npm install\n\n      installInPackage(dir, pluginName, version)\n      var platformDir = path.join(dir,\"platforms\", platformList[i].toLowerCase())\n      handleInstall(platformDir, pluginName, version, option)\n    }\n\n  }\n  else if(fs.existsSync(path.join(dir,\"package.json\"))){\n    installInPackage(dir, pluginName, version)\n    console.log(name +\" install success \")\n  }\n  else {\n    console.log(\"can't recognize type of this project\")\n  }\n\n}\n\n\nfunction installPList(projectRoot, projectPath, config){\n  var xcodeproj = xcode.project(projectPath);\n  xcodeproj.parseSync();\n\n  var xcBuildConfiguration = xcodeproj.pbxXCBuildConfigurationSection();\n\n  for(var p in xcBuildConfiguration){\n    var entry = xcBuildConfiguration[p];\n    if(entry.buildSettings && entry.buildSettings.INFOPLIST_FILE){\n      var plist_file_entry = entry\n      break;\n    }\n\n  }\n  if(plist_file_entry){\n    var plist_file = path.join(projectRoot, plist_file_entry.buildSettings.INFOPLIST_FILE.replace(/^\"(.*)\"$/g, '$1').replace(/\\\\&/g, '&'));\n\n  }\n\n\n  if (!fs.existsSync(plist_file) ) {\n    console.error('Could not find *-Info.plist file');\n  }\n  else{\n    var obj = plist.parse(fs.readFileSync(plist_file, 'utf8'));\n    obj = merge.recursive(true, obj, config)\n\n    fs.writeFileSync(plist_file,plist.build(obj))\n\n  }\n}\n\n\n\nfunction installInPackage(dir, pluginName, version, option){\n  var p = path.join(dir,\"package.json\")\n  if(fs.existsSync(p)){\n    var pkg = require(p);\n    pkg.dependencies[pluginName] = version;\n    fs.writeFileSync(p, JSON.stringify(pkg, null, 4));\n  }\n\n\n}\n\nmodule.exports = install\n\n\n\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/plugin/podfile.js":"const fs = require('fs');\n\nfunction applyPatch(file, patch) {\n  var content = fs.readFileSync(file, 'utf8');\n\n\n  if(content.match(patch.findPattern)){\n    content = content.replace(patch.findPattern, '')\n  }\n\n  content = content.replace(patch.pattern, match => `${patch.patch}${match}`)\n\n  fs.writeFileSync(file, content)\n};\n// aim is to match (space insignificant around the comma, comma optional):\n//     pod 'Foobar', '1.2'\n//     pod 'Foobar', 'abc 123 1.2'\n//     pod 'PonyDebugger', :configurations => ['Debug', 'Beta']\n\n\nfunction makeBuildPatch(name, version) {\n  var patch = \"\"\n  if(version){\n    patch = `    pod '${name}', '${version}'\\n`\n\n  }\n  else {\n    patch = `    pod '${name}'\\n`\n  }\n\n  return {\n    pattern: /\\t*pod\\s+\\'\\w+\\'\\s*,?.*\\n/,\n    patch: patch,\n    findPattern:new RegExp('\\\\t*pod\\\\s+\\''+name+'\\'\\\\s*,?.*\\\\n',\"g\")\n  };\n};\n\nfunction revokePatch(file, patch) {\n  fs.writeFileSync(file, fs\n      .readFileSync(file, 'utf8')\n      .replace(patch.findPattern, '')\n  );\n};\n\n//\n\nmodule.exports = {\n  applyPatch,\n  makeBuildPatch,\n  revokePatch\n}","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/plugin/project.js":"var config            = require('../../lib/src/cordova/config'),\n    cordova           = require('../../lib/src/cordova/cordova'),\n    prepare           = require('../../lib/src/cordova//prepare'),\n    cordova_util      = require('../../lib/src/cordova/util'),\n    ConfigParser      = require('weexpack-common').ConfigParser,\n    fs                = require('fs'),\n    os                = require('os'),\n    path              = require('path'),\n    events            = require('weexpack-common').events,\n    lazy_load         = require('../../lib/src/cordova/lazy_load'),\n    CordovaError      = require('weexpack-common').CordovaError,\n    Q                 = require('q'),\n    promiseutil       = require('../../lib/src/util/promise-util'),\n    HooksRunner       = require('../../lib/src/hooks/HooksRunner'),\n    superspawn        = require('weexpack-common').superspawn,\n    semver            = require('semver'),\n    shell             = require('shelljs'),\n    _                 = require('underscore'),\n    PlatformJson      = require('weexpack-common').PlatformJson,\n    fetch             = require('cordova-fetch'),\n    gitclone      = require('../../lib/src/gitclone'),\n    npmUninstall         = require('cordova-fetch').uninstall;\n\n\nvar project = {}\n\nproject.createProject = function(projectRoot, platform, opts) {\n  var msg;\n\n\n\n  opts = opts || {};\n\n\n  // The \"platforms\" dir is safe to delete, it's almost equivalent to\n  // cordova platform rm <list of all platforms>\n  var platformsDir = projectRoot\n\n\n  return Q().then(function() {\n    return downloadProject(projectRoot, platform,  opts);\n  }).then(function(dir) {\n\n    var platformPath = path.join(projectRoot, 'Weexplugin');\n    var platformAlreadyAdded = fs.existsSync(platformPath);\n\n    if (platformAlreadyAdded) {\n      throw new CordovaError('plugin project ' + platform + ' already added.');\n      console.log('plugin project ' + platform + ' already added.')\n    }\n\n    var tempDir =\"\"\n    if(platform == \"ios\"){\n      tempDir = path.join(dir,\"bin\",\"templates\")\n    }\n    else {\n      tempDir = dir;\n    }\n\n    shell.mkdir('-p', platformPath);\n    copyProject(tempDir, platformPath)\n    if(platform == \"ios\" && opts.ali == true){\n      changeSource(platformPath)\n    }\n\n    events.emit('log', ' ');\n    events.emit('log', 'add plugin'  + platform + ' project ...');\n    console.log('create weexplugin project  success...')\n\n\n  });\n\n}\n\n\nfunction changeSource (destinationDir){\n\n    var weexPluginRootDir = path.join(destinationDir);\n    var xcodeProjDir;\n    var xcodeCordovaProj;\n\n    try {\n      xcodeProjDir = fs.readdirSync(weexPluginRootDir).filter( function(e) { return e.match(/\\.xcodeproj$/i); })[0];\n      if (!xcodeProjDir) {\n        throw new CordovaError('The provided path \"' + weexPluginRootDir + '\" is not a Weex iOS project.');\n      }\n\n      var cordovaProjName = xcodeProjDir.substring(xcodeProjDir.lastIndexOf(path.sep)+1, xcodeProjDir.indexOf('.xcodeproj'));\n      xcodeCordovaProj = path.join(weexPluginRootDir, cordovaProjName);\n    } catch(e) {\n      throw new CordovaError('The provided path \"'+weexPluginRootDir+'\" is not a weexpack iOS project.');\n    }\n    var Podfile = require('../../lib/src/platforms/ios_pack/lib/Podfile').Podfile;\n    var project_name = xcodeCordovaProj.split('/').pop();\n    var podfileFile = new Podfile(path.join(weexPluginRootDir, Podfile.FILENAME), project_name)\n    podfileFile.writeUseAliSource()\n\n\n}\n\n\n\n\nfunction  removeProject() {\n\n\n}\n\n\nfunction createProjectInWeexpack() {\n\n}\n\n\nfunction listPlatforms(project_dir) {\n  var core_platforms = require('../../lib/src/platforms/platforms');\n  var platforms_dir = path.join(project_dir, 'platforms');\n  if ( !exports.existsSync(platforms_dir)) {\n    return [];\n  }\n  var subdirs = fs.readdirSync(platforms_dir);\n  return subdirs.filter(function(p) {\n    return Object.keys(core_platforms).indexOf(p) > -1;\n  });\n}\n\nvar  pluginProjectApi = {}\n\npluginProjectApi.create = function (destinationDir, projectConfig, options) {\n\n\n  var templatePath = destinationDir\n  return Q().then(function(){\n    copyProject(templatePath, destinationDir)\n\n    return pluginProjectApi;\n  })\n\n};\n\n/**\n * Updates already installed platform.\n *\n * @param  {String}  destinationDir  A directory, where existing platform\n *   installed, that should be updated.\n * @param  {Object}  [options]  An options object. The most common options are:\n * @param  {String}  [options.customTemplate]  A path to custom template, that\n *   should override the default one from platform.\n * @param  {Boolean}  [options.link=false]  Flag that indicates that platform's sources\n *   will be linked to installed platform instead of copying.\n *\n * @return {Promise<PlatformApi>} Promise either fulfilled with PlatformApi\n *   instance or rejected with CordovaError.\n */\npluginProjectApi.update = function (destinationDir, options) {\n  if (!options || !options.platformDetails)\n    return Q.reject(new CordovaError('Failed to find platform\\'s \\'create\\' script. ' +\n        'Either \\'options\\' parameter or \\'platformDetails\\' option is missing'));\n\n  var command = path.join(options.platformDetails.libDir, 'bin', 'update');\n  return superspawn.spawn(command, [destinationDir],\n      { printCommand: true, stdio: 'inherit', chmod: true })\n      .then(function () {\n        var platformApi = knownPlatforms\n            .getPlatformApi(options.platformDetails.platform, destinationDir);\n        copyCordovaSrc(options.platformDetails.libDir, platformApi.getPlatformInfo());\n        return platformApi;\n      });\n};\n\n\n\n\nfunction downloadProject(projectRoot, platform) {\n  return Q().then(function() {\n    var git_url = 'https://github.com/weexteam/weexpluginContainer-iOS.git'\n    if (platform == \"ios\") {\n      git_url = 'https://github.com/weexteam/weexpluginContainer-iOS.git'\n    }\n\n\n    if(platform == \"android\") {\n      git_url = 'https://github.com/weexteam/weexplugin-android.git'\n    }\n\n\n    return git_clone(git_url, undefined).fail(function(err) {\n      // If it looks like a url, but cannot be cloned, try handling it differently.\n      // it's because it's a tarball of the form:\n      //     - wp8@https://git-wip-us.apache.org/repos/asf?p=cordova-wp8.git;a=snapshot;h=3.7.0;sf=tgz\n      //     - https://api.github.com/repos/msopenTech/cordova-browser/tarball/my-branch\n      events.emit('verbose', err.message);\n      events.emit('verbose', 'Cloning failed. Let\\'s try handling it as a tarball');\n    });\n\n\n    return cordova_npm(projectRoot, target, opts);\n  }).fail(function (error) {\n    var message = 'Failed to fetch plugin container for platform ' + platform +\n        '\\nProbably this is either a connection problem, or platform spec is incorrect.' +\n        '\\nCheck your connection and platform name/version/URL.' +\n        '\\n' + error;\n    return Q.reject(new CordovaError(message));\n  });\n}\n\n// Returns a promise\nfunction git_clone(git_url, branch) {\n  // Create a tmp dir. Using /tmp is a problem because it's often on a different partition and sehll.mv()\n  // fails in this case with \"EXDEV, cross-device link not permitted\".\n  var tmp_subidr = 'tmp_cordova_git_' + process.pid + '_' + (new Date()).valueOf();\n  var tmp_dir = path.join(cordova_util.libDirectory, 'tmp', tmp_subidr);\n  shell.rm('-rf', tmp_dir);\n  shell.mkdir('-p', tmp_dir);\n\n  return Q().then(function () {\n    var branchToCheckout = branch || 'master';\n    return gitclone.clone(git_url, branchToCheckout, tmp_dir);\n  }).then(function () {\n\n    return tmp_dir;\n  }).fail(function (err) {\n    shell.rm('-rf', tmp_dir);\n    return Q.reject(err);\n  });\n}\n\n\n\nfunction cordova_git(platform) {\n  var mixed_platforms = _.extend({}, platforms),\n      plat;\n  if (!(platform.name in platforms)) {\n    return Q.reject(new Error('weexpack library \"' + platform.name + '\" not recognized.'));\n  }\n  plat = mixed_platforms[platform.name];\n  plat.id = 'cordova';\n\n  // We can't use a version range when getting from git, so if we have a range, find the latest release on npm that matches.\n  return util.getLatestMatchingNpmVersion(platform.packageName, platform.version).then(function (version) {\n    plat.version = version;\n    if (/^...*:/.test(plat.url)) {\n      plat.url = plat.url + ';a=snapshot;h=' + version + ';sf=tgz';\n    }\n    return module.exports.custom(mixed_platforms, platform.name);\n  });\n}\n\nfunction cordova_npm(platform) {\n  if (!(platform.name in platforms)) {\n    return Q.reject(new Error('weexpack library \"' + platform.name + '\" not recognized.'));\n  }\n  // Check if this version was already downloaded from git, if yes, use that copy.\n  // TODO: remove this once we fully switch to npm workflow.\n  var platdir = platforms[platform.name].altplatform || platform.name;\n  // If platform.version specifies a *range*, we need to determine what version we'll actually get from npm (the\n  // latest version that matches the range) to know what local directory to look for.\n  return util.getLatestMatchingNpmVersion(platform.packageName, platform.version).then(function (version) {\n    var git_dload_dir = path.join(util.libDirectory, platdir, 'cordova', version);\n    if (fs.existsSync(git_dload_dir)) {\n      var subdir = platforms[platform.name].subdirectory;\n      if (subdir) {\n        git_dload_dir = path.join(git_dload_dir, subdir);\n      }\n      events.emit('verbose', 'Platform files for \"' + platform.name + '\" previously downloaded not from npm. Using that copy.');\n      return Q(git_dload_dir);\n    }\n\n    // Note that because the version of npm we use internally doesn't support caret versions, in order to allow them\n    // from the command line and in config.xml, we use the actual version returned by getLatestMatchingNpmVersion().\n    return npmhelper.cachePackage(platform.packageName, version);\n  });\n}\n\n\n\n\nfunction copyProject(templateDir, projectDir){\n  var templateFiles;      // Current file\n  templateFiles = fs.readdirSync(templateDir);\n  // Remove directories, and files that are unwanted\n\n  // Copy each template file after filter\n  for (var i = 0; i < templateFiles.length; i++) {\n    var p = path.resolve(templateDir, templateFiles[i]);\n    shell.cp('-R', p, projectDir);\n  }\n}\n\n\nmodule.exports = project\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/cordova/config.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar path          = require('path'),\n    fs            = require('fs'),\n    url           = require('url'),\n    shell         = require('shelljs');\n\n// Map of project_root -> JSON\nvar configCache = {};\nvar autoPersist = true;\n\nfunction config(project_root, opts) {\n    var json = config.read(project_root);\n    for (var p in opts) {\n        json[p] = opts[p];\n    }\n    if (autoPersist) {\n        config.write(project_root, json);\n    } else {\n        configCache[project_root] = JSON.stringify(json);\n    }\n    return json;\n}\n\nconfig.getAutoPersist = function() {\n    return autoPersist;\n};\n\nconfig.setAutoPersist = function(value) {\n    autoPersist = value;\n};\n\nconfig.read = function get_config(project_root) {\n    var data = configCache[project_root];\n    if (data === undefined) {\n        var configPath = path.join(project_root, '.cordova', 'config.json');\n        if (!fs.existsSync(configPath)) {\n            data = '{}';\n        } else {\n            data = fs.readFileSync(configPath, 'utf-8');\n        }\n    }\n    configCache[project_root] = data;\n    return JSON.parse(data);\n};\n\nconfig.write = function set_config(project_root, json) {\n    var configPath = path.join(project_root, '.cordova', 'config.json');\n    var contents = JSON.stringify(json, null, 4);\n    configCache[project_root] = contents;\n    // Don't write the file for an empty config.\n    if (contents != '{}' || fs.existsSync(configPath)) {\n        shell.mkdir('-p', path.join(project_root, '.cordova'));\n        fs.writeFileSync(configPath, contents, 'utf-8');\n    }\n    return json;\n};\n\nconfig.has_custom_path = function(project_root, platform) {\n    var json = config.read(project_root);\n    if (json.lib && json.lib[platform]) {\n        var uri = url.parse(json.lib[platform].url || json.lib[platform].uri);\n        if (!(uri.protocol)) return uri.path;\n        else if (uri.protocol && uri.protocol[1] ==':') return uri.href;\n    }\n    return false;\n};\n\nmodule.exports = config;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/cordova/prepare.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar cordova_util      = require('./util'),\n    ConfigParser      = require('weexpack-common').ConfigParser,\n    PlatformJson      = require('weexpack-common').PlatformJson,\n    PluginInfoProvider = require('weexpack-common').PluginInfoProvider,\n    PlatformMunger    = require('weexpack-common').ConfigChanges.PlatformMunger,\n    events            = require('weexpack-common').events,\n    platforms         = require('../platforms/platforms'),\n    PlatformApiPoly = require('../platforms/PlatformApiPoly'),\n    HooksRunner       = require('../hooks/HooksRunner'),\n    Q                 = require('q'),\n    restore           = require('./restore-util'),\n    path              = require('path'),\n    config            = require('./config'),\n    _ = require('underscore');\n\n// Returns a promise.\nexports = module.exports = prepare;\nfunction prepare(options) {\n    return Q().then(function() {\n        var projectRoot = cordova_util.cdProjectRoot();\n        var config_json = config.read(projectRoot);\n        options = options || { verbose: false, platforms: [], options: {} };\n        options.save = options.save || false;\n        options.fetch = options.fetch || false;\n        var hooksRunner = new HooksRunner(projectRoot);\n        return hooksRunner.fire('before_prepare', options)\n        .then(function(){\n            return restore.installPlatformsFromConfigXML(options.platforms, { searchpath : options.searchpath, fetch : options.fetch, restoring : true });\n        })\n        .then(function(){\n            options = cordova_util.preProcessOptions(options);\n            var paths = options.platforms.map(function(p) {\n                var platform_path = path.join(projectRoot, 'platforms', p);\n                return platforms.getPlatformApi(p, platform_path).getPlatformInfo().locations.www;\n            });\n            options.paths = paths;\n        }).then(function() {\n            options = cordova_util.preProcessOptions(options);\n            options.searchpath = options.searchpath || config_json.plugin_search_path;\n            // Iterate over each added platform\n            return preparePlatforms(options.platforms, projectRoot, options);\n        }).then(function() {\n            options.paths = options.platforms.map(function(platform) {\n                return platforms.getPlatformApi(platform).getPlatformInfo().locations.www;\n            });\n            return hooksRunner.fire('after_prepare', options);\n        }).then(function () {\n            return restore.installPluginsFromConfigXML(options);\n        });\n    });\n}\n\n/**\n * Calls `platformApi.prepare` for each platform in project\n *\n * @param   {string[]}  platformList  List of platforms, added to current project\n * @param   {string}    projectRoot   Project root directory\n *\n * @return  {Promise}\n */\nfunction preparePlatforms (platformList, projectRoot, options) {\n    return Q.all(platformList.map(function(platform) {\n        // TODO: this need to be replaced by real projectInfo\n        // instance for current project.\n        var project = {\n            root: projectRoot,\n            projectConfig: new ConfigParser(cordova_util.projectConfig(projectRoot)),\n            locations: {\n                plugins: path.join(projectRoot, 'plugins'),\n                www: cordova_util.projectWww(projectRoot)\n            }\n        };\n\n        // CB-9987 We need to reinstall the plugins for the platform it they were added by cordova@<5.4.0\n        return restoreMissingPluginsForPlatform(platform, projectRoot, options)\n        .then(function () {\n            // platformApi prepare takes care of all functionality\n            // which previously had been executed by cordova.prepare:\n            //   - reset config.xml and then merge changes from project's one,\n            //   - update www directory from project's one and merge assets from platform_www,\n            //   - reapply config changes, made by plugins,\n            //   - update platform's project\n            // Please note that plugins' changes, such as installed js files, assets and\n            // config changes is not being reinstalled on each prepare.\n            var platformApi = platforms.getPlatformApi(platform);\n            return platformApi.prepare(project, _.clone(options))\n            .then(function () {\n                if (platform === 'windows' && !(platformApi instanceof PlatformApiPoly)) {\n                    // Windows Api doesn't fire 'pre_package' hook, so we fire it here\n                    return new HooksRunner(projectRoot).fire('pre_package', {\n                        wwwPath: platformApi.getPlatformInfo().locations.www,\n                        platforms: ['windows'],\n                        nohooks: options.nohooks\n                    });\n                }\n            })\n            .then(function () {\n                if (options.browserify) {\n                    var browserify = require('../plugman/browserify');\n                    return browserify(project, platformApi);\n                }\n            })\n            .then(function () {\n                // Handle edit-config in config.xml\n                var platformRoot = path.join(projectRoot, 'platforms', platform);\n                var platformJson = PlatformJson.load(platformRoot, platform);\n                var munger = new PlatformMunger(platform, platformRoot, platformJson);\n                munger.add_config_changes(project.projectConfig, /*should_increment=*/true).save_all();\n            });\n        });\n    }));\n}\n\nmodule.exports.preparePlatforms = preparePlatforms;\n\n/**\n * Ensures that plugins, installed with previous versions of CLI (<5.4.0) are\n *   readded to platform correctly. Also triggers regeneration of\n *   cordova_plugins.js file.\n *\n * @param   {String}  platform     Platform name to check for installed plugins\n * @param   {String}  projectRoot  A current cordova project location\n * @param   {Object}  [options]    Options that will be passed to\n *   PlatformApi.pluginAdd/Remove. This object will be extended with plugin\n *   variables, used to install the plugin initially (picked from \"old\"\n *   plugins/<platform>.json)\n *\n * @return  {Promise}               Promise that'll be fulfilled if all the\n *   plugins reinstalled properly.\n */\nfunction restoreMissingPluginsForPlatform(platform, projectRoot, options) {\n    events.emit('verbose', 'Checking for any plugins added to the project that have not been installed in ' + platform + ' platform');\n\n    // Flow:\n    // 1. Compare <platform>.json file in <project>/plugins (\"old\") and platforms/<platform> (\"new\")\n    // 2. If there is any differences - merge \"old\" one into \"new\"\n    // 3. Reinstall plugins that are missing and was merged on previous step\n\n    var oldPlatformJson = PlatformJson.load(path.join(projectRoot, 'plugins'), platform);\n    var platformJson = PlatformJson.load(path.join(projectRoot, 'platforms', platform), platform);\n\n    var missingPlugins = Object.keys(oldPlatformJson.root.installed_plugins)\n        .concat(Object.keys(oldPlatformJson.root.dependent_plugins))\n        .reduce(function (result, candidate) {\n            if (!platformJson.isPluginInstalled(candidate))\n                result.push({name: candidate,\n                    // Note: isPluginInstalled is actually returns not a boolean,\n                    // but object which corresponds to this particular plugin\n                    variables: oldPlatformJson.isPluginInstalled(candidate)});\n\n            return result;\n        }, []);\n\n    if (missingPlugins.length === 0) {\n        events.emit('verbose', 'No differences found between plugins added to project and installed in ' +\n            platform + ' platform. Continuing...');\n        return Q.resolve();\n    }\n\n    var api = platforms.getPlatformApi(platform);\n    var provider = new PluginInfoProvider();\n    return missingPlugins.reduce(function (promise, plugin) {\n        return promise.then(function () {\n            var pluginOptions = options || {};\n            pluginOptions.variables = plugin.variables;\n            pluginOptions.usePlatformWww = true;\n\n            events.emit('verbose', 'Reinstalling missing plugin ' + plugin.name + ' in ' + platform + ' platform');\n            var pluginInfo = provider.get(path.join(projectRoot, 'plugins', plugin.name));\n            return api.removePlugin(pluginInfo, pluginOptions)\n            .then(function () {\n                return api.addPlugin(pluginInfo, pluginOptions);\n            });\n        });\n    }, Q());\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/ConfigParser/ConfigParser.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint sub:true */\n\nvar et = require('elementtree'),\n    xml= require('../util/xml-helpers'),\n    CordovaError = require('../CordovaError/CordovaError'),\n    fs = require('fs'),\n    events = require('../events');\n\n\n/** Wraps a config.xml file */\nfunction ConfigParser(path) {\n    this.path = path;\n    try {\n        this.doc = xml.parseElementtreeSync(path);\n        this.cdvNamespacePrefix = getCordovaNamespacePrefix(this.doc);\n        et.register_namespace(this.cdvNamespacePrefix, 'http://cordova.apache.org/ns/1.0');\n    } catch (e) {\n        console.error('Parsing '+path+' failed');\n        throw e;\n    }\n    var r = this.doc.getroot();\n    if (r.tag !== 'widget') {\n        throw new CordovaError(path + ' has incorrect root node name (expected \"widget\", was \"' + r.tag + '\")');\n    }\n}\n\nfunction getNodeTextSafe(el) {\n    return el && el.text && el.text.trim();\n}\n\nfunction findOrCreate(doc, name) {\n    var ret = doc.find(name);\n    if (!ret) {\n        ret = new et.Element(name);\n        doc.getroot().append(ret);\n    }\n    return ret;\n}\n\nfunction getCordovaNamespacePrefix(doc){\n    var rootAtribs = Object.getOwnPropertyNames(doc.getroot().attrib);\n    var prefix = 'cdv';\n    for (var j = 0; j < rootAtribs.length; j++ ) {\n        if(rootAtribs[j].indexOf('xmlns:') === 0 &&\n            doc.getroot().attrib[rootAtribs[j]] === 'http://cordova.apache.org/ns/1.0'){\n            var strings = rootAtribs[j].split(':');\n            prefix = strings[1];\n            break;\n        }\n    }\n    return prefix;\n}\n\n/**\n * Finds the value of an element's attribute\n * @param  {String} attributeName Name of the attribute to search for\n * @param  {Array}  elems         An array of ElementTree nodes\n * @return {String}\n */\nfunction findElementAttributeValue(attributeName, elems) {\n\n    elems = Array.isArray(elems) ? elems : [ elems ];\n\n    var value = elems.filter(function (elem) {\n        return elem.attrib.name.toLowerCase() === attributeName.toLowerCase();\n    }).map(function (filteredElems) {\n        return filteredElems.attrib.value;\n    }).pop();\n\n    return value ? value : '';\n}\n\nConfigParser.prototype = {\n    getAttribute: function(attr) {\n        return this.doc.getroot().attrib[attr];\n    },\n\n    packageName: function(id) {\n        return this.getAttribute('id');\n    },\n    setPackageName: function(id) {\n        this.doc.getroot().attrib['id'] = id;\n    },\n    android_packageName: function() {\n        return this.getAttribute('android-packageName');\n    },\n    android_activityName: function() {\n        return this.getAttribute('android-activityName');\n    },\n    ios_CFBundleIdentifier: function() {\n        return this.getAttribute('ios-CFBundleIdentifier');\n    },\n    name: function() {\n        return getNodeTextSafe(this.doc.find('name'));\n    },\n    setName: function(name) {\n        var el = findOrCreate(this.doc, 'name');\n        el.text = name;\n    },\n    description: function() {\n        return getNodeTextSafe(this.doc.find('description'));\n    },\n    setDescription: function(text) {\n        var el = findOrCreate(this.doc, 'description');\n        el.text = text;\n    },\n    version: function() {\n        return this.getAttribute('version');\n    },\n    windows_packageVersion: function() {\n        return this.getAttribute('windows-packageVersion');\n    },\n    android_versionCode: function() {\n        return this.getAttribute('android-versionCode');\n    },\n    ios_CFBundleVersion: function() {\n        return this.getAttribute('ios-CFBundleVersion');\n    },\n    setVersion: function(value) {\n        this.doc.getroot().attrib['version'] = value;\n    },\n    author: function() {\n        return getNodeTextSafe(this.doc.find('author'));\n    },\n    getGlobalPreference: function (name) {\n        return findElementAttributeValue(name, this.doc.findall('preference'));\n    },\n    setGlobalPreference: function (name, value) {\n        var pref = this.doc.find('preference[@name=\"' + name + '\"]');\n        if (!pref) {\n            pref = new et.Element('preference');\n            pref.attrib.name = name;\n            this.doc.getroot().append(pref);\n        }\n        pref.attrib.value = value;\n    },\n    getPlatformPreference: function (name, platform) {\n        return findElementAttributeValue(name, this.doc.findall('platform[@name=\\'' + platform + '\\']/preference'));\n    },\n    getPreference: function(name, platform) {\n\n        var platformPreference = '';\n\n        if (platform) {\n            platformPreference = this.getPlatformPreference(name, platform);\n        }\n\n        return platformPreference ? platformPreference : this.getGlobalPreference(name);\n\n    },\n    /**\n     * Returns all resources for the platform specified.\n     * @param  {String} platform     The platform.\n     * @param {string}  resourceName Type of static resources to return.\n     *                               \"icon\" and \"splash\" currently supported.\n     * @return {Array}               Resources for the platform specified.\n     */\n    getStaticResources: function(platform, resourceName) {\n        var ret = [],\n            staticResources = [];\n        if (platform) { // platform specific icons\n            this.doc.findall('platform[@name=\\'' + platform + '\\']/' + resourceName).forEach(function(elt){\n                elt.platform = platform; // mark as platform specific resource\n                staticResources.push(elt);\n            });\n        }\n        // root level resources\n        staticResources = staticResources.concat(this.doc.findall(resourceName));\n        // parse resource elements\n        var that = this;\n        staticResources.forEach(function (elt) {\n            var res = {};\n            res.src = elt.attrib.src;\n            res.target = elt.attrib.target || undefined;\n            res.density = elt.attrib['density'] || elt.attrib[that.cdvNamespacePrefix+':density'] || elt.attrib['gap:density'];\n            res.platform = elt.platform || null; // null means icon represents default icon (shared between platforms)\n            res.width = +elt.attrib.width || undefined;\n            res.height = +elt.attrib.height || undefined;\n\n            // default icon\n            if (!res.width && !res.height && !res.density) {\n                ret.defaultResource = res;\n            }\n            ret.push(res);\n        });\n\n        /**\n         * Returns resource with specified width and/or height.\n         * @param  {number} width Width of resource.\n         * @param  {number} height Height of resource.\n         * @return {Resource} Resource object or null if not found.\n         */\n        ret.getBySize = function(width, height) {\n            return ret.filter(function(res) {\n                if (!res.width && !res.height) {\n                    return false;\n                }\n                return ((!res.width || (width == res.width)) &&\n                    (!res.height || (height == res.height)));\n            })[0] || null;\n        };\n\n        /**\n         * Returns resource with specified density.\n         * @param  {string} density Density of resource.\n         * @return {Resource}       Resource object or null if not found.\n         */\n        ret.getByDensity = function(density) {\n            return ret.filter(function(res) {\n                return res.density == density;\n            })[0] || null;\n        };\n\n        /** Returns default icons */\n        ret.getDefault = function() {\n            return ret.defaultResource;\n        };\n\n        return ret;\n    },\n\n    /**\n     * Returns all icons for specific platform.\n     * @param  {string} platform Platform name\n     * @return {Resource[]}      Array of icon objects.\n     */\n    getIcons: function(platform) {\n        return this.getStaticResources(platform, 'icon');\n    },\n\n    /**\n     * Returns all splash images for specific platform.\n     * @param  {string} platform Platform name\n     * @return {Resource[]}      Array of Splash objects.\n     */\n    getSplashScreens: function(platform) {\n        return this.getStaticResources(platform, 'splash');\n    },\n\n    /**\n     * Returns all hook scripts for the hook type specified.\n     * @param  {String} hook     The hook type.\n     * @param {Array}  platforms Platforms to look for scripts into (root scripts will be included as well).\n     * @return {Array}               Script elements.\n     */\n    getHookScripts: function(hook, platforms) {\n        var self = this;\n        var scriptElements = self.doc.findall('./hook');\n\n        if(platforms) {\n            platforms.forEach(function (platform) {\n                scriptElements = scriptElements.concat(self.doc.findall('./platform[@name=\"' + platform + '\"]/hook'));\n            });\n        }\n\n        function filterScriptByHookType(el) {\n            return el.attrib.src && el.attrib.type && el.attrib.type.toLowerCase() === hook;\n        }\n\n        return scriptElements.filter(filterScriptByHookType);\n    },\n   /**\n    * Returns a list of plugin (IDs).\n    *\n    * This function also returns any plugin's that\n    * were defined using the legacy <feature> tags.\n    * @return {string[]} Array of plugin IDs\n    */\n    getPluginIdList: function () {\n        var plugins = this.doc.findall('plugin');\n        var result = plugins.map(function(plugin){\n            return plugin.attrib.name;\n        });\n        var features = this.doc.findall('feature');\n        features.forEach(function(element ){\n            var idTag = element.find('./param[@name=\"id\"]');\n            if(idTag){\n                result.push(idTag.attrib.value);\n            }\n        });\n        return result;\n    },\n    getPlugins: function () {\n        return this.getPluginIdList().map(function (pluginId) {\n            return this.getPlugin(pluginId);\n        }, this);\n    },\n    /**\n     * Adds a plugin element. Does not check for duplicates.\n     * @name addPlugin\n     * @function\n     * @param {object} attributes name and spec are supported\n     * @param {Array|object} variables name, value or arbitary object\n     */\n    addPlugin: function (attributes, variables) {\n        if (!attributes && !attributes.name) return;\n        var el = new et.Element('plugin');\n        el.attrib.name = attributes.name;\n        if (attributes.spec) {\n            el.attrib.spec = attributes.spec;\n        }\n\n        // support arbitrary object as variables source\n        if (variables && typeof variables === 'object' && !Array.isArray(variables)) {\n            variables = Object.keys(variables)\n            .map(function (variableName) {\n                return {name: variableName, value: variables[variableName]};\n            });\n        }\n\n        if (variables) {\n            variables.forEach(function (variable) {\n                el.append(new et.Element('variable', { name: variable.name, value: variable.value }));\n            });\n        }\n        this.doc.getroot().append(el);\n    },\n    /**\n     * Retrives the plugin with the given id or null if not found.\n     *\n     * This function also returns any plugin's that\n     * were defined using the legacy <feature> tags.\n     * @name getPlugin\n     * @function\n     * @param {String} id\n     * @returns {object} plugin including any variables\n     */\n    getPlugin: function(id){\n        if(!id){\n            return undefined;\n        }\n        var pluginElement = this.doc.find('./plugin/[@name=\"' + id + '\"]');\n        if (null === pluginElement) {\n            var legacyFeature =  this.doc.find('./feature/param[@name=\"id\"][@value=\"' + id + '\"]/..');\n            if(legacyFeature){\n                 events.emit('log', 'Found deprecated feature entry for ' + id +' in config.xml.');\n                return featureToPlugin(legacyFeature);\n            }\n            return undefined;\n        }\n        var plugin = {};\n\n        plugin.name = pluginElement.attrib.name;\n        plugin.spec = pluginElement.attrib.spec || pluginElement.attrib.src || pluginElement.attrib.version;\n        plugin.variables = {};\n        var variableElements = pluginElement.findall('variable');\n        variableElements.forEach(function(varElement){\n            var name = varElement.attrib.name;\n            var value = varElement.attrib.value;\n            if(name){\n                plugin.variables[name] = value;\n            }\n        });\n        return plugin;\n    },\n    /**\n     * Remove the plugin entry with give name (id).\n     *\n     * This function also operates on any plugin's that\n     * were defined using the legacy <feature> tags.\n     * @name removePlugin\n     * @function\n     * @param id name of the plugin\n     */\n    removePlugin: function(id){\n        if(id){\n            var plugins = this.doc.findall('./plugin/[@name=\"' + id + '\"]')\n                .concat(this.doc.findall('./feature/param[@name=\"id\"][@value=\"' + id + '\"]/..'));\n            var children = this.doc.getroot().getchildren();\n            plugins.forEach(function (plugin) {\n                var idx = children.indexOf(plugin);\n                if (idx > -1) {\n                    children.splice(idx, 1);\n                }\n            });\n        }\n    },\n\n    // Add any element to the root\n    addElement: function(name, attributes) {\n        var el = et.Element(name);\n        for (var a in attributes) {\n            el.attrib[a] = attributes[a];\n        }\n        this.doc.getroot().append(el);\n    },\n\n    /**\n     * Adds an engine. Does not check for duplicates.\n     * @param  {String} name the engine name\n     * @param  {String} spec engine source location or version (optional)\n     */\n    addEngine: function(name, spec){\n        if(!name) return;\n        var el = et.Element('engine');\n        el.attrib.name = name;\n        if(spec){\n            el.attrib.spec = spec;\n        }\n        this.doc.getroot().append(el);\n    },\n    /**\n     * Removes all the engines with given name\n     * @param  {String} name the engine name.\n     */\n    removeEngine: function(name){\n        var engines = this.doc.findall('./engine/[@name=\"' +name+'\"]');\n        for(var i=0; i < engines.length; i++){\n            var children = this.doc.getroot().getchildren();\n            var idx = children.indexOf(engines[i]);\n            if(idx > -1){\n                children.splice(idx,1);\n            }\n        }\n    },\n    getEngines: function(){\n        var engines = this.doc.findall('./engine');\n        return engines.map(function(engine){\n            var spec = engine.attrib.spec || engine.attrib.version;\n            return {\n                'name': engine.attrib.name,\n                'spec': spec ? spec : null\n            };\n        });\n    },\n    /* Get all the access tags */\n    getAccesses: function() {\n        var accesses = this.doc.findall('./access');\n        return accesses.map(function(access){\n            var minimum_tls_version = access.attrib['minimum-tls-version']; /* String */\n            var requires_forward_secrecy = access.attrib['requires-forward-secrecy']; /* Boolean */\n            var requires_certificate_transparency = access.attrib['requires-certificate-transparency']; /* Boolean */\n            var allows_arbitrary_loads_in_web_content = access.attrib['allows-arbitrary-loads-in-web-content']; /* Boolean */\n            var allows_arbitrary_loads_in_media = access.attrib['allows-arbitrary-loads-in-media']; /* Boolean */\n            var allows_local_networking = access.attrib['allows-local-networking']; /* Boolean */\n            \n            return {\n                'origin': access.attrib.origin,\n                'minimum_tls_version': minimum_tls_version,\n                'requires_forward_secrecy' : requires_forward_secrecy,\n                'requires_certificate_transparency' : requires_certificate_transparency,\n                'allows_arbitrary_loads_in_web_content' : allows_arbitrary_loads_in_web_content,\n                'allows_arbitrary_loads_in_media' : allows_arbitrary_loads_in_media,\n                'allows_local_networking' : allows_local_networking\n            };\n        });\n    },\n    /* Get all the allow-navigation tags */\n    getAllowNavigations: function() {\n        var allow_navigations = this.doc.findall('./allow-navigation');\n        return allow_navigations.map(function(allow_navigation){\n            var minimum_tls_version = allow_navigation.attrib['minimum-tls-version']; /* String */\n            var requires_forward_secrecy = allow_navigation.attrib['requires-forward-secrecy']; /* Boolean */\n            var requires_certificate_transparency = allow_navigation.attrib['requires-certificate-transparency']; /* Boolean */\n\n            return {\n                'href': allow_navigation.attrib.href,\n                'minimum_tls_version': minimum_tls_version,\n                'requires_forward_secrecy' : requires_forward_secrecy,\n                'requires_certificate_transparency' : requires_certificate_transparency\n            };\n        });\n    },\n    /* Get all the allow-intent tags */\n    getAllowIntents: function() {\n        var allow_intents = this.doc.findall('./allow-intent');\n        return allow_intents.map(function(allow_intent){\n            return {\n                'href': allow_intent.attrib.href\n            };\n        });\n    },\n    /* Get all edit-config tags */\n    getEditConfigs: function(platform) {\n        var platform_tag = this.doc.find('./platform[@name=\"' + platform + '\"]');\n        var platform_edit_configs = platform_tag ? platform_tag.findall('edit-config') : [];\n\n        var edit_configs = this.doc.findall('edit-config').concat(platform_edit_configs);\n\n        return edit_configs.map(function(tag) {\n            var editConfig =\n                {\n                    file : tag.attrib['file'],\n                    target : tag.attrib['target'],\n                    mode : tag.attrib['mode'],\n                    id : 'config.xml',\n                    xmls : tag.getchildren()\n                };\n            return editConfig;\n        });\n    },\n    write:function() {\n        fs.writeFileSync(this.path, this.doc.write({indent: 4}), 'utf-8');\n    }\n};\n\nfunction featureToPlugin(featureElement) {\n    var plugin = {};\n    plugin.variables = [];\n    var pluginVersion,\n        pluginSrc;\n\n    var nodes = featureElement.findall('param');\n    nodes.forEach(function (element) {\n        var n = element.attrib.name;\n        var v = element.attrib.value;\n        if (n === 'id') {\n            plugin.name = v;\n        } else if (n === 'version') {\n            pluginVersion = v;\n        } else if (n === 'url' || n === 'installPath') {\n            pluginSrc = v;\n        } else {\n            plugin.variables[n] = v;\n        }\n    });\n\n    var spec = pluginSrc || pluginVersion;\n    if (spec) {\n        plugin.spec = spec;\n    }\n\n    return plugin;\n}\nmodule.exports = ConfigParser;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/PlatformJson.js":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n/* jshint sub:true */\n\nvar fs = require('fs');\nvar path = require('path');\nvar shelljs = require('shelljs');\nvar mungeutil = require('./ConfigChanges/munge-util');\nvar pluginMappernto = require('cordova-registry-mapper').newToOld;\nvar pluginMapperotn = require('cordova-registry-mapper').oldToNew;\n\nfunction PlatformJson(filePath, platform, root) {\n    this.filePath = filePath;\n    this.platform = platform;\n    this.root = fix_munge(root || {});\n}\n\nPlatformJson.load = function(plugins_dir, platform) {\n    var filePath = path.join(plugins_dir, platform + '.json');\n    var root = null;\n    if (fs.existsSync(filePath)) {\n        root = JSON.parse(fs.readFileSync(filePath, 'utf-8'));\n    }\n    return new PlatformJson(filePath, platform, root);\n};\n\nPlatformJson.prototype.save = function() {\n    shelljs.mkdir('-p', path.dirname(this.filePath));\n    fs.writeFileSync(this.filePath, JSON.stringify(this.root, null, 4), 'utf-8');\n};\n\n/**\n * Indicates whether the specified plugin is installed as a top-level (not as\n *  dependency to others)\n * @method function\n * @param  {String} pluginId A plugin id to check for.\n * @return {Boolean} true if plugin installed as top-level, otherwise false.\n */\nPlatformJson.prototype.isPluginTopLevel = function(pluginId) {\n    var installedPlugins = this.root.installed_plugins;\n    return installedPlugins[pluginId] ||\n        installedPlugins[pluginMappernto[pluginId]] ||\n        installedPlugins[pluginMapperotn[pluginId]];\n};\n\n/**\n * Indicates whether the specified plugin is installed as a dependency to other\n *  plugin.\n * @method function\n * @param  {String} pluginId A plugin id to check for.\n * @return {Boolean} true if plugin installed as a dependency, otherwise false.\n */\nPlatformJson.prototype.isPluginDependent = function(pluginId) {\n    var dependentPlugins = this.root.dependent_plugins;\n    return dependentPlugins[pluginId] ||\n        dependentPlugins[pluginMappernto[pluginId]] ||\n        dependentPlugins[pluginMapperotn[pluginId]];\n};\n\n/**\n * Indicates whether plugin is installed either as top-level or as dependency.\n * @method function\n * @param  {String} pluginId A plugin id to check for.\n * @return {Boolean} true if plugin installed, otherwise false.\n */\nPlatformJson.prototype.isPluginInstalled = function(pluginId) {\n    return this.isPluginTopLevel(pluginId) ||\n        this.isPluginDependent(pluginId);\n};\n\nPlatformJson.prototype.addPlugin = function(pluginId, variables, isTopLevel) {\n    var pluginsList = isTopLevel ?\n        this.root.installed_plugins :\n        this.root.dependent_plugins;\n\n    pluginsList[pluginId] = variables;\n\n    return this;\n};\n\n/**\n * @chaining\n * Generates and adds metadata for provided plugin into associated <platform>.json file\n *\n * @param   {PluginInfo}  pluginInfo  A pluginInfo instance to add metadata from\n * @returns {this} Current PlatformJson instance to allow calls chaining\n */\nPlatformJson.prototype.addPluginMetadata = function (pluginInfo) {\n\n    var installedModules = this.root.modules || [];\n\n    var installedPaths = installedModules.map(function (installedModule) {\n        return installedModule.file;\n    });\n\n    var modulesToInstall = pluginInfo.getJsModules(this.platform)\n    .map(function (module) {\n        return new ModuleMetadata(pluginInfo.id, module);\n    })\n    .filter(function (metadata) {\n        // Filter out modules which are already added to metadata\n        return installedPaths.indexOf(metadata.file) === -1;\n    });\n\n    this.root.modules = installedModules.concat(modulesToInstall);\n\n    this.root.plugin_metadata = this.root.plugin_metadata || {};\n    this.root.plugin_metadata[pluginInfo.id] = pluginInfo.version;\n\n    return this;\n};\n\nPlatformJson.prototype.removePlugin = function(pluginId, isTopLevel) {\n    var pluginsList = isTopLevel ?\n        this.root.installed_plugins :\n        this.root.dependent_plugins;\n\n    delete pluginsList[pluginId];\n\n    return this;\n};\n\n/**\n * @chaining\n * Removes metadata for provided plugin from associated file\n *\n * @param   {PluginInfo}  pluginInfo A PluginInfo instance to which modules' metadata\n *   we need to remove\n *\n * @returns {this} Current PlatformJson instance to allow calls chaining\n */\nPlatformJson.prototype.removePluginMetadata = function (pluginInfo) {\n    var modulesToRemove = pluginInfo.getJsModules(this.platform)\n    .map(function (jsModule) {\n        return  ['plugins', pluginInfo.id, jsModule.src].join('/');\n    });\n\n    var installedModules = this.root.modules || [];\n    this.root.modules = installedModules\n    .filter(function (installedModule) {\n        // Leave only those metadatas which 'file' is not in removed modules\n        return (modulesToRemove.indexOf(installedModule.file) === -1);\n    });\n\n    if (this.root.plugin_metadata) {\n        delete this.root.plugin_metadata[pluginInfo.id];\n    }\n\n    return this;\n};\n\nPlatformJson.prototype.addInstalledPluginToPrepareQueue = function(pluginDirName, vars, is_top_level, force) {\n    this.root.prepare_queue.installed.push({'plugin':pluginDirName, 'vars':vars, 'topLevel':is_top_level, 'force':force});\n};\n\nPlatformJson.prototype.addUninstalledPluginToPrepareQueue = function(pluginId, is_top_level) {\n    this.root.prepare_queue.uninstalled.push({'plugin':pluginId, 'id':pluginId, 'topLevel':is_top_level});\n};\n\n/**\n * Moves plugin, specified by id to top-level plugins. If plugin is top-level\n *  already, then does nothing.\n * @method function\n * @param  {String} pluginId A plugin id to make top-level.\n * @return {PlatformJson} PlatformJson instance.\n */\nPlatformJson.prototype.makeTopLevel = function(pluginId) {\n    var plugin = this.root.dependent_plugins[pluginId];\n    if (plugin) {\n        delete this.root.dependent_plugins[pluginId];\n        this.root.installed_plugins[pluginId] = plugin;\n    }\n    return this;\n};\n\n/**\n * Generates a metadata for all installed plugins and js modules. The resultant\n *   string is ready to be written to 'cordova_plugins.js'\n *\n * @returns {String} cordova_plugins.js contents\n */\nPlatformJson.prototype.generateMetadata = function () {\n    return [\n        'cordova.define(\\'cordova/plugin_list\\', function(require, exports, module) {',\n        'module.exports = ' + JSON.stringify(this.root.modules, null, 4) + ';',\n        'module.exports.metadata = ',\n        '// TOP OF METADATA',\n        JSON.stringify(this.root.plugin_metadata, null, 4) + ';',\n        '// BOTTOM OF METADATA',\n        '});' // Close cordova.define.\n    ].join('\\n');\n};\n\n/**\n * @chaining\n * Generates and then saves metadata to specified file. Doesn't check if file exists.\n *\n * @param {String} destination  File metadata will be written to\n * @return {PlatformJson} PlatformJson instance\n */\nPlatformJson.prototype.generateAndSaveMetadata = function (destination) {\n    var meta = this.generateMetadata();\n    shelljs.mkdir('-p', path.dirname(destination));\n    fs.writeFileSync(destination, meta, 'utf-8');\n\n    return this;\n};\n\n// convert a munge from the old format ([file][parent][xml] = count) to the current one\nfunction fix_munge(root) {\n    root.prepare_queue = root.prepare_queue || {installed:[], uninstalled:[]};\n    root.config_munge = root.config_munge || {files: {}};\n    root.installed_plugins = root.installed_plugins || {};\n    root.dependent_plugins = root.dependent_plugins || {};\n\n    var munge = root.config_munge;\n    if (!munge.files) {\n        var new_munge = { files: {} };\n        for (var file in munge) {\n            for (var selector in munge[file]) {\n                for (var xml_child in munge[file][selector]) {\n                    var val = parseInt(munge[file][selector][xml_child]);\n                    for (var i = 0; i < val; i++) {\n                        mungeutil.deep_add(new_munge, [file, selector, { xml: xml_child, count: val }]);\n                    }\n                }\n            }\n        }\n        root.config_munge = new_munge;\n    }\n\n    return root;\n}\n\n/**\n * @constructor\n * @class ModuleMetadata\n *\n * Creates a ModuleMetadata object that represents module entry in 'cordova_plugins.js'\n *   file at run time\n *\n * @param {String}  pluginId  Plugin id where this module installed from\n * @param (JsModule|Object)  jsModule  A js-module entry from PluginInfo class to generate metadata for\n */\nfunction ModuleMetadata (pluginId, jsModule) {\n\n    if (!pluginId) throw new TypeError('pluginId argument must be a valid plugin id');\n    if (!jsModule.src && !jsModule.name) throw new TypeError('jsModule argument must contain src or/and name properties');\n\n    this.id  = pluginId + '.' + ( jsModule.name || jsModule.src.match(/([^\\/]+)\\.js/)[1] );\n    this.file = ['plugins', pluginId, jsModule.src].join('/');\n    this.pluginId = pluginId;\n\n    if (jsModule.clobbers && jsModule.clobbers.length > 0) {\n        this.clobbers = jsModule.clobbers.map(function(o) { return o.target; });\n    }\n    if (jsModule.merges && jsModule.merges.length > 0) {\n        this.merges = jsModule.merges.map(function(o) { return o.target; });\n    }\n    if (jsModule.runs) {\n        this.runs = true;\n    }\n}\n\nmodule.exports = PlatformJson;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/ConfigChanges/munge-util.js":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n/* jshint sub:true  */\n\nvar _ = require('underscore');\n\n// add the count of [key1][key2]...[keyN] to obj\n// return true if it didn't exist before\nexports.deep_add = function deep_add(obj, keys /* or key1, key2 .... */ ) {\n    if ( !Array.isArray(keys) ) {\n        keys = Array.prototype.slice.call(arguments, 1);\n    }\n\n    return exports.process_munge(obj, true/*createParents*/, function (parentArray, k) {\n        var found = _.find(parentArray, function(element) {\n            return element.xml == k.xml;\n        });\n        if (found) {\n            found.after = found.after || k.after;\n            found.count += k.count;\n        } else {\n            parentArray.push(k);\n        }\n        return !found;\n    }, keys);\n};\n\n// decrement the count of [key1][key2]...[keyN] from obj and remove if it reaches 0\n// return true if it was removed or not found\nexports.deep_remove = function deep_remove(obj, keys /* or key1, key2 .... */ ) {\n    if ( !Array.isArray(keys) ) {\n        keys = Array.prototype.slice.call(arguments, 1);\n    }\n\n    var result = exports.process_munge(obj, false/*createParents*/, function (parentArray, k) {\n        var index = -1;\n        var found = _.find(parentArray, function (element) {\n            index++;\n            return element.xml == k.xml;\n        });\n        if (found) {\n            if (parentArray[index].oldAttrib) {\n                k.oldAttrib = _.extend({}, parentArray[index].oldAttrib);\n            }\n            found.count -= k.count;\n            if (found.count > 0) {\n                return false;\n            }\n            else {\n                parentArray.splice(index, 1);\n            }\n        }\n        return undefined;\n    }, keys);\n\n    return typeof result === 'undefined' ? true : result;\n};\n\n// search for [key1][key2]...[keyN]\n// return the object or undefined if not found\nexports.deep_find = function deep_find(obj, keys /* or key1, key2 .... */ ) {\n    if ( !Array.isArray(keys) ) {\n        keys = Array.prototype.slice.call(arguments, 1);\n    }\n\n    return exports.process_munge(obj, false/*createParents?*/, function (parentArray, k) {\n        return _.find(parentArray, function (element) {\n            return element.xml == (k.xml || k);\n        });\n    }, keys);\n};\n\n// Execute func passing it the parent array and the xmlChild key.\n// When createParents is true, add the file and parent items  they are missing\n// When createParents is false, stop and return undefined if the file and/or parent items are missing\n\nexports.process_munge = function process_munge(obj, createParents, func, keys /* or key1, key2 .... */ ) {\n    if ( !Array.isArray(keys) ) {\n        keys = Array.prototype.slice.call(arguments, 1);\n    }\n    var k = keys[0];\n    if (keys.length == 1) {\n        return func(obj, k);\n    } else if (keys.length == 2) {\n        if (!obj.parents[k] && !createParents) {\n            return undefined;\n        }\n        obj.parents[k] = obj.parents[k] || [];\n        return exports.process_munge(obj.parents[k], createParents, func, keys.slice(1));\n    } else if (keys.length == 3){\n        if (!obj.files[k] && !createParents) {\n            return undefined;\n        }\n        obj.files[k] = obj.files[k] || { parents: {} };\n        return exports.process_munge(obj.files[k], createParents, func, keys.slice(1));\n    } else {\n        throw new Error('Invalid key format. Must contain at most 3 elements (file, parent, xmlChild).');\n    }\n};\n\n// All values from munge are added to base as\n// base[file][selector][child] += munge[file][selector][child]\n// Returns a munge object containing values that exist in munge\n// but not in base.\nexports.increment_munge = function increment_munge(base, munge) {\n    var diff = { files: {} };\n\n    for (var file in munge.files) {\n        for (var selector in munge.files[file].parents) {\n            for (var xml_child in munge.files[file].parents[selector]) {\n                var val = munge.files[file].parents[selector][xml_child];\n                // if node not in base, add it to diff and base\n                // else increment it's value in base without adding to diff\n                var newlyAdded = exports.deep_add(base, [file, selector, val]);\n                if (newlyAdded) {\n                    exports.deep_add(diff, file, selector, val);\n                }\n            }\n        }\n    }\n    return diff;\n};\n\n// Update the base munge object as\n// base[file][selector][child] -= munge[file][selector][child]\n// nodes that reached zero value are removed from base and added to the returned munge\n// object.\nexports.decrement_munge = function decrement_munge(base, munge) {\n    var zeroed = { files: {} };\n\n    for (var file in munge.files) {\n        for (var selector in munge.files[file].parents) {\n            for (var xml_child in munge.files[file].parents[selector]) {\n                var val = munge.files[file].parents[selector][xml_child];\n                // if node not in base, add it to diff and base\n                // else increment it's value in base without adding to diff\n                var removed = exports.deep_remove(base, [file, selector, val]);\n                if (removed) {\n                    exports.deep_add(zeroed, file, selector, val);\n                }\n            }\n        }\n    }\n    return zeroed;\n};\n\n// For better readability where used\nexports.clone_munge = function clone_munge(munge) {\n    return exports.increment_munge({}, munge);\n};\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/PluginInfo/PluginInfoProvider.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint sub:true, laxcomma:true, laxbreak:true */\n\nvar fs = require('fs');\nvar path = require('path');\nvar PluginInfo = require('./PluginInfo');\nvar events = require('../events');\n\nfunction PluginInfoProvider() {\n    this._cache = {};\n    this._getAllCache = {};\n}\n\nPluginInfoProvider.prototype.get = function(dirName) {\n    var absPath = path.resolve(dirName);\n    if (!this._cache[absPath]) {\n        this._cache[absPath] = new PluginInfo(dirName);\n    }\n    return this._cache[absPath];\n};\n\n// Normally you don't need to put() entries, but it's used\n// when copying plugins, and in unit tests.\nPluginInfoProvider.prototype.put = function(pluginInfo) {\n    var absPath = path.resolve(pluginInfo.dir);\n    this._cache[absPath] = pluginInfo;\n};\n\n// Used for plugin search path processing.\n// Given a dir containing multiple plugins, create a PluginInfo object for\n// each of them and return as array.\n// Should load them all in parallel and return a promise, but not yet.\nPluginInfoProvider.prototype.getAllWithinSearchPath = function(dirName) {\n    var absPath = path.resolve(dirName);\n    if (!this._getAllCache[absPath]) {\n        this._getAllCache[absPath] = getAllHelper(absPath, this);\n    }\n    return this._getAllCache[absPath];\n};\n\nfunction getAllHelper(absPath, provider) {\n    if (!fs.existsSync(absPath)){\n        return [];\n    }\n    // If dir itself is a plugin, return it in an array with one element.\n    if (fs.existsSync(path.join(absPath, 'plugin.xml'))) {\n        return [provider.get(absPath)];\n    }\n    var subdirs = fs.readdirSync(absPath);\n    var plugins = [];\n    subdirs.forEach(function(subdir) {\n        var d = path.join(absPath, subdir);\n        if (fs.existsSync(path.join(d, 'plugin.xml'))) {\n            try {\n                plugins.push(provider.get(d));\n            } catch (e) {\n                events.emit('warn', 'Error parsing ' + path.join(d, 'plugin.xml.\\n' + e.stack));\n            }\n        }\n    });\n    return plugins;\n}\n\nmodule.exports = PluginInfoProvider;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/ConfigChanges/ConfigChanges.js":"/*\n *\n * Copyright 2013 Anis Kadri\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/*\n * This module deals with shared configuration / dependency \"stuff\". That is:\n * - XML configuration files such as config.xml, AndroidManifest.xml or WMAppManifest.xml.\n * - plist files in iOS\n * Essentially, any type of shared resources that we need to handle with awareness\n * of how potentially multiple plugins depend on a single shared resource, should be\n * handled in this module.\n *\n * The implementation uses an object as a hash table, with \"leaves\" of the table tracking\n * reference counts.\n */\n\n/* jshint sub:true */\n\nvar fs   = require('fs'),\n    path = require('path'),\n    et   = require('elementtree'),\n    semver = require('semver'),\n    events = require('../events'),\n    ConfigKeeper = require('./ConfigKeeper'),\n    CordovaLogger = require('../CordovaLogger');\n\nvar mungeutil = require('./munge-util');\nvar xml_helpers = require('../util/xml-helpers');\n\nexports.PlatformMunger = PlatformMunger;\n\nexports.process = function(plugins_dir, project_dir, platform, platformJson, pluginInfoProvider) {\n    var munger = new PlatformMunger(platform, project_dir, platformJson, pluginInfoProvider);\n    munger.process(plugins_dir);\n    munger.save_all();\n};\n\n/******************************************************************************\n* PlatformMunger class\n*\n* Can deal with config file of a single project.\n* Parsed config files are cached in a ConfigKeeper object.\n******************************************************************************/\nfunction PlatformMunger(platform, project_dir, platformJson, pluginInfoProvider) {\n    this.platform = platform;\n    this.project_dir = project_dir;\n    this.config_keeper = new ConfigKeeper(project_dir);\n    this.platformJson = platformJson;\n    this.pluginInfoProvider = pluginInfoProvider;\n}\n\n// Write out all unsaved files.\nPlatformMunger.prototype.save_all = PlatformMunger_save_all;\nfunction PlatformMunger_save_all() {\n    this.config_keeper.save_all();\n    this.platformJson.save();\n}\n\n// Apply a munge object to a single config file.\n// The remove parameter tells whether to add the change or remove it.\nPlatformMunger.prototype.apply_file_munge = PlatformMunger_apply_file_munge;\nfunction PlatformMunger_apply_file_munge(file, munge, remove) {\n    var self = this;\n\n    for (var selector in munge.parents) {\n        for (var xml_child in munge.parents[selector]) {\n            // this xml child is new, graft it (only if config file exists)\n            var config_file = self.config_keeper.get(self.project_dir, self.platform, file);\n            if (config_file.exists) {\n                if (remove) config_file.prune_child(selector, munge.parents[selector][xml_child]);\n                else config_file.graft_child(selector, munge.parents[selector][xml_child]);\n            }\n        }\n    }\n}\n\n\nPlatformMunger.prototype.remove_plugin_changes = remove_plugin_changes;\nfunction remove_plugin_changes(pluginInfo, is_top_level) {\n    var self = this;\n    var platform_config = self.platformJson.root;\n    var plugin_vars = is_top_level ?\n        platform_config.installed_plugins[pluginInfo.id] :\n        platform_config.dependent_plugins[pluginInfo.id];\n    var edit_config_changes = null;\n    if(pluginInfo.getEditConfigs) {\n        edit_config_changes = pluginInfo.getEditConfigs(self.platform);\n    }\n\n    // get config munge, aka how did this plugin change various config files\n    var config_munge = self.generate_plugin_config_munge(pluginInfo, plugin_vars, edit_config_changes);\n    // global munge looks at all plugins' changes to config files\n    var global_munge = platform_config.config_munge;\n    var munge = mungeutil.decrement_munge(global_munge, config_munge);\n\n    for (var file in munge.files) {\n        // CB-6976 Windows Universal Apps. Compatibility fix for existing plugins.\n        if (self.platform == 'windows' && file == 'package.appxmanifest' &&\n            !fs.existsSync(path.join(self.project_dir, 'package.appxmanifest'))) {\n            // New windows template separate manifest files for Windows10, Windows8.1 and WP8.1\n            var substs = ['package.phone.appxmanifest', 'package.windows.appxmanifest', 'package.windows10.appxmanifest'];\n            /* jshint loopfunc:true */\n            substs.forEach(function(subst) {\n                events.emit('verbose', 'Applying munge to ' + subst);\n                self.apply_file_munge(subst, munge.files[file], true);\n            });\n            /* jshint loopfunc:false */\n        }\n        self.apply_file_munge(file, munge.files[file], /* remove = */ true);\n    }\n\n    // Remove from installed_plugins\n    self.platformJson.removePlugin(pluginInfo.id, is_top_level);\n    return self;\n}\n\n\nPlatformMunger.prototype.add_plugin_changes = add_plugin_changes;\nfunction add_plugin_changes(pluginInfo, plugin_vars, is_top_level, should_increment, plugin_force) {\n    var self = this;\n    var platform_config = self.platformJson.root;\n\n    var edit_config_changes = null;\n    if(pluginInfo.getEditConfigs) {\n        edit_config_changes = pluginInfo.getEditConfigs(self.platform);\n    }\n\n    var config_munge;\n\n    if (!edit_config_changes || edit_config_changes.length === 0) {\n        // get config munge, aka how should this plugin change various config files\n        config_munge = self.generate_plugin_config_munge(pluginInfo, plugin_vars);\n    }\n    else {\n        var isConflictingInfo = is_conflicting(edit_config_changes, platform_config.config_munge, self, plugin_force);\n\n        if (isConflictingInfo.conflictWithConfigxml) {\n            throw new Error(pluginInfo.id +\n                ' cannot be added. <edit-config> changes in this plugin conflicts with <edit-config> changes in config.xml. Conflicts must be resolved before plugin can be added.');\n        }\n        if (plugin_force) {\n            CordovaLogger.get().log(CordovaLogger.WARN, '--force is used. edit-config will overwrite conflicts if any. Conflicting plugins may not work as expected.');\n\n            // remove conflicting munges\n            var conflict_munge = mungeutil.decrement_munge(platform_config.config_munge, isConflictingInfo.conflictingMunge);\n            for (var conflict_file in conflict_munge.files) {\n                self.apply_file_munge(conflict_file, conflict_munge.files[conflict_file], /* remove = */ true);\n            }\n\n            // force add new munges\n            config_munge = self.generate_plugin_config_munge(pluginInfo, plugin_vars, edit_config_changes);\n        }\n        else if(isConflictingInfo.conflictFound) {\n            throw new Error('There was a conflict trying to modify attributes with <edit-config> in plugin ' + pluginInfo.id +\n            '. The conflicting plugin, ' + isConflictingInfo.conflictingPlugin + ', already modified the same attributes. The conflict must be resolved before ' +\n            pluginInfo.id + ' can be added. You may use --force to add the plugin and overwrite the conflicting attributes.');\n        }\n        else {\n            // no conflicts, will handle edit-config\n            config_munge = self.generate_plugin_config_munge(pluginInfo, plugin_vars, edit_config_changes);\n        }\n    }\n\n    self = munge_helper(should_increment, self, platform_config, config_munge);\n\n    // Move to installed/dependent_plugins\n    self.platformJson.addPlugin(pluginInfo.id, plugin_vars || {}, is_top_level);\n    return self;\n}\n\n\n// Handle edit-config changes from config.xml\nPlatformMunger.prototype.add_config_changes = add_config_changes;\nfunction add_config_changes(config, should_increment) {\n    var self = this;\n    var platform_config = self.platformJson.root;\n\n    var config_munge;\n    var edit_config_changes = null;\n    if(config.getEditConfigs) {\n        edit_config_changes = config.getEditConfigs(self.platform);\n    }\n\n    if (!edit_config_changes || edit_config_changes.length === 0) {\n        // There are no edit-config changes to add, return here\n        return self;\n    }\n    else {\n        var isConflictingInfo = is_conflicting(edit_config_changes, platform_config.config_munge, self, true /*always force overwrite other edit-config*/);\n\n        if(isConflictingInfo.conflictFound) {\n            var conflict_munge;\n            var conflict_file;\n\n            if (Object.keys(isConflictingInfo.configxmlMunge.files).length !== 0) {\n                // silently remove conflicting config.xml munges so new munges can be added\n                conflict_munge = mungeutil.decrement_munge(platform_config.config_munge, isConflictingInfo.configxmlMunge);\n                for (conflict_file in conflict_munge.files) {\n                    self.apply_file_munge(conflict_file, conflict_munge.files[conflict_file], /* remove = */ true);\n                }\n            }\n            if (Object.keys(isConflictingInfo.conflictingMunge.files).length !== 0) {\n                CordovaLogger.get().log(CordovaLogger.WARN, 'Conflict found, edit-config changes from config.xml will overwrite plugin.xml changes');\n\n                // remove conflicting plugin.xml munges\n                conflict_munge = mungeutil.decrement_munge(platform_config.config_munge, isConflictingInfo.conflictingMunge);\n                for (conflict_file in conflict_munge.files) {\n                    self.apply_file_munge(conflict_file, conflict_munge.files[conflict_file], /* remove = */ true);\n                }\n            }\n        }\n        // Add config.xml edit-config munges\n        config_munge = self.generate_config_xml_munge(config, edit_config_changes, 'config.xml');\n    }\n\n    self = munge_helper(should_increment, self, platform_config, config_munge);\n\n    // Move to installed/dependent_plugins\n    return self;\n}\n\nfunction munge_helper(should_increment, self, platform_config, config_munge) {\n    // global munge looks at all changes to config files\n\n    // TODO: The should_increment param is only used by cordova-cli and is going away soon.\n    // If should_increment is set to false, avoid modifying the global_munge (use clone)\n    // and apply the entire config_munge because it's already a proper subset of the global_munge.\n    var munge, global_munge;\n    if (should_increment) {\n        global_munge = platform_config.config_munge;\n        munge = mungeutil.increment_munge(global_munge, config_munge);\n    } else {\n        global_munge = mungeutil.clone_munge(platform_config.config_munge);\n        munge = config_munge;\n    }\n\n    for (var file in munge.files) {\n        // CB-6976 Windows Universal Apps. Compatibility fix for existing plugins.\n        if (self.platform == 'windows' && file == 'package.appxmanifest' &&\n            !fs.existsSync(path.join(self.project_dir, 'package.appxmanifest'))) {\n            var substs = ['package.phone.appxmanifest', 'package.windows.appxmanifest', 'package.windows10.appxmanifest'];\n            /* jshint loopfunc:true */\n            substs.forEach(function(subst) {\n                events.emit('verbose', 'Applying munge to ' + subst);\n                self.apply_file_munge(subst, munge.files[file]);\n            });\n            /* jshint loopfunc:false */\n        }\n\n        self.apply_file_munge(file, munge.files[file]);\n    }\n\n    return self;\n}\n\n\n// Load the global munge from platform json and apply all of it.\n// Used by cordova prepare to re-generate some config file from platform\n// defaults and the global munge.\nPlatformMunger.prototype.reapply_global_munge = reapply_global_munge ;\nfunction reapply_global_munge () {\n    var self = this;\n\n    var platform_config = self.platformJson.root;\n    var global_munge = platform_config.config_munge;\n    for (var file in global_munge.files) {\n        self.apply_file_munge(file, global_munge.files[file]);\n    }\n\n    return self;\n}\n\n// generate_plugin_config_munge\n// Generate the munge object from config.xml\nPlatformMunger.prototype.generate_config_xml_munge = generate_config_xml_munge;\nfunction generate_config_xml_munge(config, edit_config_changes, type) {\n\n    var munge = { files: {} };\n    var changes = edit_config_changes;\n    var id;\n\n    if(!changes) {\n        return munge;\n    }\n\n    if (type === 'config.xml') {\n        id = type;\n    }\n    else {\n        id = config.id;\n    }\n\n    changes.forEach(function(change) {\n        change.xmls.forEach(function(xml) {\n            // 1. stringify each xml\n            var stringified = (new et.ElementTree(xml)).write({xml_declaration:false});\n            // 2. add into munge\n            if (change.mode) {\n                mungeutil.deep_add(munge, change.file, change.target, { xml: stringified, count: 1, mode: change.mode, id: id });\n            }\n        });\n    });\n    return munge;\n}\n\n\n// generate_plugin_config_munge\n// Generate the munge object from plugin.xml + vars\nPlatformMunger.prototype.generate_plugin_config_munge = generate_plugin_config_munge;\nfunction generate_plugin_config_munge(pluginInfo, vars, edit_config_changes) {\n    var self = this;\n\n    vars = vars || {};\n    var munge = { files: {} };\n    var changes = pluginInfo.getConfigFiles(self.platform);\n\n    if(edit_config_changes) {\n        Array.prototype.push.apply(changes, edit_config_changes);\n    }\n\n    // Demux 'package.appxmanifest' into relevant platform-specific appx manifests.\n    // Only spend the cycles if there are version-specific plugin settings\n    if (self.platform === 'windows' &&\n            changes.some(function(change) {\n                return ((typeof change.versions !== 'undefined') ||\n                    (typeof change.deviceTarget !== 'undefined'));\n            }))\n    {\n        var manifests = {\n            'windows': {\n                '8.1.0': 'package.windows.appxmanifest',\n                '10.0.0': 'package.windows10.appxmanifest'\n            },\n            'phone': {\n                '8.1.0': 'package.phone.appxmanifest',\n                '10.0.0': 'package.windows10.appxmanifest'\n            },\n            'all': {\n                '8.1.0': ['package.windows.appxmanifest', 'package.phone.appxmanifest'],\n                '10.0.0': 'package.windows10.appxmanifest'\n            }\n        };\n\n        var oldChanges = changes;\n        changes = [];\n\n        oldChanges.forEach(function(change, changeIndex) {\n            // Only support semver/device-target demux for package.appxmanifest\n            // Pass through in case something downstream wants to use it\n            if (change.target !== 'package.appxmanifest') {\n                changes.push(change);\n                return;\n            }\n\n            var hasVersion = (typeof change.versions !== 'undefined');\n            var hasTargets = (typeof change.deviceTarget !== 'undefined');\n\n            // No semver/device-target for this config-file, pass it through\n            if (!(hasVersion || hasTargets)) {\n                changes.push(change);\n                return;\n            }\n\n            var targetDeviceSet = hasTargets ? change.deviceTarget : 'all';\n            if (['windows', 'phone', 'all'].indexOf(targetDeviceSet) === -1) {\n                // target-device couldn't be resolved, fix it up here to a valid value\n                targetDeviceSet = 'all';\n            }\n            var knownWindowsVersionsForTargetDeviceSet = Object.keys(manifests[targetDeviceSet]);\n\n            // at this point, 'change' targets package.appxmanifest and has a version attribute\n            knownWindowsVersionsForTargetDeviceSet.forEach(function(winver) {\n                // This is a local function that creates the new replacement representing the\n                // mutation.  Used to save code further down.\n                var createReplacement = function(manifestFile, originalChange) {\n                    var replacement = {\n                        target:         manifestFile,\n                        parent:         originalChange.parent,\n                        after:          originalChange.after,\n                        xmls:           originalChange.xmls,\n                        versions:       originalChange.versions,\n                        deviceTarget:   originalChange.deviceTarget\n                    };\n                    return replacement;\n                };\n\n                // version doesn't satisfy, so skip\n                if (hasVersion && !semver.satisfies(winver, change.versions)) {\n                    return;\n                }\n\n                var versionSpecificManifests = manifests[targetDeviceSet][winver];\n                if (versionSpecificManifests.constructor === Array) {\n                    // e.g. all['8.1.0'] === ['pkg.windows.appxmanifest', 'pkg.phone.appxmanifest']\n                    versionSpecificManifests.forEach(function(manifestFile) {\n                        changes.push(createReplacement(manifestFile, change));\n                    });\n                }\n                else {\n                    // versionSpecificManifests is actually a single string\n                    changes.push(createReplacement(versionSpecificManifests, change));\n                }\n            });\n        });\n    }\n\n    changes.forEach(function(change) {\n        change.xmls.forEach(function(xml) {\n            // 1. stringify each xml\n            var stringified = (new et.ElementTree(xml)).write({xml_declaration:false});\n            // interp vars\n            if (vars) {\n                Object.keys(vars).forEach(function(key) {\n                    var regExp = new RegExp('\\\\$' + key, 'g');\n                    stringified = stringified.replace(regExp, vars[key]);\n                });\n            }\n            // 2. add into munge\n            if (change.mode) {\n                if (change.mode !== 'remove') {\n                    mungeutil.deep_add(munge, change.file, change.target, { xml: stringified, count: 1, mode: change.mode, plugin: pluginInfo.id });\n                }\n            }\n            else {\n                mungeutil.deep_add(munge, change.target, change.parent, { xml: stringified, count: 1, after: change.after });\n            }\n        });\n    });\n    return munge;\n}\n\nfunction is_conflicting(editchanges, config_munge, self, force) {\n    var files = config_munge.files;\n    var conflictFound = false;\n    var conflictWithConfigxml = false;\n    var conflictingMunge = { files: {} };\n    var configxmlMunge = { files: {} };\n    var conflictingParent;\n    var conflictingPlugin;\n\n    editchanges.forEach(function(editchange) {\n        if (files[editchange.file]) {\n            var parents = files[editchange.file].parents;\n            var target = parents[editchange.target];\n\n            // Check if the edit target will resolve to an existing target\n            if (!target || target.length === 0) {\n                var file_xml = self.config_keeper.get(self.project_dir, self.platform, editchange.file).data;\n                var resolveEditTarget = xml_helpers.resolveParent(file_xml, editchange.target);\n                var resolveTarget;\n\n                if (resolveEditTarget) {\n                    for (var parent in parents) {\n                        resolveTarget = xml_helpers.resolveParent(file_xml, parent);\n                        if (resolveEditTarget === resolveTarget) {\n                            conflictingParent = parent;\n                            target = parents[parent];\n                            break;\n                        }\n                    }\n                }\n            }\n            else {\n                conflictingParent = editchange.target;\n            }\n\n            if (target && target.length !== 0) {\n                // conflict has been found\n                conflictFound = true;\n\n                if (editchange.id === 'config.xml') {\n                    if (target[0].id === 'config.xml') {\n                        // Keep track of config.xml/config.xml edit-config conflicts\n                        mungeutil.deep_add(configxmlMunge, editchange.file, conflictingParent, target[0]);\n                    }\n                    else {\n                        // Keep track of config.xml x plugin.xml edit-config conflicts\n                        mungeutil.deep_add(conflictingMunge, editchange.file, conflictingParent, target[0]);\n                    }\n                }\n                else {\n                    if (target[0].id === 'config.xml') {\n                        // plugin.xml cannot overwrite config.xml changes even if --force is used\n                        conflictWithConfigxml = true;\n                        return;\n                    }\n\n                    if (force) {\n                        // Need to find all conflicts when --force is used, track conflicting munges\n                        mungeutil.deep_add(conflictingMunge, editchange.file, conflictingParent, target[0]);\n                    }\n                    else {\n                        // plugin cannot overwrite other plugin changes without --force\n                        conflictingPlugin = target[0].plugin;\n                        return;\n                    }\n                }\n            }\n        }\n    });\n\n    return {conflictFound: conflictFound, conflictingPlugin: conflictingPlugin, conflictingMunge: conflictingMunge,\n        configxmlMunge: configxmlMunge, conflictWithConfigxml:conflictWithConfigxml};\n}\n\n// Go over the prepare queue and apply the config munges for each plugin\n// that has been (un)installed.\nPlatformMunger.prototype.process = PlatformMunger_process;\nfunction PlatformMunger_process(plugins_dir) {\n    var self = this;\n    var platform_config = self.platformJson.root;\n\n    // Uninstallation first\n    platform_config.prepare_queue.uninstalled.forEach(function(u) {\n        var pluginInfo = self.pluginInfoProvider.get(path.join(plugins_dir, u.plugin));\n        self.remove_plugin_changes(pluginInfo, u.topLevel);\n    });\n\n    // Now handle installation\n    platform_config.prepare_queue.installed.forEach(function(u) {\n        var pluginInfo = self.pluginInfoProvider.get(path.join(plugins_dir, u.plugin));\n        self.add_plugin_changes(pluginInfo, u.vars, u.topLevel, true, u.force);\n    });\n\n    // Empty out installed/ uninstalled queues.\n    platform_config.prepare_queue.uninstalled = [];\n    platform_config.prepare_queue.installed = [];\n}\n/**** END of PlatformMunger ****/\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/node_modules/semver/semver.js":"exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return compare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/ConfigChanges/ConfigKeeper.js":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n/* jshint sub:true */\n\nvar path = require('path');\nvar ConfigFile = require('./ConfigFile');\n\n/******************************************************************************\n* ConfigKeeper class\n*\n* Used to load and store config files to avoid re-parsing and writing them out\n* multiple times.\n*\n* The config files are referred to by a fake path constructed as\n* project_dir/platform/file\n* where file is the name used for the file in config munges.\n******************************************************************************/\nfunction ConfigKeeper(project_dir, plugins_dir) {\n    this.project_dir = project_dir;\n    this.plugins_dir = plugins_dir;\n    this._cached = {};\n}\n\nConfigKeeper.prototype.get = function ConfigKeeper_get(project_dir, platform, file) {\n    var self = this;\n\n    // This fixes a bug with older plugins - when specifying config xml instead of res/xml/config.xml\n    // https://issues.apache.org/jira/browse/CB-6414\n    if(file == 'config.xml' && platform == 'android'){\n        file = 'res/xml/config.xml';\n    }else if(file.indexOf('.xml') > -1 && platform == 'ios') {\n        file = path.join('Resources', 'WeexpluginConfig.xml');\n    }\n    var fake_path = path.join(project_dir, platform, file);\n\n    if (self._cached[fake_path]) {\n        return self._cached[fake_path];\n    }\n    // File was not cached, need to load.\n    var config_file = new ConfigFile(project_dir, platform, file);\n    self._cached[fake_path] = config_file;\n    return config_file;\n};\n\n\nConfigKeeper.prototype.save_all = function ConfigKeeper_save_all() {\n    var self = this;\n    Object.keys(self._cached).forEach(function (fake_path) {\n        var config_file = self._cached[fake_path];\n        if (config_file.is_changed) config_file.save();\n    });\n};\n\nmodule.exports = ConfigKeeper;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/ConfigChanges/ConfigFile.js":"/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar modules = {};\nvar addProperty = require('../util/addProperty');\n\n// Use delay loading to ensure plist and other node modules to not get loaded\n// on Android, Windows platforms\naddProperty(module, 'bplist', 'bplist-parser', modules);\naddProperty(module, 'et', 'elementtree', modules);\naddProperty(module, 'glob', 'glob', modules);\naddProperty(module, 'plist', 'plist', modules);\naddProperty(module, 'plist_helpers', '../util/plist-helpers', modules);\naddProperty(module, 'xml_helpers', '../util/xml-helpers', modules);\n\n/******************************************************************************\n* ConfigFile class\n*\n* Can load and keep various types of config files. Provides some functionality\n* specific to some file types such as grafting XML children. In most cases it\n* should be instantiated by ConfigKeeper.\n*\n* For plugin.xml files use as:\n* plugin_config = self.config_keeper.get(plugin_dir, '', 'plugin.xml');\n*\n* TODO: Consider moving it out to a separate file and maybe partially with\n* overrides in platform handlers.\n******************************************************************************/\nfunction ConfigFile(project_dir, platform, file_tag) {\n    this.project_dir = project_dir;\n    this.platform = platform;\n    this.file_tag = file_tag;\n    this.is_changed = false;\n\n    this.load();\n}\n\n// ConfigFile.load()\nConfigFile.prototype.load = ConfigFile_load;\nfunction ConfigFile_load() {\n    var self = this;\n\n    // config file may be in a place not exactly specified in the target\n    var filepath = self.filepath = resolveConfigFilePath(self.project_dir, self.platform, self.file_tag);\n\n    if ( !filepath || !fs.existsSync(filepath) ) {\n        self.exists = false;\n        return;\n    }\n    self.exists = true;\n    self.mtime = fs.statSync(self.filepath).mtime;\n\n    var ext = path.extname(filepath);\n    // Windows8 uses an appxmanifest, and wp8 will likely use\n    // the same in a future release\n    if (ext == '.xml' || ext == '.appxmanifest') {\n        self.type = 'xml';\n        self.data = modules.xml_helpers.parseElementtreeSync(filepath);\n    } else {\n        // plist file\n        self.type = 'plist';\n        // TODO: isBinaryPlist() reads the file and then parse re-reads it again.\n        //       We always write out text plist, not binary.\n        //       Do we still need to support binary plist?\n        //       If yes, use plist.parseStringSync() and read the file once.\n        self.data = isBinaryPlist(filepath) ?\n                modules.bplist.parseBuffer(fs.readFileSync(filepath)) :\n                modules.plist.parse(fs.readFileSync(filepath, 'utf8'));\n    }\n}\n\nConfigFile.prototype.save = function ConfigFile_save() {\n    var self = this;\n    if (self.type === 'xml') {\n        fs.writeFileSync(self.filepath, self.data.write({indent: 4}), 'utf-8');\n    } else {\n        // plist\n        var regExp = new RegExp('<string>[ \\t\\r\\n]+?</string>', 'g');\n        fs.writeFileSync(self.filepath, modules.plist.build(self.data).replace(regExp, '<string></string>'));\n    }\n    self.is_changed = false;\n};\n\nConfigFile.prototype.graft_child = function ConfigFile_graft_child(selector, xml_child) {\n    var self = this;\n    var filepath = self.filepath;\n    var result;\n    if (self.type === 'xml') {\n        var xml_to_graft = [modules.et.XML(xml_child.xml)];\n        switch (xml_child.mode) {\n            case 'merge':\n                result = modules.xml_helpers.graftXMLMerge(self.data, xml_to_graft, selector, xml_child);\n                break;\n            case 'overwrite':\n                result = modules.xml_helpers.graftXMLOverwrite(self.data, xml_to_graft, selector, xml_child);\n                break;\n            case 'remove':\n                result= true;\n                break;\n            default:\n                result = modules.xml_helpers.graftXML(self.data, xml_to_graft, selector, xml_child.after);\n        }\n        if ( !result) {\n            throw new Error('Unable to graft xml at selector \"' + selector + '\" from \"' + filepath + '\" during config install');\n        }\n    } else {\n        // plist file\n        result = modules.plist_helpers.graftPLIST(self.data, xml_child.xml, selector);\n        if ( !result ) {\n            throw new Error('Unable to graft plist \"' + filepath + '\" during config install');\n        }\n    }\n    self.is_changed = true;\n};\n\nConfigFile.prototype.prune_child = function ConfigFile_prune_child(selector, xml_child) {\n    var self = this;\n    var filepath = self.filepath;\n    var result;\n    if (self.type === 'xml') {\n        var xml_to_graft = [modules.et.XML(xml_child.xml)];\n        switch (xml_child.mode) {\n            case 'merge':\n            case 'overwrite':\n                result = modules.xml_helpers.pruneXMLRestore(self.data, selector, xml_child);\n                break;\n            case 'remove':\n                result = modules.xml_helpers.prunXMLRemove(self.data, selector, xml_to_graft);\n                break;\n            default:\n                result = modules.xml_helpers.pruneXML(self.data, xml_to_graft, selector);\n        }\n    } else {\n        // plist file\n        result = modules.plist_helpers.prunePLIST(self.data, xml_child.xml, selector);\n    }\n    if (!result) {\n        var err_msg = 'Pruning at selector \"' + selector + '\" from \"' + filepath + '\" went bad.';\n        throw new Error(err_msg);\n    }\n    self.is_changed = true;\n};\n\n// Some config-file target attributes are not qualified with a full leading directory, or contain wildcards.\n// Resolve to a real path in this function.\n// TODO: getIOSProjectname is slow because of glob, try to avoid calling it several times per project.\nfunction resolveConfigFilePath(project_dir, platform, file) {\n    var filepath = path.join(project_dir, file);\n    var matches;\n\n\n    if (file.indexOf('*') > -1 && file.indexOf('plist') > -1) {\n        project_dir = path.join(project_dir);\n        // handle wildcards in targets using glob.\n        matches = modules.glob.sync(path.join(project_dir, '**', file));\n        if (matches.length) filepath = matches[0];\n        else {\n            project_dir = path.join(project_dir, '..');\n            // handle wildcards in targets using glob.\n            matches = modules.glob.sync(path.join(project_dir, '**', file));\n            if (matches.length) filepath = matches[0];\n        }\n\n        // [CB-5989] multiple Info.plist files may exist. default to $PROJECT_NAME-Info.plist\n        if(matches.length > 1 && file.indexOf('-Info.plist')>-1){\n            var plistName =  getIOSProjectname(project_dir)+'-Info.plist';\n            for (var i=0; i < matches.length; i++) {\n                if(matches[i].indexOf(plistName) > -1){\n                    filepath = matches[i];\n                    break;\n                }\n            }\n        }\n        return filepath;\n    }else if (platform === 'ios' && (file != 'config.xml' || file != 'WeexpluginConfig.xml')){\n        return filepath = path.join(project_dir, getIOSProjectname(project_dir), file);\n    }\n\n    // special-case config.xml target that is just \"config.xml\". This should be resolved to the real location of the file.\n    // TODO: move the logic that contains the locations of config.xml from cordova CLI into plugman.\n    if (file == 'config.xml') {\n        if (platform == 'ubuntu') {\n            filepath = path.join(project_dir, 'config.xml');\n        } else if (platform == 'ios') {\n            var iospath = getIOSProjectname(project_dir);\n            filepath = path.join(project_dir,iospath, 'config.xml');\n        } else if (platform == 'android') {\n            filepath = path.join(project_dir, 'res', 'xml', 'config.xml');\n        } else {\n            matches = modules.glob.sync(path.join(project_dir, '**', 'config.xml'));\n            if (matches.length) filepath = matches[0];\n        }\n        return filepath;\n    }\n\n    // XXX this checks for android studio projects\n    // only if none of the options above are satisfied does this get called\n    if(platform === 'android' && !fs.existsSync(filepath)) {\n      // WEEX_HOOK_START\n      if (file === 'AndroidManifest.xml') {\n          filepath = path.join(project_dir, 'weexplugin', 'src', 'main', 'AndroidManifest.xml');\n      } else {\n          filepath = path.join(project_dir, 'weexplugin', 'src', 'main', 'res', 'xml', 'config.xml');\n      }\n      // WEEX_HOOK_END\n    }\n\n    // None of the special cases matched, returning project_dir/file.\n    return filepath;\n}\n\n// Find out the real name of an iOS project\n// TODO: glob is slow, need a better way or caching, or avoid using more than once.\nfunction getIOSProjectname(project_dir) {\n    var matches = modules.glob.sync(path.join(project_dir, '*.xcodeproj'));\n    var iospath;\n    if (matches.length === 1) {\n        iospath = path.basename(matches[0],'.xcodeproj');\n    } else {\n        var msg;\n        if (matches.length === 0) {\n            msg = 'Does not appear to be an xcode project, no xcode project file in ' + project_dir;\n        } else {\n            msg = 'There are multiple *.xcodeproj dirs in ' + project_dir;\n        }\n        throw new Error(msg);\n    }\n    return iospath;\n}\n\n// determine if a plist file is binary\nfunction isBinaryPlist(filename) {\n    // I wish there was a synchronous way to read only the first 6 bytes of a\n    // file. This is wasteful :/\n    var buf = '' + fs.readFileSync(filename, 'utf8');\n    // binary plists start with a magic header, \"bplist\"\n    return buf.substring(0, 6) === 'bplist';\n}\n\nmodule.exports = ConfigFile;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/platforms/platforms.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar path = require('path');\nvar util = require('../cordova/util');\nvar platforms = require('./platformsConfig.json');\nvar events = require('weexpack-common').events;\n\n// Avoid loading the same platform projects more than once (identified by path)\nvar cachedApis = {};\n\n// getPlatformApi() should be the only method of instantiating the\n// PlatformProject classes for now.\nfunction getPlatformApi(platform, platformRootDir) {\n\n    // if platformRootDir is not specified, try to detect it first\n    if (!platformRootDir) {\n        var projectRootDir = util.isCordova();\n        platformRootDir = projectRootDir && path.join(projectRootDir, 'platforms', platform);\n    }\n\n    if (!platformRootDir) {\n        // If platformRootDir is still undefined, then we're probably is not inside of cordova project\n        throw new Error('Current location is not a weexpack project');\n    }\n\n    // CB-11174 Resolve symlinks first before working with root directory\n    platformRootDir = util.convertToRealPathSafe(platformRootDir);\n\n    var cached = cachedApis[platformRootDir];\n    if (cached && cached.platform == platform) return cached;\n\n    if (!platforms[platform]) throw new Error('Unknown platform ' + platform);\n\n    var PlatformApi;\n\n  //WEEK_HOOK\n    // try {\n    //     // First we need to find whether platform exposes its' API via js module\n    //     // If it does, then we require and instantiate it.\n    //     var platformApiModule = path.join(platformRootDir, 'cordova', 'Api.js');\n    //     PlatformApi = require(platformApiModule);\n    // } catch (err) {\n    //     // Check if platform already compatible w/ PlatformApi and show deprecation warning\n    //     if (err && err.code === 'MODULE_NOT_FOUND' && platforms[platform].apiCompatibleSince) {\n    //         events.emit('warn', ' Using this version of weexpack with older version of weexpack-' + platform +\n    //             ' is being deprecated. Consider upgrading to weexpack-' + platform + '@' +\n    //             platforms[platform].apiCompatibleSince + ' or newer.');\n    //     } else {\n    //         events.emit('warn', 'Error loading weexpack-'+platform);\n    //     }\n    //\n    //     PlatformApi = require('./PlatformApiPoly');\n    // }\n\n  var platformPath = platform + '_' + 'pack';\n  var platformApiPath = path.join(__dirname, platformPath, 'Api.js');\n  PlatformApi = require(platformApiPath);\n\n    var platformApi = new PlatformApi(platform, platformRootDir, events);\n    cachedApis[platformRootDir] = platformApi;\n    return platformApi;\n}\n\nfunction getRealPlatformApi(platform, platformRootDir) {\n\n  var cached; //= cachedApis[__dirname];\n  if (cached && cached.platform == platform) return cached;\n\n  if (!platforms[platform]) throw new Error('Unknown platform ' + platform);\n\n  var PlatformApi;\n  try {\n    // First we need to find whether platform exposes its' API via js module\n    // If it does, then we require and instantiate it.\n    var platformPath = platform + '_' + 'pack';\n    var platformApiPath = path.join(__dirname, platformPath, 'Api.js');\n    PlatformApi = require(platformApiPath);\n  } catch (err) {\n    // Check if platform already compatible w/ PlatformApi and show deprecation warning\n    if (err && err.code === 'MODULE_NOT_FOUND' && platforms[platform].apiCompatibleSince) {\n      events.emit('warn', ' Using this version of weexpack with older version of weexpack-' + platform +\n        ' is being deprecated. Consider upgrading to weexpack-' + platform + '@' +\n        platforms[platform].apiCompatibleSince + ' or newer.');\n    } else {\n      events.emit('warn', 'Error loading weexpack-'+platform);\n    }\n\n    PlatformApi = require('./PlatformApiPoly');\n  }\n\n  var platformApi = new PlatformApi(platform, platformRootDir, events);\n  // cachedApis[__dirname] = platformApi;\n  return platformApi;\n}\n\nmodule.exports = platforms;\n\n// We don't want these methods to be enumerable on the platforms object, because we expect enumerable properties of the\n// platforms object to be platforms.\nObject.defineProperties(module.exports, {\n    'getPlatformApi': {value: getPlatformApi, configurable: true, writable: true},\n    'getRealPlatformApi':{value: getRealPlatformApi, configurable: true, writable: true}\n});\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/platforms/PlatformApiPoly.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar Q = require('q');\nvar fs = require('fs');\nvar path = require('path');\nvar shell = require('shelljs');\nvar semver = require('semver');\n\nvar common = require('../plugman/platforms/common');\n\nvar superspawn = require('weexpack-common').superspawn;\nvar xmlHelpers = require('weexpack-common').xmlHelpers;\nvar knownPlatforms = require('./platforms');\nvar CordovaError = require('weexpack-common').CordovaError;\nvar PluginInfo = require('weexpack-common').PluginInfo;\nvar ConfigParser = require('weexpack-common').ConfigParser;\nvar PlatformJson = require('weexpack-common').PlatformJson;\nvar ActionStack = require('weexpack-common').ActionStack;\nvar PlatformMunger = require('weexpack-common').ConfigChanges.PlatformMunger;\nvar PluginInfoProvider = require('weexpack-common').PluginInfoProvider;\n\n/**\n * Class, that acts as abstraction over particular platform. Encapsulates the\n *   platform's properties and methods.\n *\n * Platform that implements own PlatformApi instance _should implement all\n *   prototype methods_ of this class to be fully compatible with cordova-lib.\n *\n * The PlatformApi instance also should define the following field:\n *\n * * platform: String that defines a platform name.\n */\nfunction PlatformApiPoly(platform, platformRootDir, events) {\n    if (!platform) throw new CordovaError('\\'platform\\' argument is missing');\n    if (!platformRootDir) throw new CordovaError('platformRootDir argument is missing');\n\n    this.root = platformRootDir;\n    this.platform = platform;\n    this.events = events || require('weexpack-common').events;\n\n    if (!(platform in knownPlatforms))\n        throw new CordovaError('Unknown platform ' + platform);\n\n    var ParserConstructor = require(knownPlatforms[platform].parser_file);\n    this._parser = new ParserConstructor(this.root);\n    this._handler = require(knownPlatforms[platform].handler_file);\n\n    this._platformJson = PlatformJson.load(this.root, platform);\n    this._pluginInfoProvider = new PluginInfoProvider();\n    this._munger = new PlatformMunger(platform, this.root, this._platformJson, this._pluginInfoProvider);\n}\n\n/**\n * Installs platform to specified directory and creates a platform project.\n *\n * @param  {String}  destinationDir  A directory, where platform should be\n *   created/installed.\n * @param  {ConfigParser} [projectConfig] A ConfigParser instance, used to get\n *   some application properties for new platform like application name, package\n *   id, etc. If not defined, this means that platform is used as standalone\n *   project and is not a part of cordova project, so platform will use some\n *   default values.\n * @param  {Object}   [options]  An options object. The most common options are:\n * @param  {String}   [options.customTemplate]  A path to custom template, that\n *   should override the default one from platform.\n * @param  {Boolean}  [options.link=false]  Flag that indicates that platform's\n *   sources will be linked to installed platform instead of copying.\n *\n * @return {Promise<PlatformApi>} Promise either fulfilled with PlatformApi\n *   instance or rejected with CordovaError.\n */\nPlatformApiPoly.createPlatform = function (destinationDir, projectConfig, options) {\n    if (!options || !options.platformDetails)\n        return Q.reject(new CordovaError('Failed to find platform\\'s \\'create\\' script. ' +\n            'Either \\'options\\' parameter or \\'platformDetails\\' option is missing'));\n\n    var templatePath = path.join(options.platformDetails.libDir, 'bin', 'templates');\n    return Q().then(function(){\n\n        copyPlatform(templatePath, destinationDir)\n        //修改source\n        if(options.ali&&options.platformDetails.platform == \"ios\"){\n            var weexPluginRootDir = path.join(destinationDir, 'Weexplugin');\n            changeSource(destinationDir)\n            changeSource(weexPluginRootDir)\n        }\n        return PlatformApiPoly;\n    })\n\n\n    // WEEX_HOOK\n    // var command = path.join(options.platformDetails.libDir, 'bin', 'create');\n    // var commandArguments = getCreateArgs(destinationDir, projectConfig, options);\n    //\n    // return superspawn.spawn(command, commandArguments,\n    //     { printCommand: true, stdio: 'inherit', chmod: true })\n    // .then(function () {\n    //     var platformApi = knownPlatforms\n    //         .getPlatformApi(options.platformDetails.platform, destinationDir);\n    //     copyCordovaSrc(options.platformDetails.libDir, platformApi.getPlatformInfo());\n    //     return platformApi;\n    // });\n};\n\nfunction changeSource (destinationDir){\n\n    var weexPluginRootDir = path.join(destinationDir);\n    var xcodeProjDir;\n    var xcodeCordovaProj;\n\n    try {\n        xcodeProjDir = fs.readdirSync(weexPluginRootDir).filter( function(e) { return e.match(/\\.xcodeproj$/i); })[0];\n        if (!xcodeProjDir) {\n            throw new CordovaError('The provided path \"' + weexPluginRootDir + '\" is not a Weex iOS project.');\n        }\n\n        var cordovaProjName = xcodeProjDir.substring(xcodeProjDir.lastIndexOf(path.sep)+1, xcodeProjDir.indexOf('.xcodeproj'));\n        xcodeCordovaProj = path.join(weexPluginRootDir, cordovaProjName);\n    } catch(e) {\n        throw new CordovaError('The provided path \"'+weexPluginRootDir+'\" is not a weexpack iOS project.');\n    }\n    var Podfile = require('./ios_pack/lib/Podfile').Podfile;\n    var project_name = xcodeCordovaProj.split('/').pop();\n    var podfileFile = new Podfile(path.join(weexPluginRootDir, Podfile.FILENAME), project_name)\n    podfileFile.writeUseAliSource()\n\n\n}\n\n\n/**\n * Updates already installed platform.\n *\n * @param  {String}  destinationDir  A directory, where existing platform\n *   installed, that should be updated.\n * @param  {Object}  [options]  An options object. The most common options are:\n * @param  {String}  [options.customTemplate]  A path to custom template, that\n *   should override the default one from platform.\n * @param  {Boolean}  [options.link=false]  Flag that indicates that platform's sources\n *   will be linked to installed platform instead of copying.\n *\n * @return {Promise<PlatformApi>} Promise either fulfilled with PlatformApi\n *   instance or rejected with CordovaError.\n */\nPlatformApiPoly.updatePlatform = function (destinationDir, options) {\n    if (!options || !options.platformDetails)\n        return Q.reject(new CordovaError('Failed to find platform\\'s \\'create\\' script. ' +\n            'Either \\'options\\' parameter or \\'platformDetails\\' option is missing'));\n\n    var command = path.join(options.platformDetails.libDir, 'bin', 'update');\n    return superspawn.spawn(command, [destinationDir],\n        { printCommand: true, stdio: 'inherit', chmod: true })\n    .then(function () {\n        var platformApi = knownPlatforms\n            .getPlatformApi(options.platformDetails.platform, destinationDir);\n        copyCordovaSrc(options.platformDetails.libDir, platformApi.getPlatformInfo());\n        return platformApi;\n    });\n};\n\n/**\n * Gets a CordovaPlatform object, that represents the platform structure.\n *\n * @return  {CordovaPlatform}  A structure that contains the description of\n *   platform's file structure and other properties of platform.\n */\nPlatformApiPoly.prototype.getPlatformInfo = function () {\n    var self = this;\n    var result = {};\n    result.locations = {\n        www: self._parser.www_dir(),\n        platformWww: path.join(self.root, 'platform_www'),\n        configXml: self._parser.config_xml(),\n        // NOTE: Due to platformApi spec we need to return relative paths here\n        cordovaJs: path.relative(self.root, self._parser.cordovajs_path.call(self.parser, self.root)),\n        cordovaJsSrc: path.relative(self.root, self._parser.cordovajs_src_path.call(self.parser, self.root))\n    };\n    result.root = self.root;\n    result.name = self.platform;\n    self.version = result.version = self.version || getPlatformVersion(self.root) || knownPlatforms[self.platform].version;\n    result.projectConfig = self._config;\n\n    return result;\n};\n\n/**\n * Updates installed platform with provided www assets and new app\n *   configuration. This method is required for CLI workflow and will be called\n *   each time before build, so the changes, made to app configuration and www\n *   code, will be applied to platform.\n *\n * @param {CordovaProject} cordovaProject A CordovaProject instance, that defines a\n *   project structure and configuration, that should be applied to platform\n *   (contains project's www location and ConfigParser instance for project's\n *   config).\n *\n * @return  {Promise}  Return a promise either fulfilled, or rejected with\n *   CordovaError instance.\n */\nPlatformApiPoly.prototype.prepare = function (cordovaProject, options) {\n    // First cleanup current config and merge project's one into own\n    var defaultConfig = path.join(this.root, 'cordova', 'defaults.xml');\n    var ownConfig = this.getPlatformInfo().locations.configXml;\n\n    var sourceCfg = cordovaProject.projectConfig;\n    // If defaults.xml is present, overwrite platform config.xml with it.\n    // Otherwise save whatever is there as defaults so it can be\n    // restored or copy project config into platform if none exists.\n    if (fs.existsSync(defaultConfig)) {\n        this.events.emit('verbose', 'Generating config.xml from defaults for platform \"' + this.platform + '\"');\n        shell.cp('-f', defaultConfig, ownConfig);\n    } else if (fs.existsSync(ownConfig)) {\n        shell.cp('-f', ownConfig, defaultConfig);\n    } else {\n        shell.cp('-f', sourceCfg.path, ownConfig);\n    }\n\n    this._munger.reapply_global_munge().save_all();\n\n    this._config = new ConfigParser(ownConfig);\n    xmlHelpers.mergeXml(cordovaProject.projectConfig.doc.getroot(),\n        this._config.doc.getroot(), this.platform, true);\n    this._config.write();\n\n    // Update own www dir with project's www assets and plugins' assets and js-files\n    this._parser.update_www(cordovaProject.locations.www);\n\n    // update project according to config.xml changes.\n    return this._parser.update_project(this._config, options);\n};\n\n/**\n * Installs a new plugin into platform. This method only copies non-www files\n *   (sources, libs, etc.) to platform. It also doesn't resolves the\n *   dependencies of plugin. Both of handling of www files, such as assets and\n *   js-files and resolving dependencies are the responsibility of caller.\n *\n * @param  {PluginInfo}  plugin  A PluginInfo instance that represents plugin\n *   that will be installed.\n * @param  {Object}  installOptions  An options object. Possible options below:\n * @param  {Boolean}  installOptions.link: Flag that specifies that plugin\n *   sources will be symlinked to app's directory instead of copying (if\n *   possible).\n * @param  {Object}  installOptions.variables  An object that represents\n *   variables that will be used to install plugin. See more details on plugin\n *   variables in documentation:\n *   https://cordova.apache.org/docs/en/4.0.0/plugin_ref_spec.md.html\n *\n * @return  {Promise}  Return a promise either fulfilled, or rejected with\n *   CordovaError instance.\n */\nPlatformApiPoly.prototype.addPlugin = function (plugin, installOptions) {\n\n    if (!plugin || !(plugin instanceof PluginInfo))\n        return Q.reject('The parameter is incorrect. The first parameter ' +\n            'should be valid PluginInfo instance');\n\n    installOptions = installOptions || {};\n    installOptions.variables = installOptions.variables || {};\n    // CB-10108 platformVersion option is required for proper plugin installation\n    installOptions.platformVersion = installOptions.platformVersion ||\n        this.getPlatformInfo().version;\n\n    var self = this;\n    var actions = new ActionStack();\n    var projectFile = this._handler.parseProjectFile && this._handler.parseProjectFile(this.root);\n\n    // gather all files needs to be handled during install\n    plugin.getFilesAndFrameworks(this.platform)\n        .concat(plugin.getAssets(this.platform))\n        .concat(plugin.getJsModules(this.platform))\n    .forEach(function(item) {\n        actions.push(actions.createAction(\n            self._getInstaller(item.itemType), [item, plugin.dir, plugin.id, installOptions, projectFile],\n            self._getUninstaller(item.itemType), [item, plugin.dir, plugin.id, installOptions, projectFile]));\n    });\n\n    // run through the action stack\n    return actions.process(this.platform, this.root)\n    .then(function () {\n        if (projectFile) {\n            projectFile.write();\n        }\n\n        // Add PACKAGE_NAME variable into vars\n        if (!installOptions.variables.PACKAGE_NAME) {\n            installOptions.variables.PACKAGE_NAME = self._handler.package_name(self.root);\n        }\n\n        self._munger\n            // Ignore passed `is_top_level` option since platform itself doesn't know\n            // anything about managing dependencies - it's responsibility of caller.\n            .add_plugin_changes(plugin, installOptions.variables, /*is_top_level=*/true, /*should_increment=*/true)\n            .save_all();\n\n        var targetDir = installOptions.usePlatformWww ?\n            self.getPlatformInfo().locations.platformWww :\n            self.getPlatformInfo().locations.www;\n\n        self._addModulesInfo(plugin, targetDir);\n    });\n};\n\n/**\n * Removes an installed plugin from platform.\n *\n * Since method accepts PluginInfo instance as input parameter instead of plugin\n *   id, caller shoud take care of managing/storing PluginInfo instances for\n *   future uninstalls.\n *\n * @param  {PluginInfo}  plugin  A PluginInfo instance that represents plugin\n *   that will be installed.\n *\n * @return  {Promise}  Return a promise either fulfilled, or rejected with\n *   CordovaError instance.\n */\nPlatformApiPoly.prototype.removePlugin = function (plugin, uninstallOptions) {\n\n    uninstallOptions = uninstallOptions || {};\n    // CB-10108 platformVersion option is required for proper plugin installation\n    uninstallOptions.platformVersion = uninstallOptions.platformVersion ||\n        this.getPlatformInfo().version;\n\n    var self = this;\n    var actions = new ActionStack();\n    var projectFile = this._handler.parseProjectFile && this._handler.parseProjectFile(this.root);\n\n    // queue up plugin files\n    plugin.getFilesAndFrameworks(this.platform)\n        .concat(plugin.getAssets(this.platform))\n        .concat(plugin.getJsModules(this.platform))\n    .forEach(function(item) {\n        actions.push(actions.createAction(\n            self._getUninstaller(item.itemType), [item, plugin.dir, plugin.id, uninstallOptions, projectFile],\n            self._getInstaller(item.itemType), [item, plugin.dir, plugin.id, uninstallOptions, projectFile]));\n    });\n\n    // run through the action stack\n    return actions.process(this.platform, this.root)\n    .then(function() {\n        if (projectFile) {\n            projectFile.write();\n        }\n\n        self._munger\n            // Ignore passed `is_top_level` option since platform itself doesn't know\n            // anything about managing dependencies - it's responsibility of caller.\n            .remove_plugin_changes(plugin, /*is_top_level=*/true)\n            .save_all();\n\n        var targetDir = uninstallOptions.usePlatformWww ?\n            self.getPlatformInfo().locations.platformWww :\n            self.getPlatformInfo().locations.www;\n\n        self._removeModulesInfo(plugin, targetDir);\n        // Remove stale plugin directory\n        // TODO: this should be done by plugin files uninstaller\n        shell.rm('-rf', path.resolve(self.root, 'Plugins', plugin.id));\n    });\n};\n\nPlatformApiPoly.prototype.updatePlugin = function (plugin, updateOptions) {\n    var self = this;\n\n    // Set up assets installer to copy asset files into platform_www dir instead of www\n    updateOptions = updateOptions || {};\n    updateOptions.usePlatformWww = true;\n\n    return this.removePlugin(plugin, updateOptions)\n    .then(function () {\n        return  self.addPlugin(plugin, updateOptions);\n    });\n};\n\n/**\n * Builds an application package for current platform.\n *\n * @param  {Object}  buildOptions  A build options. This object's structure is\n *   highly depends on platform's specific. The most common options are:\n * @param  {Boolean}  buildOptions.debug  Indicates that packages should be\n *   built with debug configuration. This is set to true by default unless the\n *   'release' option is not specified.\n * @param  {Boolean}  buildOptions.release  Indicates that packages should be\n *   built with release configuration. If not set to true, debug configuration\n *   will be used.\n * @param   {Boolean}  buildOptions.device  Specifies that built app is intended\n *   to run on device\n * @param   {Boolean}  buildOptions.emulator: Specifies that built app is\n *   intended to run on emulator\n * @param   {String}  buildOptions.target  Specifies the device id that will be\n *   used to run built application.\n * @param   {Boolean}  buildOptions.nobuild  Indicates that this should be a\n *   dry-run call, so no build artifacts will be produced.\n * @param   {String[]}  buildOptions.archs  Specifies chip architectures which\n *   app packages should be built for. List of valid architectures is depends on\n *   platform.\n * @param   {String}  buildOptions.buildConfig  The path to build configuration\n *   file. The format of this file is depends on platform.\n * @param   {String[]} buildOptions.argv Raw array of command-line arguments,\n *   passed to `build` command. The purpose of this property is to pass a\n *   platform-specific arguments, and eventually let platform define own\n *   arguments processing logic.\n *\n * @return {Promise<Object[]>} A promise either fulfilled with an array of build\n *   artifacts (application packages) if package was built successfully,\n *   or rejected with CordovaError. The resultant build artifact objects is not\n *   strictly typed and may conatin arbitrary set of fields as in sample below.\n *\n *     {\n *         architecture: 'x86',\n *         buildType: 'debug',\n *         path: '/path/to/build',\n *         type: 'app'\n *     }\n *\n * The return value in most cases will contain only one item but in some cases\n *   there could be multiple items in output array, e.g. when multiple\n *   arhcitectures is specified.\n */\nPlatformApiPoly.prototype.build = function(buildOptions) {\n    var command = path.join(this.root, 'cordova', 'build');\n    var commandArguments = getBuildArgs(buildOptions);\n    return superspawn.spawn(command, commandArguments, {\n        printCommand: true, stdio: 'inherit', chmod: true });\n};\n\n/**\n * Builds an application package for current platform and runs it on\n *   specified/default device. If no 'device'/'emulator'/'target' options are\n *   specified, then tries to run app on default device if connected, otherwise\n *   runs the app on emulator.\n *\n * @param   {Object}  runOptions  An options object. The structure is the same\n *   as for build options.\n *\n * @return {Promise} A promise either fulfilled if package was built and ran\n *   successfully, or rejected with CordovaError.\n */\nPlatformApiPoly.prototype.run = function(runOptions) {\n    var command = path.join(this.root, 'cordova', 'run');\n    var commandArguments = getBuildArgs(runOptions);\n    return superspawn.spawn(command, commandArguments, {\n        printCommand: true, stdio: 'inherit', chmod: true });\n};\n\n/**\n * Cleans out the build artifacts from platform's directory.\n *\n * @return  {Promise}  Return a promise either fulfilled, or rejected with\n *   CordovaError.\n */\nPlatformApiPoly.prototype.clean = function() {\n    var cmd = path.join(this.root, 'cordova', 'clean');\n    return superspawn.spawn(cmd, [], { printCommand: true, stdio: 'inherit', chmod: true });\n};\n\n/**\n * Performs a requirements check for current platform. Each platform defines its\n *   own set of requirements, which should be resolved before platform can be\n *   built successfully.\n *\n * @return  {Promise<Requirement[]>}  Promise, resolved with set of Requirement\n *   objects for current platform.\n */\nPlatformApiPoly.prototype.requirements = function() {\n    var modulePath = path.join(this.root, 'cordova', 'lib', 'check_reqs');\n    try {\n        return require(modulePath).check_all();\n    } catch (e) {\n        var errorMsg = 'Failed to check requirements for ' + this.platform + ' platform. ' +\n            'check_reqs module is missing for platform. Skipping it...';\n        return Q.reject(errorMsg);\n    }\n};\n\nmodule.exports = PlatformApiPoly;\n\n/**\n * Converts arguments, passed to createPlatform to command-line args to\n *   'bin/create' script for specific platform.\n *\n * @param   {ProjectInfo}  project  A current project information. The vauest\n *   which this method interested in are project.config - config.xml abstraction\n *   - and platformsLocation - to get install destination.\n * @param   {Object}       options  Set of properties for create script.\n *\n * @return  {String[]}     An array or arguments which can be passed to\n *   'bin/create'.\n */\nfunction getCreateArgs(destinationDir, projectConfig, options) {\n    var platformName = options.platformDetails.platform;\n    var platformVersion = options.platformDetails.version;\n\n    var args = [];\n    args.push(destinationDir); // output\n    args.push(projectConfig.packageName().replace(/[^\\w.]/g,'_'));\n    // CB-6992 it is necessary to normalize characters\n    // because node and shell scripts handles unicode symbols differently\n    // We need to normalize the name to NFD form since iOS uses NFD unicode form\n    var name = projectConfig.name();\n    if (platformName == 'ios') {\n        var unorm = require('unorm');\n        name = unorm.nfd(name);\n    }\n    args.push(name);\n\n    if (options.customTemplate) {\n        args.push(options.customTemplate);\n    }\n\n    if (/android|ios/.exec(platformName) &&\n        semver.gt(platformVersion, '3.3.0')) args.push('--cli');\n\n    if (options.link) args.push('--link');\n\n    if (platformName === 'android' && semver.gte(platformVersion, '4.0.0-dev')) {\n        var activityName = projectConfig.android_activityName();\n        if (activityName) {\n            args.push('--activity-name', activityName.replace(/\\W/g, ''));\n        }\n    }\n\n    return args;\n}\n\n/**\n * Reconstructs the buildOptions tat will be passed along to platform scripts.\n *   This is an ugly temporary fix. The code spawning or otherwise calling into\n *   platform code should be dealing with this based on the parsed args object.\n *\n * @param   {Object}  options  A build options set, passed to `build` method\n *\n * @return  {String[]}         An array or arguments which can be passed to\n *   `create` build script.\n */\nfunction getBuildArgs(options) {\n    // if no options passed, empty object will be returned\n    if (!options) return [];\n\n    var downstreamArgs = [];\n    var argNames =[\n        'debug',\n        'release',\n        'device',\n        'emulator',\n        'nobuild',\n        'list'\n    ];\n\n    argNames.forEach(function(flag) {\n        if (options[flag]) {\n            downstreamArgs.push('--' + flag);\n        }\n    });\n\n    if (options.buildConfig) {\n        downstreamArgs.push('--buildConfig=' + options.buildConfig);\n    }\n    if (options.target) {\n        downstreamArgs.push('--target=' + options.target);\n    }\n    if (options.archs) {\n        downstreamArgs.push('--archs=' + options.archs);\n    }\n\n    var unparsedArgs = options.argv || [];\n    return downstreamArgs.concat(unparsedArgs);\n}\n\n/**\n * Removes the specified modules from list of installed modules and updates\n *   platform_json and cordova_plugins.js on disk.\n *\n * @param   {PluginInfo}  plugin  PluginInfo instance for plugin, which modules\n *   needs to be added.\n * @param   {String}  targetDir  The directory, where updated cordova_plugins.js\n *   should be written to.\n */\nPlatformApiPoly.prototype._addModulesInfo = function(plugin, targetDir) {\n    var installedModules = this._platformJson.root.modules || [];\n\n    var installedPaths = installedModules.map(function (installedModule) {\n        return installedModule.file;\n    });\n\n    var modulesToInstall = plugin.getJsModules(this.platform)\n    .filter(function (moduleToInstall) {\n        return installedPaths.indexOf(moduleToInstall.file) === -1;\n    }).map(function (moduleToInstall) {\n        var moduleName = plugin.id + '.' + ( moduleToInstall.name || moduleToInstall.src.match(/([^\\/]+)\\.js/)[1] );\n        var obj = {\n            file: ['plugins', plugin.id, moduleToInstall.src].join('/'),\n            id: moduleName,\n            pluginId: plugin.id\n        };\n        if (moduleToInstall.clobbers.length > 0) {\n            obj.clobbers = moduleToInstall.clobbers.map(function(o) { return o.target; });\n        }\n        if (moduleToInstall.merges.length > 0) {\n            obj.merges = moduleToInstall.merges.map(function(o) { return o.target; });\n        }\n        if (moduleToInstall.runs) {\n            obj.runs = true;\n        }\n\n        return obj;\n    });\n\n    this._platformJson.root.modules = installedModules.concat(modulesToInstall);\n    if (!this._platformJson.root.plugin_metadata) {\n        this._platformJson.root.plugin_metadata = {};\n    }\n    this._platformJson.root.plugin_metadata[plugin.id] = plugin.version;\n\n    this._writePluginModules(targetDir);\n    this._platformJson.save();\n};\n\n/**\n * Removes the specified modules from list of installed modules and updates\n *   platform_json and cordova_plugins.js on disk.\n *\n * @param   {PluginInfo}  plugin  PluginInfo instance for plugin, which modules\n *   needs to be removed.\n * @param   {String}  targetDir  The directory, where updated cordova_plugins.js\n *   should be written to.\n */\nPlatformApiPoly.prototype._removeModulesInfo = function(plugin, targetDir) {\n    var installedModules = this._platformJson.root.modules || [];\n    var modulesToRemove = plugin.getJsModules(this.platform)\n    .map(function (jsModule) {\n        return  ['plugins', plugin.id, jsModule.src].join('/');\n    });\n\n    var updatedModules = installedModules\n    .filter(function (installedModule) {\n        return (modulesToRemove.indexOf(installedModule.file) === -1);\n    });\n\n    this._platformJson.root.modules = updatedModules;\n    if (this._platformJson.root.plugin_metadata) {\n        delete this._platformJson.root.plugin_metadata[plugin.id];\n    }\n\n    this._writePluginModules(targetDir);\n    this._platformJson.save();\n};\n\n/**\n * Fetches all installed modules, generates cordova_plugins contents and writes\n *   it to file.\n *\n * @param   {String}  targetDir  Directory, where write cordova_plugins.js to.\n *   Ususally it is either <platform>/www or <platform>/platform_www\n *   directories.\n */\nPlatformApiPoly.prototype._writePluginModules = function (targetDir) {\n    // Write out moduleObjects as JSON wrapped in a cordova module to cordova_plugins.js\n    var final_contents = 'cordova.define(\\'cordova/plugin_list\\', function(require, exports, module) {\\n';\n    final_contents += 'module.exports = ' + JSON.stringify(this._platformJson.root.modules, null, '    ') + ';\\n';\n    final_contents += 'module.exports.metadata = \\n';\n    final_contents += '// TOP OF METADATA\\n';\n    final_contents += JSON.stringify(this._platformJson.root.plugin_metadata || {}, null, '    ') + '\\n';\n    final_contents += '// BOTTOM OF METADATA\\n';\n    final_contents += '});'; // Close cordova.define.\n\n    shell.mkdir('-p', targetDir);\n    fs.writeFileSync(path.join(targetDir, 'cordova_plugins.js'), final_contents, 'utf-8');\n};\n\nPlatformApiPoly.prototype._getInstaller = function(type) {\n    var self = this;\n    return function (item, plugin_dir, plugin_id, options, project) {\n        var installer = self._handler[type] || common[type];\n\n        var wwwDest = options.usePlatformWww ?\n            self.getPlatformInfo().locations.platformWww :\n            self._handler.www_dir(self.root);\n\n        var installerArgs = type === 'asset' ? [wwwDest] :\n            type === 'js-module' ? [plugin_id, wwwDest]:\n            [self.root, plugin_id, options, project];\n\n        installer.install.apply(null, [item, plugin_dir].concat(installerArgs));\n    };\n};\n\nPlatformApiPoly.prototype._getUninstaller = function(type) {\n    var self = this;\n    return function (item, plugin_dir, plugin_id, options, project) {\n        var uninstaller = self._handler[type] || common[type];\n\n        var wwwDest = options.usePlatformWww ?\n            self.getPlatformInfo().locations.platformWww :\n            self._handler.www_dir(self.root);\n\n        var uninstallerArgs = (type === 'asset' || type === 'js-module') ? [wwwDest, plugin_id] :\n            [self.root, plugin_id, options, project];\n\n        uninstaller.uninstall.apply(null, [item].concat(uninstallerArgs));\n    };\n};\n\n/**\n * Copies cordova.js itself and cordova-js source into installed/updated\n *   platform's `platform_www` directory.\n *\n * @param   {String}  sourceLib    Path to platform library. Required to acquire\n *   cordova-js sources.\n * @param   {PlatformInfo}  platformInfo  PlatformInfo structure, required for\n *   detecting copied files destination.\n */\nfunction copyCordovaSrc(sourceLib, platformInfo) {\n    // Copy the cordova.js file to platforms/<platform>/platform_www/\n    // The www dir is nuked on each prepare so we keep cordova.js in platform_www\n    shell.mkdir('-p', platformInfo.locations.platformWww);\n    shell.cp('-f', path.join(platformInfo.locations.www, 'cordova.js'),\n        path.join(platformInfo.locations.platformWww, 'cordova.js'));\n\n    // Copy cordova-js-src directory into platform_www directory.\n    // We need these files to build cordova.js if using browserify method.\n    var cordovaJsSrcPath = path.resolve(sourceLib, platformInfo.locations.cordovaJsSrc);\n\n    //only exists for platforms that have shipped cordova-js-src directory\n    if(fs.existsSync(cordovaJsSrcPath)) {\n        shell.cp('-rf', cordovaJsSrcPath, platformInfo.locations.platformWww);\n    }\n}\n\nfunction copyPlatform(templateDir, projectDir){\n    var templateFiles;      // Current file\n    templateFiles = fs.readdirSync(templateDir);\n    // Remove directories, and files that are unwanted\n\n    // Copy each template file after filter\n    for (var i = 0; i < templateFiles.length; i++) {\n        var p = path.resolve(templateDir, templateFiles[i]);\n        shell.cp('-R', p, projectDir);\n    }\n}\n\n/**\n * Gets platform version from 'version' file\n *\n * @param   {String}  platformRoot  Platform location\n * @return  {String|null}           Stringified version of platform or null\n *   if it is not possible to retrieve version\n */\nfunction getPlatformVersion (platformRoot) {\n    var versionFile = path.join(platformRoot, 'cordova/version');\n\n    if (!fs.existsSync(versionFile)) {\n        return null;\n    }\n\n    var version = shell.cat(versionFile).match(/VERSION\\s=\\s[\"'](.*)[\"'];/m);\n    return version && version[1];\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/plugman/platforms/common.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar shell = require('shelljs'),\n    path  = require('path'),\n    fs    = require('fs'),\n    common;\n\nvar cordovaUtil = require('../../cordova/util');\nvar CordovaError = require('weexpack-common').CordovaError;\nvar xmlHelpers = require('weexpack-common').xmlHelpers;\n\nmodule.exports = common = {\n    package_name: function(project_dir, www_dir) {\n\n        var configPaths = [\n            // preferred location if cordova >= 3.4\n            path.join(project_dir, 'config.xml'),\n            // older location\n            path.join(www_dir || path.join(project_dir, 'www'), 'config.xml'),\n        ];\n\n        var cordovaRoot = cordovaUtil.isCordova();\n        if (cordovaRoot) {\n            // CB-10662 If we're in cli project then add project's config as a fallback\n            configPaths.push(path.join(cordovaRoot, 'config.xml'));\n        }\n\n        for (var i = 0; i < configPaths.length; i++) {\n            var configPath = configPaths[i];\n            // If no config there try next path\n            if (!fs.existsSync(configPath)) continue;\n\n            var widget_doc = xmlHelpers.parseElementtreeSync(configPath);\n            return widget_doc._root.attrib.id;\n        }\n\n        // No configs found - fail with meaningful error message\n        throw new CordovaError('Unable to find project\\'s config in any of ' +\n            'the following directories:\\n\\t' + configPaths.join('\\n\\t'));\n    },\n    // helper for resolving source paths from plugin.xml\n    resolveSrcPath:function(plugin_dir, relative_path) {\n        var full_path = path.resolve(plugin_dir, relative_path);\n        return full_path;\n    },\n    // helper for resolving target paths from plugin.xml into a cordova project\n    resolveTargetPath:function(project_dir, relative_path) {\n        var full_path = path.resolve(project_dir, relative_path);\n        return full_path;\n    },\n    copyFile:function(plugin_dir, src, project_dir, dest, link) {\n        src = module.exports.resolveSrcPath(plugin_dir, src);\n        if (!fs.existsSync(src)) throw new Error('\"' + src + '\" not found!');\n\n        // check that src path is inside plugin directory\n        var real_path = fs.realpathSync(src);\n        var real_plugin_path = fs.realpathSync(plugin_dir);\n        if (real_path.indexOf(real_plugin_path) !== 0)\n            throw new Error('\"' + src + '\" not located within plugin!');\n\n        dest = module.exports.resolveTargetPath(project_dir, dest);\n\n        // check that dest path is located in project directory\n        if (dest.indexOf(project_dir) !== 0)\n            throw new Error('\"' + dest + '\" not located within project!');\n\n        shell.mkdir('-p', path.dirname(dest));\n\n        if (link) {\n            common.symlinkFileOrDirTree(src, dest);\n        } else if (fs.statSync(src).isDirectory()) {\n            // XXX shelljs decides to create a directory when -R|-r is used which sucks. http://goo.gl/nbsjq\n            shell.cp('-Rf', src+'/*', dest);\n        } else {\n            shell.cp('-f', src, dest);\n        }\n    },\n    // Same as copy file but throws error if target exists\n    copyNewFile:function(plugin_dir, src, project_dir, dest, link) {\n        var target_path = common.resolveTargetPath(project_dir, dest);\n        if (fs.existsSync(target_path))\n            throw new Error('\"' + target_path + '\" already exists!');\n\n        common.copyFile(plugin_dir, src, project_dir, dest, !!link);\n    },\n    symlinkFileOrDirTree:function symlinkFileOrDirTree(src, dest) {\n            if (fs.existsSync(dest)) {\n                shell.rm('-Rf', dest);\n            }\n            \n            if (fs.statSync(src).isDirectory()) {\n                shell.mkdir('-p', dest);\n                fs.readdirSync(src).forEach(function(entry) {\n                    symlinkFileOrDirTree(path.join(src, entry), path.join(dest, entry));\n                });\n            }\n            else {\n                fs.symlinkSync(path.relative(fs.realpathSync(path.dirname(dest)), src), dest);\n            }\n    },\n    // checks if file exists and then deletes. Error if doesn't exist\n    removeFile:function(project_dir, src) {\n        var file = module.exports.resolveSrcPath(project_dir, src);\n        shell.rm('-Rf', file);\n    },\n    // deletes file/directory without checking\n    removeFileF:function(file) {\n        shell.rm('-Rf', file);\n    },\n    // Sometimes we want to remove some java, and prune any unnecessary empty directories\n    deleteJava:function(project_dir, destFile) {\n        common.removeFileAndParents(project_dir, destFile, 'src');\n    },\n    removeFileAndParents:function(baseDir, destFile, stopper) {\n        stopper = stopper || '.';\n        var file = path.resolve(baseDir, destFile);\n        if (!fs.existsSync(file)) return;\n\n        common.removeFileF(file);\n\n        // check if directory is empty\n        var curDir = path.dirname(file);\n\n        while(curDir !== path.resolve(baseDir, stopper)) {\n            if(fs.existsSync(curDir) && fs.readdirSync(curDir).length === 0) {\n                fs.rmdirSync(curDir);\n                curDir = path.resolve(curDir, '..');\n            } else {\n                // directory not empty...do nothing\n                break;\n            }\n        }\n    },\n    // handle <asset> elements\n    asset:{\n        install:function(asset, plugin_dir, www_dir) {\n            if (!asset.src) {\n                throw new Error('<asset> tag without required \"src\" attribute. plugin=' + plugin_dir);\n            }\n            if (!asset.target) {\n                throw new Error('<asset> tag without required \"target\" attribute');\n            }\n\n            common.copyFile(plugin_dir, asset.src, www_dir, asset.target);\n        },\n        uninstall:function(asset, www_dir, plugin_id) {\n            var target = asset.target || asset.src;\n\n            if (!target) {\n                throw new Error('<asset> tag without required \"target\" attribute');\n            }\n\n            common.removeFile(www_dir, target);\n            common.removeFileF(path.resolve(www_dir, 'plugins', plugin_id));\n        }\n    },\n    'js-module': {\n        install: function (jsModule, plugin_dir, plugin_id, www_dir) {\n            // Copy the plugin's files into the www directory.\n            var moduleSource = path.resolve(plugin_dir, jsModule.src);\n            // Get module name based on existing 'name' attribute or filename\n            // Must use path.extname/path.basename instead of path.parse due to CB-9981\n            var moduleName = plugin_id + '.' + (jsModule.name || path.basename(jsModule.src, path.extname (jsModule.src)));\n\n            // Read in the file, prepend the cordova.define, and write it back out.\n            var scriptContent = fs.readFileSync(moduleSource, 'utf-8').replace(/^\\ufeff/, ''); // Window BOM\n            if (moduleSource.match(/.*\\.json$/)) {\n                scriptContent = 'module.exports = ' + scriptContent;\n            }\n            scriptContent = 'cordova.define(\"' + moduleName + '\", function(require, exports, module) { ' + scriptContent + '\\n});\\n';\n\n            var moduleDestination = path.resolve(www_dir, 'plugins', plugin_id, jsModule.src);\n            shell.mkdir('-p', path.dirname(moduleDestination));\n            fs.writeFileSync(moduleDestination, scriptContent, 'utf-8');\n        },\n        uninstall: function (jsModule, www_dir, plugin_id) {\n            var pluginRelativePath = path.join('plugins', plugin_id, jsModule.src);\n            common.removeFileAndParents(www_dir, pluginRelativePath);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-common/src/ActionStack.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint quotmark:false */\n\nvar events = require('./events'),\n    Q = require('q');\n\nfunction ActionStack() {\n    this.stack = [];\n    this.completed = [];\n}\n\nActionStack.prototype = {\n    createAction:function(handler, action_params, reverter, revert_params) {\n        return {\n            handler:{\n                run:handler,\n                params:action_params\n            },\n            reverter:{\n                run:reverter,\n                params:revert_params\n            }\n        };\n    },\n    push:function(tx) {\n        this.stack.push(tx);\n    },\n    // Returns a promise.\n    process:function(platform) {\n        events.emit('verbose', 'Beginning processing of action stack for ' + platform + ' project...');\n\n        while (this.stack.length) {\n            var action = this.stack.shift();\n            var handler = action.handler.run;\n            var action_params = action.handler.params;\n\n            try {\n                handler.apply(null, action_params);\n            } catch(e) {\n                events.emit('warn', 'Error during processing of action! Attempting to revert...');\n                this.stack.unshift(action);\n                var issue = 'Uh oh!\\n';\n                // revert completed tasks\n                while(this.completed.length) {\n                    var undo = this.completed.shift();\n                    var revert = undo.reverter.run;\n                    var revert_params = undo.reverter.params;\n\n                    try {\n                        revert.apply(null, revert_params);\n                    } catch(err) {\n                        events.emit('warn', 'Error during reversion of action! We probably really messed up your project now, sorry! D:');\n                        issue += 'A reversion action failed: ' + err.message + '\\n';\n                    }\n                }\n                e.message = issue + e.message;\n                \n                return Q.reject(e);\n            }\n            this.completed.push(action);\n        }\n        events.emit('verbose', 'Action stack processing complete.');\n\n        return Q();\n    }\n};\n\nmodule.exports = ActionStack;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/hooks/HooksRunner.js":"/**\n Licensed to the Apache Software Foundation (ASF) under one\n or more contributor license agreements.  See the NOTICE file\n distributed with this work for additional information\n regarding copyright ownership.  The ASF licenses this file\n to you under the Apache License, Version 2.0 (the\n \"License\"); you may not use this file except in compliance\n with the License.  You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing,\n software distributed under the License is distributed on an\n \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n KIND, either express or implied.  See the License for the\n specific language governing permissions and limitations\n under the License.\n */\nvar cordovaUtil  = require('../cordova/util'),\n    events = require('weexpack-common').events,\n    Q = require('q'),\n    scriptsFinder = require('./scriptsFinder'),\n    Context = require('./Context'),\n    CordovaError = require('weexpack-common').CordovaError,\n    path = require('path'),\n    fs = require('fs'),\n    os = require('os'),\n    superspawn = require('weexpack-common').superspawn;\n\nvar isWindows = os.platform().slice(0, 3) === 'win';\n\n/**\n * Tries to create a HooksRunner for passed project root.\n * @constructor\n */\nfunction HooksRunner(projectRoot) {\n    var root = cordovaUtil.isCordova(projectRoot);\n    if (!root) throw new CordovaError('Not a Cordova project (\"' + projectRoot + '\"), can\\'t use hooks.');\n    else this.projectRoot = root;\n}\n\n/**\n * Fires all event handlers and scripts for a passed hook type.\n * Returns a promise.\n */\nHooksRunner.prototype.fire = function fire(hook, opts) {\n    if (isHookDisabled(opts, hook)) {\n        return Q('hook '+hook+' is disabled.');\n    }\n\n    // args check\n    if (!hook) {\n        throw new Error('hook type is not specified');\n    }\n    opts = this.prepareOptions(opts);\n\n    var handlers = events.listeners(hook);\n    var scripts = scriptsFinder.getHookScripts(hook, opts);\n\n    // CB-10193 Emit warning if there is any handlers subscribed to 'pre_package'\n    if (hook === 'pre_package' && (handlers.length > 0 || scripts.length > 0)) {\n        events.emit('warn', '\"pre_package\" hook is deprecated and will be removed in next Windows platform versions. ' +\n            'Please use \"after_prepare\" if you want to manipulate files in www before app will be packaged.');\n    }\n\n    // execute hook event listeners first\n    return executeEventHandlersSerially(hook, opts).then(function() {\n        // then execute hook script files\n        var context = new Context(hook, opts);\n        return runScriptsSerially(scripts, context);\n    });\n};\n\n/**\n * Refines passed options so that all required parameters are set.\n */\nHooksRunner.prototype.prepareOptions = function(opts) {\n    opts = opts || {};\n    opts.projectRoot = this.projectRoot;\n    opts.cordova = opts.cordova || {};\n    opts.cordova.platforms = opts.cordova.platforms || opts.platforms || cordovaUtil.listPlatforms(opts.projectRoot);\n    opts.cordova.platforms = opts.cordova.platforms.map(function(platform) { return platform.split('@')[0]; } );\n    opts.cordova.plugins = opts.cordova.plugins || opts.plugins || cordovaUtil.findPlugins(path.join(opts.projectRoot, 'plugins'));\n\n    try {\n        opts.cordova.version = opts.cordova.version || require('../../../package').version;\n    } catch(ex) {\n        events.emit('warn', 'HooksRunner could not load package.json: ' + ex.message);\n    }\n\n    return opts;\n};\n\nmodule.exports = HooksRunner;\n\n/**\n * Executes hook event handlers serially. Doesn't require a HooksRunner to be constructed.\n * Returns a promise.\n */\nmodule.exports.fire = globalFire;\nfunction globalFire(hook, opts) {\n    if (isHookDisabled(opts, hook)) {\n        return Q('hook '+hook+' is disabled.');\n    }\n\n    opts = opts || {};\n    return executeEventHandlersSerially(hook, opts);\n}\n\n// Returns a promise.\nfunction executeEventHandlersSerially(hook, opts) {\n    var handlers = events.listeners(hook);\n    if (handlers.length) {\n        // Chain the handlers in series.\n        return handlers.reduce(function(soFar, f) {\n            return soFar.then(function() { return f(opts); });\n        }, Q());\n    } else {\n        return Q(); // Nothing to do.\n    }\n}\n\n/**\n * Serially fires scripts either via Q(require(pathToScript)(context)) or via child_process.spawn.\n * Returns promise.\n */\nfunction runScriptsSerially (scripts, context) {\n    if (scripts.length === 0) {\n        events.emit('verbose', 'No scripts found for hook \"' + context.hook + '\".');\n    }\n    return scripts.reduce(function(prevScriptPromise, nextScript) {\n        return prevScriptPromise.then(function() {\n            return runScript(nextScript, context);\n        });\n    }, Q());\n}\n\n/**\n * Async runs single script file.\n */\nfunction runScript(script, context) {\n    if (typeof script.useModuleLoader == 'undefined') {\n        // if it is not explicitly defined whether we should use modeule loader or not\n        // we assume we should use module loader for .js files\n        script.useModuleLoader = path.extname(script.path).toLowerCase() == '.js';\n    }\n\n    var source;\n    var relativePath;\n\n    if (script.plugin) {\n        source = 'plugin ' + script.plugin.id;\n        relativePath = path.join('plugins', script.plugin.id, script.path);\n    } else if (script.useModuleLoader) {\n        source = 'config.xml';\n        relativePath = path.normalize(script.path);\n    } else {\n        source = 'hooks directory';\n        relativePath = path.join('hooks', context.hook, script.path);\n    }\n\n    events.emit('verbose', 'Executing script found in ' + source + ' for hook \"' + context.hook + '\": ' + relativePath);\n\n    if(script.useModuleLoader) {\n        return runScriptViaModuleLoader(script, context);\n    } else {\n        return runScriptViaChildProcessSpawn(script, context);\n    }\n}\n\n/**\n * Runs script using require.\n * Returns a promise. */\nfunction runScriptViaModuleLoader(script, context) {\n    if(!fs.existsSync(script.fullPath)) {\n        events.emit('warn', 'Script file does\\'t exist and will be skipped: ' + script.fullPath);\n        return Q();\n    }\n    var scriptFn = require(script.fullPath);\n    context.scriptLocation = script.fullPath;\n    context.opts.plugin = script.plugin;\n\n    // We can't run script if it is a plain Node script - it will run its commands when we require it.\n    // This is not a desired case as we want to pass context, but added for compatibility.\n    if (scriptFn instanceof Function) {\n        // If hook is async it can return promise instance and we will handle it.\n        return Q(scriptFn(context));\n    } else {\n        return Q();\n    }\n}\n\n/**\n * Runs script using child_process spawn method.\n * Returns a promise. */\nfunction runScriptViaChildProcessSpawn(script, context) {\n    var opts = context.opts;\n    var command = script.fullPath;\n    var args = [opts.projectRoot];\n\n    if (fs.statSync(script.fullPath).isDirectory()) {\n        events.emit('verbose', 'Skipped directory \"' + script.fullPath + '\" within hook directory');\n        return Q();\n    }\n\n    if (isWindows) {\n        // TODO: Make shebang sniffing a setting (not everyone will want this).\n        var interpreter = extractSheBangInterpreter(script.fullPath);\n        // we have shebang, so try to run this script using correct interpreter\n        if (interpreter) {\n            args.unshift(command);\n            command = interpreter;\n        }\n    }\n\n    var execOpts = {cwd: opts.projectRoot, printCommand: true, stdio: 'inherit'};\n    execOpts.env = {};\n    execOpts.env.CORDOVA_VERSION = require('../../package').version;\n    execOpts.env.CORDOVA_PLATFORMS = opts.platforms ? opts.platforms.join() : '';\n    execOpts.env.CORDOVA_PLUGINS = opts.plugins ? opts.plugins.join() : '';\n    execOpts.env.CORDOVA_HOOK = script.fullPath;\n    execOpts.env.CORDOVA_CMDLINE = process.argv.join(' ');\n\n    return superspawn.spawn(command, args, execOpts)\n        .catch(function(err) {\n            // Don't treat non-executable files as errors. They could be READMEs, or Windows-only scripts.\n            if (!isWindows && err.code == 'EACCES') {\n                events.emit('verbose', 'Skipped non-executable file: ' + script.fullPath);\n            } else {\n                throw new Error('Hook failed with error code ' + err.code + ': ' + script.fullPath);\n            }\n        });\n}\n\n/**\n * Extracts shebang interpreter from script' source. */\nfunction extractSheBangInterpreter(fullpath) {\n    var fileChunk;\n    var octetsRead;\n    var fileData;\n    var hookFd = fs.openSync(fullpath, 'r');\n    try {\n        // this is a modern cluster size. no need to read less\n        fileData = new Buffer(4096);\n        octetsRead = fs.readSync(hookFd, fileData, 0, 4096, 0);\n        fileChunk = fileData.toString();\n    } finally {\n        fs.closeSync(hookFd);\n    }\n\n    var hookCmd, shMatch;\n    // Filter out /usr/bin/env so that \"/usr/bin/env node\" works like \"node\".\n    var shebangMatch = fileChunk.match(/^#!(?:\\/usr\\/bin\\/env )?([^\\r\\n]+)/m);\n    if (octetsRead == 4096 && !fileChunk.match(/[\\r\\n]/))\n        events.emit('warn', 'shebang is too long for \"' + fullpath + '\"');\n    if (shebangMatch)\n        hookCmd = shebangMatch[1];\n    // Likewise, make /usr/bin/bash work like \"bash\".\n    if (hookCmd)\n        shMatch = hookCmd.match(/bin\\/((?:ba)?sh)$/);\n    if (shMatch)\n        hookCmd = shMatch[1];\n    return hookCmd;\n}\n\n\n/**\n * Checks if the given hook type is disabled at the command line option.\n * @param {Object} opts - the option object that contains command line options\n * @param {String} hook - the hook type\n * @returns {Boolean} return true if the passed hook is disabled.\n */\nfunction isHookDisabled(opts, hook) {\n    if (opts === undefined || opts.nohooks === undefined) {\n        return false;\n    }\n    var disabledHooks = opts.nohooks;\n    var length = disabledHooks.length;\n    for (var i=0; i<length; i++) {\n        if (hook.match(disabledHooks[i]) !== null) {\n            return true;\n        }\n    }\n    return false;\n}\n\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/hooks/scriptsFinder.js":"/**\n Licensed to the Apache Software Foundation (ASF) under one\n or more contributor license agreements.  See the NOTICE file\n distributed with this work for additional information\n regarding copyright ownership.  The ASF licenses this file\n to you under the Apache License, Version 2.0 (the\n \"License\"); you may not use this file except in compliance\n with the License.  You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing,\n software distributed under the License is distributed on an\n \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n KIND, either express or implied.  See the License for the\n specific language governing permissions and limitations\n under the License.\n */\n\nvar path = require('path'),\n    fs = require('fs'),\n    cordovaUtil = require('../cordova/util'),\n    events = require('weexpack-common').events,\n    PluginInfoProvider = require('weexpack-common').PluginInfoProvider,\n    ConfigParser = require('weexpack-common').ConfigParser;\n\n/**\n * Implements logic to retrieve hook script files defined in special folders and configuration\n * files: config.xml, hooks/hook_type, plugins/../plugin.xml, etc\n */\nmodule.exports  = {\n    /**\n     * Returns all script files for the hook type specified.\n     */\n    getHookScripts: function(hook, opts) {\n        // args check\n        if (!hook) {\n            throw new Error('hook type is not specified');\n        }\n        return getApplicationHookScripts(hook, opts)\n            .concat(getPluginsHookScripts(hook, opts));\n    }\n};\n\n/**\n * Returns script files defined on application level.\n * They are stored in .cordova/hooks folders and in config.xml.\n */\nfunction getApplicationHookScripts(hook, opts) {\n    // args check\n    if (!hook) {\n        throw new Error('hook type is not specified');\n    }\n    return getApplicationHookScriptsFromDir(path.join(opts.projectRoot, '.cordova', 'hooks', hook))\n        .concat(getApplicationHookScriptsFromDir(path.join(opts.projectRoot, 'hooks', hook)))\n        .concat(getScriptsFromConfigXml(hook, opts));\n}\n\n/**\n * Returns script files defined by plugin developers as part of plugin.xml.\n */\nfunction getPluginsHookScripts(hook, opts) {\n    // args check\n    if (!hook) {\n        throw new Error('hook type is not specified');\n    }\n\n    // In case before_plugin_install, after_plugin_install, before_plugin_uninstall hooks we receive opts.plugin and\n    // retrieve scripts exclusive for this plugin.\n    if(opts.plugin) {\n        events.emit('verbose', 'Finding scripts for \"' + hook + '\" hook from plugin ' + opts.plugin.id + ' on ' + opts.plugin.platform + ' platform only.');\n        // if plugin hook is not run for specific platform then use all available platforms\n        return getPluginScriptFiles(opts.plugin, hook, opts.plugin.platform  ? [opts.plugin.platform] : opts.cordova.platforms);\n    }\n\n    return getAllPluginsHookScriptFiles(hook, opts);\n}\n\n/**\n * Gets application level hooks from the directrory specified.\n */\nfunction getApplicationHookScriptsFromDir(dir) {\n    if (!(fs.existsSync(dir))) {\n        return [];\n    }\n\n    var compareNumbers = function(a, b) {\n        // TODO SG looks very complex, do we really need this?\n        return isNaN (parseInt(a, 10)) ? a.toLowerCase().localeCompare(b.toLowerCase ? b.toLowerCase(): b)\n            : parseInt(a, 10) > parseInt(b, 10) ? 1 : parseInt(a, 10) < parseInt(b, 10) ? -1 : 0;\n    };\n\n    var scripts = fs.readdirSync(dir).sort(compareNumbers).filter(function(s) {\n        return s[0] != '.';\n    });\n    return scripts.map(function (scriptPath) {\n        // for old style hook files we don't use module loader for backward compatibility\n        return { path: scriptPath, fullPath: path.join(dir, scriptPath), useModuleLoader: false };\n    });\n}\n\n/**\n * Gets all scripts defined in config.xml with the specified type and platforms.\n */\nfunction getScriptsFromConfigXml(hook, opts) {\n    var configPath = cordovaUtil.projectConfig(opts.projectRoot);\n    var configXml = new ConfigParser(configPath);\n\n    return configXml.getHookScripts(hook, opts.cordova.platforms).map(function(scriptElement) {\n        return {\n            path: scriptElement.attrib.src,\n            fullPath: path.join(opts.projectRoot, scriptElement.attrib.src)\n        };\n    });\n}\n\n/**\n * Gets hook scripts defined by the plugin.\n */\nfunction getPluginScriptFiles(plugin, hook, platforms) {\n    var scriptElements = plugin.pluginInfo.getHookScripts(hook, platforms);\n\n    return scriptElements.map(function(scriptElement) {\n        return {\n            path: scriptElement.attrib.src,\n            fullPath: path.join(plugin.dir, scriptElement.attrib.src),\n            plugin: plugin\n        };\n    });\n}\n\n/**\n * Gets hook scripts defined by all plugins.\n */\nfunction getAllPluginsHookScriptFiles(hook, opts) {\n    var scripts = [];\n    var currentPluginOptions;\n\n    var plugins = (new PluginInfoProvider()).getAllWithinSearchPath(path.join(opts.projectRoot, 'plugins'));\n\n    plugins.forEach(function(pluginInfo) {\n        currentPluginOptions = {\n            id: pluginInfo.id,\n            pluginInfo: pluginInfo,\n            dir: pluginInfo.dir\n        };\n\n        scripts = scripts.concat(getPluginScriptFiles(currentPluginOptions, hook, opts.cordova.platforms));\n    });\n    return scripts;\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/hooks/Context.js":"/**\n Licensed to the Apache Software Foundation (ASF) under one\n or more contributor license agreements.  See the NOTICE file\n distributed with this work for additional information\n regarding copyright ownership.  The ASF licenses this file\n to you under the Apache License, Version 2.0 (the\n \"License\"); you may not use this file except in compliance\n with the License.  You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing,\n software distributed under the License is distributed on an\n \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n KIND, either express or implied.  See the License for the\n specific language governing permissions and limitations\n under the License.\n */\n\nvar path = require('path');\nvar events = require('weexpack-common').events;\n\n/**\n * Creates hook script context\n * @constructor\n * @param {String} hook The hook type\n * @param {Object} opts Hook options\n * @returns {Object} */\nfunction Context(hook, opts) {\n    var prop;\n    this.hook = hook;\n\n    //create new object, to avoid affecting input opts in other places\n    //For example context.opts.plugin = Object is done, then it affects by reference\n    this.opts = {};\n    for (prop in opts) {\n    if (opts.hasOwnProperty(prop)) {\n        this.opts[prop] = opts[prop];\n      }\n    }\n    this.cmdLine =  process.argv.join(' ');\n    this.cordova = require('../cordova/cordova');\n}\n\n// As per CB-9834 we need to maintain backward compatibility and provide a compat layer\n// for plugins that still require modules, factored to cordova-common.\nvar compatMap = {\n    '../configparser/ConfigParser': function () {\n        return require('weexpack-common').ConfigParser;\n    },\n    '../util/xml-helpers': function () {\n        return require('weexpack-common').xmlHelpers;\n    }\n};\n\n/**\n * Returns a required module\n * @param {String} modulePath Module path\n * @returns {Object} */\nContext.prototype.requireCordovaModule = function (modulePath) {\n    // There is a very common mistake, when hook requires some cordova functionality\n    // using 'cordova-lib/...' path.\n    // This path will be resolved only when running cordova from 'normal' installation\n    // (without symlinked modules). If cordova-lib linked to cordova-cli this path is\n    // never resolved, so hook fails with 'Error: Cannot find module 'cordova-lib''\n    var resolvedPath = path.resolve(__dirname, modulePath.replace(/^cordova-lib/, '../../../cordova-lib'));\n    var relativePath = path.relative(__dirname, resolvedPath).replace(/\\\\/g, '/');\n    events.emit('verbose', 'Resolving module name for ' + modulePath + ' => ' + relativePath);\n\n    var compatRequire = compatMap[relativePath];\n    if (compatRequire) {\n        events.emit('warn', 'The module \"' + path.basename(relativePath) + '\" has been factored ' +\n            'into \"cordova-common\". Consider update your plugin hooks.');\n        return compatRequire();\n    }\n\n    return require(relativePath);\n};\n\nmodule.exports = Context;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/cordova/restore-util.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar cordova_util = require('./util'),\n    ConfigParser = require('weexpack-common').ConfigParser,\n    path         = require('path'),\n    Q            = require('q'),\n    fs           = require('fs'),\n    events       = require('weexpack-common').events,\n    cordova      = require('./cordova'),\n    semver      = require('semver'),\n    promiseutil = require('../util/promise-util');\n\nexports.installPluginsFromConfigXML = installPluginsFromConfigXML;\nexports.installPlatformsFromConfigXML = installPlatformsFromConfigXML;\n\n\nfunction installPlatformsFromConfigXML(platforms, opts) {\n    events.emit('verbose', 'Checking config.xml for saved platforms that haven\\'t been added to the project');\n\n    var projectHome = cordova_util.cdProjectRoot();\n    var configPath = cordova_util.projectConfig(projectHome);\n    var cfg = new ConfigParser(configPath);\n\n    var engines = cfg.getEngines(projectHome);\n    var installAllPlatforms = !platforms || platforms.length === 0;\n\n    var targets = engines.map(function(engine) {\n        var platformPath = path.join(projectHome, 'platforms', engine.name);\n        var platformAlreadyAdded = fs.existsSync(platformPath);\n\n        //if no platforms are specified we add all.\n        if ((installAllPlatforms || platforms.indexOf(engine.name) > -1) && !platformAlreadyAdded) {\n            var t = engine.name;\n            if (engine.spec) {\n                t += '@' + engine.spec;\n            }\n            return t;\n        }\n    });\n\n    if (!targets || !targets.length) {\n        return Q('No platforms found in config.xml that haven\\'t been added to the project');\n    }\n\n\n    // Run `platform add` for all the platforms separately\n    // so that failure on one does not affect the other.\n\n    // CB-9278 : Run `platform add` serially, one platform after another\n    // Otherwise, we get a bug where the following line: https://github.com/apache/cordova-lib/blob/0b0dee5e403c2c6d4e7262b963babb9f532e7d27/cordova-lib/src/util/npm-helper.js#L39\n    // gets executed simultaneously by each platform and leads to an exception being thrown\n    return promiseutil.Q_chainmap_graceful(targets, function(target) {\n        if (target) {\n            events.emit('log', 'Discovered platform \\\"' + target + '\\\" in config.xml. Adding it to the project');\n            return cordova.raw.platform('add', target, opts);\n        }\n        return Q();\n    }, function(err) {\n        events.emit('warn', err);\n    });\n}\n\n//returns a Promise\nfunction installPluginsFromConfigXML(args) {\n    events.emit('verbose', 'Checking config.xml for saved plugins that haven\\'t been added to the project');\n\n    //Install plugins that are listed on config.xml\n    var projectRoot = cordova_util.cdProjectRoot();\n    var configPath = cordova_util.projectConfig(projectRoot);\n    var cfg = new ConfigParser(configPath);\n    var plugins_dir = path.join(projectRoot, 'plugins');\n\n    // Get all configured plugins\n    var plugins = cfg.getPluginIdList();\n    if (0 === plugins.length) {\n        return Q('No plugins found in config.xml that haven\\'t been added to the project');\n    }\n\n\n    // Intermediate variable to store current installing plugin name\n    // to be able to create informative warning on plugin failure\n    var pluginName;\n\n    // CB-9560 : Run `plugin add` serially, one plugin after another\n    // We need to wait for the plugin and its dependencies to be installed\n    // before installing the next root plugin otherwise we can have common\n    // plugin dependencies installed twice which throws a nasty error.\n    return promiseutil.Q_chainmap_graceful(plugins, function(featureId) {\n        var pluginPath = path.join(plugins_dir, featureId);\n        if (fs.existsSync(pluginPath)) {\n            // Plugin already exists\n            return Q();\n        }\n        events.emit('log', 'Discovered plugin \"' + featureId + '\" in config.xml. Adding it to the project');\n        var pluginEntry = cfg.getPlugin(featureId);\n\n        // Install from given URL if defined or using a plugin id. If spec isn't a valid version or version range,\n        // assume it is the location to install from.\n        var pluginSpec = pluginEntry.spec;\n        pluginName = pluginEntry.name;\n\n        // CB-10761 If plugin spec is not specified, use plugin name\n        var installFrom = pluginSpec || pluginName;\n        if (pluginSpec && semver.validRange(pluginSpec, true))\n            installFrom = pluginName + '@' + pluginSpec;\n\n        // Add feature preferences as CLI variables if have any\n        var options = {\n            cli_variables: pluginEntry.variables,\n            searchpath: args.searchpath,\n            fetch: args.fetch || false,\n            save: args.save || false\n        };\n        var plugin = require('./plugin');\n        return plugin('add', installFrom, options);\n    }, function (error) {\n        // CB-10921 emit a warning in case of error\n        var msg = 'Failed to restore plugin \\\"' + pluginName + '\\\" from config.xml. ' +\n            'You might need to try adding it again. Error: ' + error;\n        events.emit('warn', msg);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/util/promise-util.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar Q = require('q');\n\n// Given a function and an array of values, creates a chain of promises that\n// will sequentially execute func(args[i]).\n// Returns a promise.\n//\nfunction Q_chainmap(args, func) {\n    return Q.when().then(function(inValue) {\n        return args.reduce(function(soFar, arg) {\n            return soFar.then(function(val) {\n                return func(arg, val);\n            });\n        }, Q(inValue));\n    });\n}\n\n// Behaves similar to Q_chainmap but gracefully handles failures.\n// When a promise in the chain is rejected, it will call the failureCallback and then continue the processing, instead of stopping\nfunction Q_chainmap_graceful(args, func, failureCallback) {\n    return Q.when().then(function(inValue) {\n        return args.reduce(function(soFar, arg) {\n            return soFar.then(function(val) {\n                return func(arg, val);\n            }).fail(function(err) {\n                if (failureCallback) {\n                    failureCallback(err);\n                }\n            });\n        }, Q(inValue));\n    });\n}\n\nexports.Q_chainmap = Q_chainmap;\nexports.Q_chainmap_graceful = Q_chainmap_graceful;","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/cordova/lazy_load.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n// The URL:true below prevents jshint error \"Redefinition or 'URL'.\"\n/* globals URL:true */\n\nvar path          = require('path'),\n    _             = require('underscore'),\n    fs            = require('fs'),\n    shell         = require('shelljs'),\n    platforms     = require('../platforms/platforms'),\n    events        = require('weexpack-common').events,\n    request       = require('request'),\n    config        = require('./config'),\n    HooksRunner   = require('../hooks/HooksRunner'),\n    zlib          = require('zlib'),\n    tar           = require('tar'),\n    URL           = require('url'),\n    Q             = require('q'),\n    npm           = require('npm'),\n    npmhelper     = require('../util/npm-helper'),\n    util          = require('./util'),\n    gitclone      = require('../gitclone'),\n    stubplatform  = {\n        url    : undefined,\n        version: undefined,\n        altplatform: undefined,\n        subdirectory: ''\n    };\n\nexports.cordova = cordova;\nexports.cordova_git = cordova_git;\nexports.git_clone = git_clone_platform;\nexports.cordova_npm = cordova_npm;\nexports.custom = custom;\nexports.based_on_config = based_on_config;\n\nfunction Platform(platformString) {\n    var name,\n        platform,\n        parts,\n        version;\n    if (platformString.indexOf('@') != -1) {\n        parts = platformString.split('@');\n        name = parts[0];\n        version = parts[1];\n    } else {\n        name = platformString;\n    }\n    platform = _.extend({}, platforms[name]);\n    this.name = name;\n    this.version = version || platform.version;\n    this.packageName = 'weexpack-' + name;\n    this.source = 'source' in platform ? platform.source : 'npm';\n}\n\n// Returns a promise for the path to the lazy-loaded directory.\nfunction based_on_config(project_root, platform, opts) {\n    var custom_path = config.has_custom_path(project_root, platform);\n    if (custom_path) {\n        var dot_file = config.read(project_root),\n            mixed_platforms = _.extend({}, platforms);\n        mixed_platforms[platform] = _.extend({}, mixed_platforms[platform], dot_file.lib && dot_file.lib[platform] || {});\n        return module.exports.custom(mixed_platforms, platform);\n    } else {\n        return module.exports.cordova(platform, opts);\n    }\n}\n\n// Returns a promise for the path to the lazy-loaded directory.\nfunction cordova(platform, opts) {\n    platform = new Platform(platform);\n    var use_git = platform.source === 'git';\n    if ( use_git ) {\n        return module.exports.cordova_git(platform);\n    } else {\n        return module.exports.cordova_npm(platform);\n    }\n}\n\nfunction cordova_git(platform) {\n    var mixed_platforms = _.extend({}, platforms),\n        plat;\n    if (!(platform.name in platforms)) {\n        return Q.reject(new Error('weexpack library \"' + platform.name + '\" not recognized.'));\n    }\n    plat = mixed_platforms[platform.name];\n    plat.id = 'cordova';\n\n    // We can't use a version range when getting from git, so if we have a range, find the latest release on npm that matches.\n    return util.getLatestMatchingNpmVersion(platform.packageName, platform.version).then(function (version) {\n        plat.version = version;\n        if (/^...*:/.test(plat.url)) {\n            plat.url = plat.url + ';a=snapshot;h=' + version + ';sf=tgz';\n        }\n        return module.exports.custom(mixed_platforms, platform.name);\n    });\n}\n\nfunction cordova_npm(platform) {\n    if ( !(platform.name in platforms) ) {\n        return Q.reject(new Error('weexpack library \"' + platform.name + '\" not recognized.'));\n    }\n    // Check if this version was already downloaded from git, if yes, use that copy.\n    // TODO: remove this once we fully switch to npm workflow.\n    var platdir = platforms[platform.name].altplatform || platform.name;\n    // If platform.version specifies a *range*, we need to determine what version we'll actually get from npm (the\n    // latest version that matches the range) to know what local directory to look for.\n    return util.getLatestMatchingNpmVersion(platform.packageName, platform.version).then(function (version) {\n        var git_dload_dir = path.join(util.libDirectory, platdir, 'cordova', version);\n        if (fs.existsSync(git_dload_dir)) {\n            var subdir = platforms[platform.name].subdirectory;\n            if (subdir) {\n                git_dload_dir = path.join(git_dload_dir, subdir);\n            }\n            events.emit('verbose', 'Platform files for \"' + platform.name + '\" previously downloaded not from npm. Using that copy.');\n            return Q(git_dload_dir);\n        }\n\n        // Note that because the version of npm we use internally doesn't support caret versions, in order to allow them\n        // from the command line and in config.xml, we use the actual version returned by getLatestMatchingNpmVersion().\n        return npmhelper.cachePackage(platform.packageName, version);\n    });\n}\n\n// Returns a promise for the path to the lazy-loaded directory.\nfunction custom(platforms, platform) {\n    var plat;\n    var id;\n    var uri;\n    var url;\n    var version;\n    var subdir;\n    var platdir;\n    var download_dir;\n    var tmp_dir;\n    var lib_dir;\n    var isUri;\n    if (!(platform in platforms)) {\n        return Q.reject(new Error('weexpack library \"' + platform + '\" not recognized.'));\n    }\n\n    plat = _.extend({}, stubplatform, platforms[platform]);\n    version = plat.version;\n    // Older tools can still provide uri (as opposed to url) as part of extra\n    // config to create, it should override the default url provided in\n    // platfroms.js\n    url = plat.uri || plat.url;\n    id = plat.id;\n    subdir = plat.subdirectory;\n    platdir = plat.altplatform || platform;\n    // Return early for already-cached remote URL, or for local URLs.\n    uri = URL.parse(url);\n    isUri = uri.protocol && uri.protocol[1] != ':'; // second part of conditional is for awesome windows support. fuuu windows\n    if (isUri) {\n        download_dir = path.join(util.libDirectory, platdir, id, version);\n        lib_dir = path.join(download_dir, subdir);\n        if (fs.existsSync(download_dir)) {\n            events.emit('verbose', id + ' library for \"' + platform + '\" already exists. No need to download. Continuing.');\n            return Q(lib_dir);\n        }\n    } else {\n        // Local path.\n        lib_dir = path.join(url, subdir);\n        return Q(lib_dir);\n    }\n\n    return HooksRunner.fire('before_library_download', {\n        platform:platform,\n        url:url,\n        id:id,\n        version:version\n    }).then(function() {\n        var uri = URL.parse(url);\n        var d = Q.defer();\n        npm.load(function(err) {\n            // Check if NPM proxy settings are set. If so, include them in the request() call.\n            var proxy;\n            if (uri.protocol == 'https:') {\n                proxy = npm.config.get('https-proxy');\n            } else if (uri.protocol == 'http:') {\n                proxy = npm.config.get('proxy');\n            }\n            var strictSSL = npm.config.get('strict-ssl');\n\n            // Create a tmp dir. Using /tmp is a problem because it's often on a different partition and sehll.mv()\n            // fails in this case with \"EXDEV, cross-device link not permitted\".\n            var tmp_subidr = 'tmp_' + id + '_' + process.pid + '_' + (new Date()).valueOf();\n            tmp_dir = path.join(util.libDirectory, 'tmp', tmp_subidr);\n            shell.rm('-rf', tmp_dir);\n            shell.mkdir('-p', tmp_dir);\n\n            var size = 0;\n            var request_options = {url:url};\n            if (proxy) {\n                request_options.proxy = proxy;\n            }\n            if (typeof strictSSL == 'boolean') {\n                request_options.strictSSL = strictSSL;\n            }\n            events.emit('verbose', 'Requesting ' + JSON.stringify(request_options) + '...');\n            events.emit('log', 'Downloading ' + id + ' library for ' + platform + '...');\n            var req = request.get(request_options, function(err, res, body) {\n                if (err) {\n                    shell.rm('-rf', tmp_dir);\n                    d.reject(err);\n                } else if (res.statusCode != 200) {\n                    shell.rm('-rf', tmp_dir);\n                    d.reject(new Error('HTTP error ' + res.statusCode + ' retrieving version ' + version + ' of ' + id + ' for ' + platform));\n                } else {\n                    size = body.length;\n                }\n            });\n            req.pipe(zlib.createUnzip())\n            .on('error', function(err) {\n                // Sometimes if the URL is bad (most likely unavailable version), and git-wip-us.apache.org is\n                // particularly slow at responding, we hit an error because of bad data piped to zlib.createUnzip()\n                // before we hit the request.get() callback above (with a 404 error). Handle that gracefully. It is\n                // likely that we will end up calling d.reject() for an HTTP error in the request() callback above, but\n                // in case not, reject with a useful error here.\n                d.reject(new Error('Unable to fetch platform ' + platform + '@' + version + ': Error: version not found.'));\n            })\n            .pipe(tar.Extract({path:tmp_dir}))\n            .on('error', function(err) {\n                shell.rm('-rf', tmp_dir);\n                d.reject(err);\n            })\n            .on('end', function() {\n                events.emit('verbose', 'Downloaded, unzipped and extracted ' + size + ' byte response.');\n                events.emit('log', 'Download complete');\n                var entries = fs.readdirSync(tmp_dir);\n                var entry = path.join(tmp_dir, entries[0]);\n                shell.mkdir('-p', download_dir);\n                shell.mv('-f', path.join(entry, '*'), download_dir);\n                shell.rm('-rf', tmp_dir);\n                d.resolve(HooksRunner.fire('after_library_download', {\n                    platform:platform,\n                    url:url,\n                    id:id,\n                    version:version,\n                    path: lib_dir,\n                    size:size,\n                    symlink:false\n                }));\n            });\n        });\n        return d.promise.then(function () { return lib_dir; });\n    });\n}\n\n// Returns a promise\nfunction git_clone_platform(git_url, branch) {\n    // Create a tmp dir. Using /tmp is a problem because it's often on a different partition and sehll.mv()\n    // fails in this case with \"EXDEV, cross-device link not permitted\".\n    var tmp_subidr = 'tmp_cordova_git_' + process.pid + '_' + (new Date()).valueOf();\n    var tmp_dir = path.join(util.libDirectory, 'tmp', tmp_subidr);\n    shell.rm('-rf', tmp_dir);\n    shell.mkdir('-p', tmp_dir);\n\n    return HooksRunner.fire('before_platform_clone', {\n        repository: git_url,\n        location: tmp_dir\n    }).then(function () {\n        var branchToCheckout = branch || 'master';\n        return gitclone.clone(git_url, branchToCheckout, tmp_dir);\n    }).then(function () {\n        HooksRunner.fire('after_platform_clone', {\n            repository: git_url,\n            location: tmp_dir\n        });\n        return tmp_dir;\n    }).fail(function (err) {\n        shell.rm('-rf', tmp_dir);\n        return Q.reject(err);\n    });\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/util/npm-helper.js":"/**\n Licensed to the Apache Software Foundation (ASF) under one\n or more contributor license agreements.  See the NOTICE file\n distributed with this work for additional information\n regarding copyright ownership.  The ASF licenses this file\n to you under the Apache License, Version 2.0 (the\n \"License\"); you may not use this file except in compliance\n with the License.  You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing,\n software distributed under the License is distributed on an\n \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n KIND, either express or implied.  See the License for the\n specific language governing permissions and limitations\n under the License.\n */\n\n// Helper methods to help keep npm operations separated.\n\nvar npm = require('npm'),\n    path = require('path'),\n    Q = require('q'),\n    unpack = require('./unpack'),\n    util = require('../cordova/util'),\n    cachedSettings = null,\n    cachedSettingsValues = null;\n\n/**\n * @description Calls npm.load, then initializes npm.config with the specified settings. Then executes a chain of\n * promises that rely on those npm settings, then restores npm settings back to their previous value. Use this rather\n * than passing settings to npm.load, since that only works the first time you try to load npm.\n * @param {Object} settings\n * @param {Function} promiseChain\n */\nfunction loadWithSettingsThenRestore(settings, promiseChain) {\n    return loadWithSettings(settings).then(promiseChain).finally(restoreSettings);\n}\n\nfunction loadWithSettings(settings) {\n    if (cachedSettings) {\n        throw new Error('Trying to initialize npm when settings have not been restored from a previous initialization.');\n    }\n\n    return Q.nfcall(npm.load, settings).then(function () {\n        for (var prop in settings) {\n            var currentValue = npm.config.get(prop);\n            var newValue = settings[prop];\n\n            if (currentValue !== newValue) {\n                cachedSettingsValues = cachedSettingsValues || {};\n                cachedSettings = cachedSettings || [];\n                cachedSettings.push(prop);\n                if (typeof currentValue !== 'undefined') {\n                    cachedSettingsValues[prop] = currentValue;\n                }\n                npm.config.set(prop, newValue);\n            }\n        }\n    });\n}\n\nfunction restoreSettings() {\n    if (cachedSettings) {\n        cachedSettings.forEach(function (prop) {\n            if (prop in cachedSettingsValues) {\n                npm.config.set(prop, cachedSettingsValues[prop]);\n            } else {\n                npm.config.del(prop);\n            }\n        });\n        cachedSettings = null;\n        cachedSettingsValues = null;\n    }\n}\n\n/**\n * Fetches the latest version of a package from NPM that matches the specified version. Returns a promise that\n * resolves to the directory the NPM package is located in.\n * @param packageName - name of an npm package\n * @param packageVersion - requested version or version range\n */\nfunction fetchPackage(packageName, packageVersion) {\n    // Get the latest matching version from NPM if a version range is specified\n    return WeexMarket.info(packageName).then(function(data){\n      //todo Market-Injection\n      return util.getLatestMatchingNpmVersion(data.fullname, packageVersion).then(\n        function (latestVersion) {\n          return cachePackage(packageName, latestVersion);\n        }\n      );\n    })\n}\n\n/**\n * Invokes \"npm cache add,\" and then returns a promise that resolves to a directory containing the downloaded,\n * or cached package.\n * @param packageName - name of an npm package\n * @param packageVersion - requested version (not a version range)\n */\nfunction cachePackage(packageName, packageVersion) {\n    //todo Market-Injection\n  // WEEK_HOOK\n  if(packageName !== \"weexpack-android\" && packageName !== \"weexpack-ios\") {\n    packageName = WeexMarket.info(packageName)\n  }\n  else {\n    packageName = { fullname: packageName}\n  }\n\n    return Q(packageName).then(function (data) {\n      packageName=data.fullname;\n\n      // npm.config.set('registry','http://registry.npm.alibaba-inc.com');\n      /*if(data.p){\n        npm.config.set('registry','http://registry.npm.alibaba-inc.com');\n      }\n      else{\n        npm.config.delete('registry');\n      }*/\n        var registry=data.p?'http://registry.npm.alibaba-inc.com':'http://registry.npm.taobao.org/';\n        var cacheDir = path.join(util.libDirectory, 'npm_cache');\n\n        // If already cached, use that rather than calling 'npm cache add' again.\n        var packageCacheDir = path.resolve(cacheDir, packageName, packageVersion);\n        var packageTGZ = path.resolve(packageCacheDir, 'package.tgz');\n        if (util.existsSync(packageTGZ)) {\n            return unpack.unpackTgz(packageTGZ, path.resolve(packageCacheDir, 'package'));\n        }\n\n        // Load with NPM configuration\n        return loadWithSettingsThenRestore({'cache': cacheDir,\"registry\":registry},\n            function () {\n                // Invoke NPM Cache Add\n                return Q.ninvoke(npm.commands, 'cache', ['add', (packageName + '@' + packageVersion)]).then(\n                    function (info) {\n                        var packageDir = path.resolve(npm.cache, info.name, info.version, 'package');\n                        var packageTGZ = path.resolve(npm.cache, info.name, info.version, 'package.tgz');\n                        return unpack.unpackTgz(packageTGZ, packageDir);\n                    }\n                );\n            }\n        );\n    });\n}\nmodule.exports.invokeNpm=function(){\n\n}\nmodule.exports.loadWithSettingsThenRestore = loadWithSettingsThenRestore;\nmodule.exports.fetchPackage = fetchPackage;\nmodule.exports.cachePackage = cachePackage;\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/util/unpack.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n// commands for packing and unpacking tarballs\n// this file is used by lib/cache.js\n\nvar events = require('weexpack-common').events,\n    fs     = require('fs'),\n    Q      = require('q'),\n    tar    = require('tar'),\n    zlib   = require('zlib');\n\nexports.unpackTgz = unpackTgz;\n\n// Returns a promise for the path to the unpacked tarball (unzip + untar).\nfunction unpackTgz(package_tgz, unpackTarget) {\n    return Q.promise(function(resolve, reject) {\n        var extractOpts = { type: 'Directory', path: unpackTarget, strip: 1 };\n\n        fs.createReadStream(package_tgz)\n        .on('error', function (err) {\n            events.emit('warn', 'Unable to open tarball ' + package_tgz + ': ' + err);\n            reject(err);\n        })\n        .pipe(zlib.createUnzip())\n        .on('error', function (err) {\n            events.emit('warn', 'Error during unzip for ' + package_tgz + ': ' + err);\n            reject(err);\n        })\n        .pipe(tar.Extract(extractOpts))\n        .on('error', function(err) {\n            events.emit('warn', 'Error during untar for ' + package_tgz + ': ' + err);\n            reject(err);\n        })\n        .on('end', resolve);\n    })\n    .then(function() {\n        return unpackTarget;\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/plugin/revoke.js":"const fs = require('fs');\n\nmodule.exports = function revokePatch(file, patch) {\n  fs.writeFileSync(file, fs\n      .readFileSync(file, 'utf8')\n      .replace(patch.patch, '')\n  );\n};","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/plugin/uninstall.js":"var npm = require(\"npm\");\nvar utils = require(\"../utils\");\nvar npmHelper = require(\"../utils/npm\")\nvar path = require(\"path\");\nvar shell = require('shelljs');\nvar fs = require(\"fs\");\n\nvar gradle = require(\"./gradle\")\nvar podfile = require(\"./podfile\")\nvar cordovaUtils = require('../../lib/src/cordova/util')\n\n\nvar cordova_lib = require('../../lib'),\n    cordova = cordova_lib.cordova;\n\nvar cli = require(\"../cli\")\n\nfunction uninstall(pluginName, args){\n  var version;\n  var target = pluginName\n  if(/@/ig.test(pluginName)){\n    var temp = pluginName.split(\"@\")\n    pluginName = temp[0];\n    version = temp[1]\n  }\n\n  var dir = process.cwd();\n\n  //get the lastest version\n  if(!version){\n    npmHelper.getLastestVersion(pluginName, function(version){\n\n      utils.isNewVersionPlugin(pluginName, version, function(result){\n\n        if(result){\n          handleUninstall(dir, pluginName, version,  result)\n          if(result.pluginDependencies){\n            for(var pn in result.pluginDependencies){\n              uninstall(pn, result.pluginDependencies[pn])\n            }\n          }\n        }\n        else{\n          cli(args)\n          //cordova.raw[\"plugin\"](\"remove\", [target]);\n        }\n      })\n    })\n  }\n  else{\n    utils.isNewVersionPlugin(pluginName,version, function(result){\n      if(result){\n        handleUninstall(dir, pluginName, version, result)\n        if(result.pluginDependencies){\n          if(result.pluginDependencies){\n            for(var pn in result.pluginDependencies){\n              uninstall(pn, result.pluginDependencies[pn])\n            }\n          }\n        }\n      }\n      else{\n        cli(args)\n        //cordova.raw[\"plugin\"](\"remove\", [target]);\n      }\n    })\n  }\n\n  //判断是否是新版本\n\n}\n\n\nfunction handleUninstall(dir, pluginName, version, option){\n  //check out the type of current project\n  var project\n  if(project = utils.isIOSProject(dir)){\n    if(!fs.existsSync(path.join(dir,\"Podfile\"))){\n      console.log(\"can't find Podfile file\");\n      return ;\n    }\n    var name = option.ios&&option.ios.name?option.ios.name:pluginName\n    var iosVersion =  option.ios&&option.ios.version || version\n    const buildPatch = podfile.makeBuildPatch(name, iosVersion);\n    podfile.revokePatch(path.join(dir,\"Podfile\"), buildPatch);\n    console.log(name +\" has removed in ios project\")\n  }\n  else if (utils.isAndroidProject(dir)){\n    var name = option.android&&option.android.name?option.android.name:pluginName\n    var androidVersion =  option.android&&option.android.version || version\n    const buildPatch = gradle.makeBuildPatch(name, androidVersion, option.android.groupId ||\"\");\n    gradle.revokePatch(path.join(dir,\"build.gradle\"), buildPatch);\n    console.log(name +\" has removed in android\")\n  }\n  //cordova工程\n  else if(cordovaUtils.isCordova(dir)) {\n    //1111\n    var platformList = cordovaUtils.listPlatforms(dir);\n    for (var i = 0; i < platformList.length; i++) {\n      uninstallInPackage(dir, pluginName, version)\n      handleUninstall(path.join(dir,\"platforms\", platformList[i].toLowerCase()), pluginName, version, option)\n    }\n  }\n  else if(fs.existsSync(path.join(dir,\"package.json\"))){\n    uninstallInPackage(dir, pluginName, version)\n  }\n  else {\n    console.log(\"can't recognize type of this project\")\n  }\n\n}\n\nfunction uninstallInPackage(dir, pluginName, version){\n  var p = path.join(dir,\"package.json\")\n  if(fs.existsSync(p)){\n    var pkg = require(p);\n    if(pkg.dependencies[pluginName]){\n      delete  pkg.dependencies[pluginName]\n    }\n    fs.writeFileSync(p, JSON.stringify(pkg, null, 4));\n  }\n}\n\n\nmodule.exports = uninstall\n\n\n\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/src/publish/weexpack-hook.js":"var fs = require('fs');\nvar path = require('path');\nif (typeof self !== 'undefined') {\n  try {\n    fs.symlinkSync(__dirname, path.join(path.dirname(__dirname), self.name))\n  } catch (e) {\n    console.info('symlink name error!')\n  }\n}\ntry {\n  deps.forEach(function (d) {\n    var entry;\n    try {\n      entry = require.resolve(d.fullname);\n    } catch (e) {\n    }\n    if (entry) {\n      var basePath = entry.substr(0, entry.indexOf(d.fullname) + d.fullname.length);\n      var pkgPath = path.join(basePath, 'package.json');\n      var pkg = JSON.parse(fs.readFileSync(pkgPath));\n      pkg.name = d.name;\n      fs.writeFileSync(pkgPath, JSON.stringify(pkg), null, 4);\n      var newPath = basePath.replace(new RegExp(d.fullname + '$'), d.name);\n      if (!fs.existsSync(newPath)) {\n        fs.symlinkSync(basePath, newPath)\n      }\n    }\n\n  });\n} catch (e) {\n  console.log('namespace fix error')\n}\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/weexapp/tools/webpack.config.plugin.js":"// only build plugin module\nrequire('webpack')\nrequire('weex-loader')\n\nvar path = require('path');\nvar fs=require('fs');\n\nlet root = process.cwd();\n\nmodule.exports = {\n  entry: {\n    plugins: [path.join(root,'plugins/plugin_bundle.js'),path.join(root,'web/js/init.js')],\n  },\n  output: {\n    path: path.join(root,'web'),\n    filename: 'index.js'\n  },\n  devtool:'inline-source-map',\n  module: {\n    loaders: [\n      {\n        test: /\\.js(\\?[^?]+)?$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader?presets[]=es2015',\n      },\n      {\n        test: /\\.we(\\?[^?]+)?$/,\n        loader: 'weex-loader',\n      },\n      {\n        test: /\\.vue(\\?[^?]+)?$/,\n        loader: 'vue',\n      }\n    ]\n  },\n  \n  /*plugins: [\n    new webpack.optimize.UglifyJsPlugin( {\n      minimize : true,\n      sourceMap : true,\n      mangle: true,\n      compress: {\n        warnings: false\n      }\n    } )\n  ]*/\n  \n}","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack/lib/src/cordova/create.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar create = require('weexpack-create');\nvar events = require('weexpack-common').events;\n\nmodule.exports = function(dir, optionalId, optionalName, cfg, extEvents){\n    if (extEvents) {\n        return create(dir, optionalId, optionalName, cfg, extEvents);\n    } else {\n        return create(dir, optionalId, optionalName, cfg, events);\n    }\n};\n\n/* If we do not pass in extEvents, then CordovaLogger will set up the listeners\ninside of cordova-create. That means we'll log everything always.  By passing in\na dummy cordova-common.events EventEmitter with no listeners, then cordova-lib\nwon't log in the create tests. When cordova-cli uses cordova-lib, it will setup\nthe listeners for events using CordovaLogger.  */\n","/home/travis/build/npmtest/node-npmtest-weexpack/node_modules/weexpack-create/index.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar path          = require('path'),\n    fs            = require('fs'),\n    shell         = require('shelljs'),\n    events        = require('weexpack-common').events,\n    Q             = require('q'),\n    CordovaError  = require('weexpack-common').CordovaError,\n    ConfigParser  = require('weexpack-common').ConfigParser,\n    fetch         = require('cordova-fetch'),\n    url           = require('url'),\n    validateIdentifier = require('valid-identifier'),\n    CordovaLogger = require('weexpack-common').CordovaLogger.get();\n// Global configuration paths\nvar global_config_path = process.env.CORDOVA_HOME;\nif (!global_config_path) {\n    var HOME = process.env[(process.platform.slice(0, 3) == 'win') ? 'USERPROFILE' : 'HOME'];\n    global_config_path = path.join(HOME, '.cordova');\n}\n/**\n * Sets up to forward events to another instance, or log console.\n * This will make the create internal events visible outside\n * @param  {EventEmitter} externalEventEmitter An EventEmitter instance that will be used for\n *   logging purposes. If no EventEmitter provided, all events will be logged to console\n * @return {EventEmitter} \n */ \nfunction setupEvents(externalEventEmitter) {\n    if (externalEventEmitter) {\n        // This will make the platform internal events visible outside\n        events.forwardEventsTo(externalEventEmitter);\n    }\n    // There is no logger if external emitter is not present,\n    // so attach a console logger\n    else { \n        CordovaLogger.subscribe(events);\n    }\n    return events;\n}\n\n/**\n * Usage:\n * @dir - directory where the project will be created. Required.\n * @optionalId - app id. Required (but be \"undefined\")\n * @optionalName - app name. Required (but can be \"undefined\"). \n * @cfg - extra config to be saved in .cordova/config.json Required (but can be \"{}\").\n * @extEvents - An EventEmitter instance that will be used for logging purposes. Required (but can be \"undefined\"). \n **/\n// Returns a promise.\nmodule.exports = function(dir, optionalId, optionalName, cfg, extEvents) {\n    var argumentCount = arguments.length;\n    return Q.fcall(function() {\n        events = setupEvents(extEvents);\n\n        if (!dir) {\n            throw new CordovaError('Directory not specified. See `weexpack --help`.');\n        }\n\n        //read projects .cordova/config.json file for project settings\n        var configFile = dotCordovaConfig(dir);\n\n        //if data exists in the configFile, lets combine it with cfg\n        //cfg values take priority over config file\n        if(configFile) {\n            var finalConfig = {};\n            for(var key1 in configFile) {\n                finalConfig[key1] = configFile[key1];\n            }\n\n            for(var key2 in cfg) {\n                finalConfig[key2] = cfg[key2];\n            }\n\n            cfg = finalConfig;\n        }\n\n        if (!cfg) {\n            throw new CordovaError('Must provide a project configuration.');\n        } else if (typeof cfg == 'string') {\n            cfg = JSON.parse(cfg);\n        }\n\n        if (optionalId) cfg.id = optionalId;\n        if (optionalName) cfg.name = optionalName;\n\n        // Make absolute.\n        dir = path.resolve(dir);\n\n        // dir must be either empty except for .cordova config file or not exist at all..\n        var sanedircontents = function (d) {\n            var contents = fs.readdirSync(d);\n            if (contents.length === 0) {\n                return true;\n            } else if (contents.length == 1) {\n                if (contents[0] == '.cordova') {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        if (fs.existsSync(dir) && !sanedircontents(dir)) {\n            throw new CordovaError('Path already exists and is not empty: ' + dir);\n        }\n\n        if (cfg.id && !validateIdentifier(cfg.id)) {\n            throw new CordovaError('App id contains a reserved word, or is not a valid identifier.');\n        }\n\n\n        // This was changed from \"uri\" to \"url\", but checking uri for backwards compatibility.\n        cfg.lib = cfg.lib || {};\n        cfg.lib.www = cfg.lib.www || {};\n        cfg.lib.www.url = cfg.lib.www.url || cfg.lib.www.uri;\n\n        if (!cfg.lib.www.url) {\n                cfg.lib.www.url = path.join(__dirname,'templates');\n        }\n\n        // TODO (kamrik): extend lazy_load for retrieval without caching to allow net urls for --src.\n        cfg.lib.www.version = cfg.lib.www.version || 'not_versioned';\n        cfg.lib.www.id = cfg.lib.www.id || 'dummy_id';\n\n        // Make sure that the source www/ is not a direct ancestor of the\n        // target www/, or else we will recursively copy forever. To do this,\n        // we make sure that the shortest relative path from source-to-target\n        // must start by going up at least one directory or with a drive\n        // letter for Windows.\n        var rel_path = path.relative(cfg.lib.www.url, dir);\n        var goes_up = rel_path.split(path.sep)[0] == '..';\n\n        if (!(goes_up || rel_path[1] == ':')) {\n            throw new CordovaError(\n                'Project dir \"' + dir +\n                '\" must not be created at/inside the template used to create the project \"' +\n                cfg.lib.www.url + '\".'\n            );\n        }\n    })\n    .then(function() {\n        // Finally, Ready to start!\n        events.emit('log', 'Creating a new weex project.');\n\n        // Strip link and url from cfg to avoid them being persisted to disk via .cordova/config.json.\n        // TODO: apparently underscore has no deep clone.  Replace with lodash or something. For now, abuse JSON.\n        var cfgToPersistToDisk = JSON.parse(JSON.stringify(cfg));\n\n        delete cfgToPersistToDisk.lib.www;\n        if (Object.keys(cfgToPersistToDisk.lib).length === 0) {\n            delete cfgToPersistToDisk.lib;\n        }\n\n        // Update cached version of config.json\n        writeToConfigJson(dir, cfgToPersistToDisk, false);\n    })\n    .then(function() {\n        var gitURL;\n        var branch;\n        var parseArr;\n        var packageName;\n        var packageVersion;\n        var isGit;\n        var isNPM;\n\n        //If symlink, don't fetch\n        if (!!cfg.lib.www.link) {\n            events.emit('verbose', 'Symlinking assets.');\n            return Q(cfg.lib.www.url);\n        }\n\n        events.emit('verbose', 'Copying assets.\"');\n        isGit = cfg.lib.www.template && isUrl(cfg.lib.www.url);\n        isNPM = cfg.lib.www.template && (cfg.lib.www.url.indexOf('@') > -1 || !fs.existsSync(path.resolve(cfg.lib.www.url)));\n\n        //Always use cordova fetch to obtain the npm or git template\n        if (isGit || isNPM) {\n            //Saved to .Cordova folder (ToDo: Delete installed template after using)\n            //ToDo: @carynbear properly label errors from fetch as such\n            var tempDest = global_config_path;\n            events.emit('log', 'Using weexpack-fetch for '+ cfg.lib.www.url);\n            return fetch(cfg.lib.www.url, tempDest, {})\n            .fail(function(err){\n                events.emit('error', '\\033[1m \\033[31m Error from Cordova Fetch: ' + err.message);\n                if (options.verbose) {\n                    console.trace();\n                }\n                throw err;\n            });\n        //If assets are not online, resolve as a relative path on local computer\n        } else {\n            cfg.lib.www.url = path.resolve(cfg.lib.www.url);\n            return Q(cfg.lib.www.url);\n        }\n    }).then(function(input_directory) {\n        var import_from_path = input_directory;\n\n        //handle when input wants to specify sub-directory (specified in index.js as \"dirname\" export); \n        var isSubDir = false;\n        try {\n            // Delete cached require incase one exists\n            delete require.cache[require.resolve(input_directory)];\n            var templatePkg = require(input_directory);\n            if (templatePkg && templatePkg.dirname){\n                import_from_path = templatePkg.dirname;\n                isSubDir = true;\n            }\n        } catch (e) {\n            events.emit('verbose', 'index.js does not specify valid sub-directory: ' + input_directory);\n            isSubDir = false;\n        }\n\n        if (!fs.existsSync(import_from_path)) {\n            throw new CordovaError('Could not find directory: ' +\n                import_from_path);\n        }\n\n        var paths = {};\n\n        // get stock config.xml, used if template does not contain config.xml\n        paths.configXml = path.join(__dirname, 'templates', 'config.xml');\n\n        // get stock www; used if template does not contain www\n        paths.www = path.join(__dirname, 'templates', 'src');\n\n        // get stock hooks; used if template does not contain hooks\n        paths.hooks = path.join(__dirname, 'templates', 'hooks');\n        \n        // ToDo: get stock package.json if template does not contain package.json;\n\n        var dirAlreadyExisted = fs.existsSync(dir);\n        if (!dirAlreadyExisted) {\n            fs.mkdirSync(dir);\n        }\n        try {\n\n            // Copy files from template to project\n            if (cfg.lib.www.template){\n                copyTemplateFiles(import_from_path, dir, isSubDir);\n            }\n            else {\n                copyTemplateFiles(import_from_path, dir, isSubDir);\n            }\n\n\n            // If --link, link merges, hooks, www, and config.xml (and/or copy to root)\n            if (!!cfg.lib.www.link)\n                linkFromTemplate(import_from_path, dir);\n\n            // If following were not copied/linked from template, copy from stock app hello world\n            copyIfNotExists(paths.www, path.join(dir, 'src'));\n            copyIfNotExists(paths.hooks, path.join(dir, 'hooks'));\n            var configXmlExists = projectConfig(dir); //moves config to root if in www\n            if (paths.configXml && !configXmlExists) {\n                shell.cp(paths.configXml, path.join(dir, 'config.xml'));\n            }\n        } catch (e) {\n            if (!dirAlreadyExisted) {\n                shell.rm('-rf', dir);\n            }\n            if (process.platform.slice(0, 3) == 'win' && e.code == 'EPERM')  {\n                throw new CordovaError('Symlinks on Windows require Administrator privileges');\n            }\n            throw e;\n        }\n\n        var pkgjsonPath = path.join(dir, 'package.json');\n        // Update package.json name and version fields\n        if (fs.existsSync(pkgjsonPath)) {\n            var pkgjson = require(pkgjsonPath);\n            if (cfg.name) {\n                pkgjson.name = cfg.name.toLowerCase();\n            }\n            pkgjson.version = '1.0.0';\n            fs.writeFileSync(pkgjsonPath, JSON.stringify(pkgjson, null, 4), 'utf8');\n        }\n\n        // Create basic project structure.\n        if (!fs.existsSync(path.join(dir, 'platforms')))\n            shell.mkdir(path.join(dir, 'platforms'));\n\n        if (!fs.existsSync(path.join(dir, 'plugins')))\n            shell.mkdir(path.join(dir, 'plugins'));\n\n        var configPath = path.join(dir, 'config.xml');\n        // only update config.xml if not a symlink\n        if(!fs.lstatSync(configPath).isSymbolicLink()) {\n            // Write out id and name to config.xml; set version to 1.0.0 (to match package.json default version)\n            var conf = new ConfigParser(configPath);\n            if (cfg.id) conf.setPackageName(cfg.id);\n            if (cfg.name) conf.setName(cfg.name);\n            conf.setVersion('1.0.0');\n            conf.write();\n        }  \n    });\n};\n\n/**\n * Recursively copies folder to destination if folder is not found in destination (including symlinks).\n * @param  {string} src for copying\n * @param  {string} dst for copying\n * @return No return value\n */\nfunction copyIfNotExists(src, dst) {\n    if (!fs.existsSync(dst) && src) {\n        shell.mkdir(dst);\n        shell.cp('-R', path.join(src, '*'), dst);\n    }\n}\n\n/**\n * Copies template files, and directories into a Cordova project directory.\n * If the template is a www folder, the www folder is simply copied\n * Otherwise if the template exists in a subdirectory everything is copied\n * Otherwise package.json, RELEASENOTES.md, .git, NOTICE, LICENSE, COPYRIGHT, and .npmignore are not copied over.\n * A template directory, and project directory must be passed.\n * templateDir - Template directory\n * projectDir - Project directory\n * isSubDir - boolean is true if template has subdirectory structure (see code around line 229)\n */\nfunction copyTemplateFiles(templateDir, projectDir, isSubDir) {\n    var copyPath;\n    // if template is a www dir\n    if (path.basename(templateDir) === 'www') {\n        copyPath = path.resolve(templateDir);\n        shell.cp('-R', copyPath, projectDir);\n    } else {\n        var templateFiles;      // Current file\n        templateFiles = fs.readdirSync(templateDir);\n        // Remove directories, and files that are unwanted\n        if (!isSubDir) {\n            var excludes = ['RELEASENOTES.md' , '.git', 'NOTICE', 'LICENSE', 'COPYRIGHT', '.npmignore', 'weex-src'];\n            templateFiles = templateFiles.filter( function (value) { \n                return excludes.indexOf(value) < 0; \n            }); \n        }\n        // create src/index.we not index.vue\n        var isForceWeFile = process.argv.indexOf('--we')>0;\n        // Copy each template file after filters\n        for (var i = 0; i < templateFiles.length; i++) {\n            copyPath = path.resolve(templateDir, templateFiles[i]);   \n            if (isForceWeFile && templateFiles[i].indexOf('src') >= 0) {\n              copyPath = path.resolve(templateDir, 'weex-src/index.we');\n              shell.cp('-R', copyPath, path.join(projectDir, 'src'));\n            } else if(isForceWeFile && templateFiles[i] == 'web') {\n              // shell.cp('-R', copyPath, projectDir);\n              shell.cp('-Rf', path.resolve(templateDir, 'weex-src/web'), projectDir);\n            } else {\n              shell.cp('-R', copyPath, projectDir);\n            }\n          \n            \n        }\n        \n        \n    }  \n}\n\n/**\n * @param  {String} value\n * @return {Boolean} is the input value a url?\n */\nfunction isUrl(value) {\n    var u = value && url.parse(value);\n    return !!(u && u.protocol && u.protocol.length > 2); // Account for windows c:/ paths\n}\n\n/**\n * Find config file in project directory or www directory\n * If file is in www directory, move it outside\n * @param  {String} project directory to be searched\n * @return {String or False} location of config file; if none exists, returns false\n */\nfunction projectConfig(projectDir) {\n    var rootPath = path.join(projectDir, 'config.xml');\n    var wwwPath = path.join(projectDir, 'www', 'config.xml');\n    if (fs.existsSync(rootPath)) {\n        return rootPath;\n    } else if (fs.existsSync(wwwPath)) {\n        fs.renameSync(wwwPath, rootPath);\n        return wwwPath;\n    }\n    return false;\n}\n\n/**\n * Retrieve and read the .cordova/config file of a cordova project\n * \n * @param  {String} project directory\n * @return {JSON data} config file's contents \n */\nfunction dotCordovaConfig(project_root) {\n    var configPath = path.join(project_root, '.cordova', 'config.json');\n    if (!fs.existsSync(configPath)) {\n        data = '{}';\n    } else {\n        data = fs.readFileSync(configPath, 'utf-8');\n    }\n    return JSON.parse(data);\n}\n\n/**\n * Write opts to .cordova/config.json\n * \n * @param  {String} project directory\n * @param  {Object} opts containing the additions to config.json\n * @param  {Boolean} autopersist option\n * @return {JSON Data}\n */\nfunction writeToConfigJson(project_root, opts, autoPersist) {\n    var json = dotCordovaConfig(project_root);\n    for (var p in opts) {\n        json[p] = opts[p];\n    }\n    if (autoPersist) {\n        var configPath = path.join(project_root, '.cordova', 'config.json');\n        var contents = JSON.stringify(json, null, 4);\n        // Don't write the file for an empty config.\n        if (contents != '{}' || fs.existsSync(configPath)) {\n            shell.mkdir('-p', path.join(project_root, '.cordova'));\n            fs.writeFileSync(configPath, contents, 'utf-8');\n        }\n        return json;\n    } else {\n        return json; \n    } \n}\n\n/**\n * Removes existing files and symlinks them if they exist.\n * Symlinks folders: www, merges, hooks \n * Symlinks file: config.xml (but only if it exists outside of the www folder)\n * If config.xml exists inside of template/www, COPY (not link) it to project/\n * */\n function linkFromTemplate(templateDir, projectDir) {\n    var linkSrc, linkDst, linkFolders, copySrc, copyDst;\n    function rmlinkSync(src, dst, type) {\n        if (src && dst) {\n            if (fs.existsSync(dst)) {\n                shell.rm('-rf', dst);\n            }\n            if (fs.existsSync(src)) {\n                fs.symlinkSync(src, dst, type);\n            }\n        }\n    } \n    // if template is a www dir\n    if (path.basename(templateDir) === 'www') {\n        linkSrc = path.resolve(templateDir);\n        linkDst = path.join(projectDir, 'www');\n        rmlinkSync(linkSrc, linkDst, 'dir');\n        copySrc = path.join(templateDir, 'config.xml');\n    } else {\n        linkFolders = ['www', 'merges', 'hooks'];\n        // Link each folder\n        for (var i = 0; i < linkFolders.length; i++) {\n            linkSrc = path.join(templateDir, linkFolders[i]);\n            linkDst = path.join(projectDir, linkFolders[i]);\n            rmlinkSync(linkSrc, linkDst, 'dir');\n        }\n        linkSrc = path.join(templateDir, 'config.xml');\n        linkDst = path.join(projectDir, 'config.xml');\n        rmlinkSync(linkSrc, linkDst, 'file');\n        copySrc = path.join(templateDir, 'www', 'config.xml');\n    }\n    // if template/www/config.xml then copy to project/config.xml\n    copyDst = path.join(projectDir, 'config.xml');\n    if (!fs.existsSync(copyDst) && fs.existsSync(copySrc)) {\n        shell.cp(copySrc, projectDir);\n    }\n }\n"}